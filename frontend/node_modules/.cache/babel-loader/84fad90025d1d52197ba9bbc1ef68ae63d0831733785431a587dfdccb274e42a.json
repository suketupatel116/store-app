{"ast":null,"code":"var _groups, _groupId;\nimport { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */\nexport function createOverflowManager() {\n  // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n  // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n  const sizeCache = new Map();\n  let container;\n  let overflowMenu;\n  // Set as true when resize observer is observing\n  let observing = false;\n  // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n  // Initially true to force dispatch on first mount\n  let forceDispatch = true;\n  const options = {\n    padding: 10,\n    overflowAxis: 'horizontal',\n    overflowDirection: 'end',\n    minimumVisible: 0,\n    onUpdateItemVisibility: () => undefined,\n    onUpdateOverflow: () => undefined\n  };\n  const overflowItems = {};\n  const overflowDividers = {};\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries[0] || !container) {\n      return;\n    }\n    update();\n  });\n  const getNextItem = (queueToDequeue, queueToEnqueue) => {\n    const nextItem = queueToDequeue.dequeue();\n    queueToEnqueue.enqueue(nextItem);\n    return overflowItems[nextItem];\n  };\n  const createGroupManager = () => {\n    const groupVisibility = {};\n    const groups = {};\n    function updateGroupVisibility(groupId) {\n      const group = groups[groupId];\n      if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n        groupVisibility[groupId] = 'overflow';\n      } else if (group.visibleItemIds.size === 0) {\n        groupVisibility[groupId] = 'hidden';\n      } else {\n        groupVisibility[groupId] = 'visible';\n      }\n    }\n    function isGroupVisible(groupId) {\n      return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n    }\n    return {\n      groupVisibility: () => groupVisibility,\n      isSingleItemVisible(itemId, groupId) {\n        return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n      },\n      addItem(itemId, groupId) {\n        var _;\n        (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n          visibleItemIds: new Set(),\n          invisibleItemIds: new Set()\n        };\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      removeItem(itemId, groupId) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      },\n      showItem(itemId, groupId) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      hideItem(itemId, groupId) {\n        groups[groupId].invisibleItemIds.add(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      }\n    };\n  };\n  const groupManager = createGroupManager();\n  const invisibleItemQueue = createPriorityQueue((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Higher priority at the top of the queue\n    const priority = itemB.priority - itemA.priority;\n    if (priority !== 0) {\n      return priority;\n    }\n    const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n  const visibleItemQueue = createPriorityQueue((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Lower priority at the top of the queue\n    const priority = itemA.priority - itemB.priority;\n    if (priority !== 0) {\n      return priority;\n    }\n    const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n  const getOffsetSize = el => {\n    if (sizeCache.has(el)) {\n      return sizeCache.get(el);\n    }\n    const offsetSize = options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;\n    sizeCache.set(el, offsetSize);\n    return offsetSize;\n  };\n  function computeSizeChange(entry) {\n    const dividerWidth = entry.groupId && groupManager.isSingleItemVisible(entry.id, entry.groupId) && overflowDividers[entry.groupId] ? getOffsetSize(overflowDividers[entry.groupId].element) : 0;\n    return getOffsetSize(entry.element) + dividerWidth;\n  }\n  const showItem = () => {\n    const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n    options.onUpdateItemVisibility({\n      item,\n      visible: true\n    });\n    if (item.groupId) {\n      groupManager.showItem(item.id, item.groupId);\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        var _overflowDividers_item_groupId;\n        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n      }\n    }\n    return computeSizeChange(item);\n  };\n  const hideItem = () => {\n    const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n    const width = computeSizeChange(item);\n    options.onUpdateItemVisibility({\n      item,\n      visible: false\n    });\n    if (item.groupId) {\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        var _overflowDividers_item_groupId;\n        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n      }\n      groupManager.hideItem(item.id, item.groupId);\n    }\n    return width;\n  };\n  const dispatchOverflowUpdate = () => {\n    const visibleItemIds = visibleItemQueue.all();\n    const invisibleItemIds = invisibleItemQueue.all();\n    const visibleItems = visibleItemIds.map(itemId => overflowItems[itemId]);\n    const invisibleItems = invisibleItemIds.map(itemId => overflowItems[itemId]);\n    options.onUpdateOverflow({\n      visibleItems,\n      invisibleItems,\n      groupVisibility: groupManager.groupVisibility()\n    });\n  };\n  const processOverflowItems = () => {\n    if (!container) {\n      return false;\n    }\n    sizeCache.clear();\n    const totalDividersWidth = Object.values(overflowDividers).map(dvdr => dvdr.groupId ? getOffsetSize(dvdr.element) : 0).reduce((prev, current) => prev + current, 0);\n    function overflowMenuSize() {\n      return invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n    }\n    const availableSize = getOffsetSize(container) - totalDividersWidth - options.padding;\n    // Snapshot of the visible/invisible state to compare for updates\n    const visibleTop = visibleItemQueue.peek();\n    const invisibleTop = invisibleItemQueue.peek();\n    let currentSize = visibleItemQueue.all().map(id => overflowItems[id].element).map(getOffsetSize).reduce((prev, current) => prev + current, 0);\n    // Run the show/hide step twice - the first step might not be correct if\n    // it was triggered by a new item being added - new items are always visible by default.\n    for (let i = 0; i < 2; i++) {\n      // Add items until available width is filled - can result in overflow\n      while (currentSize + overflowMenuSize() < availableSize && invisibleItemQueue.size() > 0) {\n        currentSize += showItem();\n      }\n      // Remove items until there's no more overflow\n      while (currentSize + overflowMenuSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {\n        currentSize -= hideItem();\n      }\n    }\n    // only update when the state of visible/invisible items has changed\n    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n  };\n  const forceUpdate = () => {\n    if (processOverflowItems() || forceDispatch) {\n      forceDispatch = false;\n      dispatchOverflowUpdate();\n    }\n  };\n  const update = debounce(forceUpdate);\n  const observe = (observedContainer, userOptions) => {\n    Object.assign(options, userOptions);\n    observing = true;\n    Object.values(overflowItems).forEach(item => visibleItemQueue.enqueue(item.id));\n    container = observedContainer;\n    resizeObserver.observe(container);\n  };\n  const disconnect = () => {\n    observing = false;\n    sizeCache.clear();\n    resizeObserver.disconnect();\n  };\n  const addItem = item => {\n    if (overflowItems[item.id]) {\n      return;\n    }\n    overflowItems[item.id] = item;\n    // some options can affect priority which are only set on `observe`\n    if (observing) {\n      // Updates to elements might not change the queue tops\n      // i.e. new element is enqueued but the top of the queue stays the same\n      // force a dispatch on the next batched update\n      forceDispatch = true;\n      visibleItemQueue.enqueue(item.id);\n    }\n    if (item.groupId) {\n      groupManager.addItem(item.id, item.groupId);\n      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n    }\n    update();\n  };\n  const addOverflowMenu = el => {\n    overflowMenu = el;\n  };\n  const addDivider = divider => {\n    if (!divider.groupId || overflowDividers[divider.groupId]) {\n      return;\n    }\n    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n    overflowDividers[divider.groupId] = divider;\n  };\n  const removeOverflowMenu = () => {\n    overflowMenu = undefined;\n  };\n  const removeDivider = groupId => {\n    if (!overflowDividers[groupId]) {\n      return;\n    }\n    const divider = overflowDividers[groupId];\n    if (divider.groupId) {\n      delete overflowDividers[groupId];\n      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n  };\n  const removeItem = itemId => {\n    if (!overflowItems[itemId]) {\n      return;\n    }\n    const item = overflowItems[itemId];\n    visibleItemQueue.remove(itemId);\n    invisibleItemQueue.remove(itemId);\n    if (item.groupId) {\n      groupManager.removeItem(item.id, item.groupId);\n      item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n    sizeCache.delete(item.element);\n    delete overflowItems[itemId];\n    update();\n  };\n  return {\n    addItem,\n    disconnect,\n    forceUpdate,\n    observe,\n    removeItem,\n    update,\n    addOverflowMenu,\n    removeOverflowMenu,\n    addDivider,\n    removeDivider\n  };\n}","map":{"version":3,"names":["_groups","_groupId","DATA_OVERFLOWING","DATA_OVERFLOW_GROUP","debounce","createPriorityQueue","createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","resizeObserver","ResizeObserver","entries","update","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","groups","updateGroupVisibility","groupId","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","_","Set","add","removeItem","delete","showItem","hideItem","groupManager","invisibleItemQueue","a","b","itemA","itemB","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","visibleItemQueue","getOffsetSize","el","get","offsetSize","offsetWidth","offsetHeight","set","computeSizeChange","entry","dividerWidth","id","item","visible","_overflowDividers_item_groupId","removeAttribute","width","setAttribute","dispatchOverflowUpdate","all","visibleItems","map","invisibleItems","processOverflowItems","clear","totalDividersWidth","Object","values","dvdr","reduce","prev","current","overflowMenuSize","availableSize","visibleTop","peek","invisibleTop","currentSize","i","forceUpdate","observe","observedContainer","userOptions","assign","forEach","disconnect","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/priority-overflow/lib/overflowManager.js"],"sourcesContent":["var _groups, _groupId;\nimport { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */ export function createOverflowManager() {\n    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n    const sizeCache = new Map();\n    let container;\n    let overflowMenu;\n    // Set as true when resize observer is observing\n    let observing = false;\n    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n    // Initially true to force dispatch on first mount\n    let forceDispatch = true;\n    const options = {\n        padding: 10,\n        overflowAxis: 'horizontal',\n        overflowDirection: 'end',\n        minimumVisible: 0,\n        onUpdateItemVisibility: ()=>undefined,\n        onUpdateOverflow: ()=>undefined\n    };\n    const overflowItems = {};\n    const overflowDividers = {};\n    const resizeObserver = new ResizeObserver((entries)=>{\n        if (!entries[0] || !container) {\n            return;\n        }\n        update();\n    });\n    const getNextItem = (queueToDequeue, queueToEnqueue)=>{\n        const nextItem = queueToDequeue.dequeue();\n        queueToEnqueue.enqueue(nextItem);\n        return overflowItems[nextItem];\n    };\n    const createGroupManager = ()=>{\n        const groupVisibility = {};\n        const groups = {};\n        function updateGroupVisibility(groupId) {\n            const group = groups[groupId];\n            if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n                groupVisibility[groupId] = 'overflow';\n            } else if (group.visibleItemIds.size === 0) {\n                groupVisibility[groupId] = 'hidden';\n            } else {\n                groupVisibility[groupId] = 'visible';\n            }\n        }\n        function isGroupVisible(groupId) {\n            return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n        }\n        return {\n            groupVisibility: ()=>groupVisibility,\n            isSingleItemVisible (itemId, groupId) {\n                return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n            },\n            addItem (itemId, groupId) {\n                var _;\n                (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n                    visibleItemIds: new Set(),\n                    invisibleItemIds: new Set()\n                };\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            removeItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            },\n            showItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            hideItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.add(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            }\n        };\n    };\n    const groupManager = createGroupManager();\n    const invisibleItemQueue = createPriorityQueue((a, b)=>{\n        const itemA = overflowItems[a];\n        const itemB = overflowItems[b];\n        // Higher priority at the top of the queue\n        const priority = itemB.priority - itemA.priority;\n        if (priority !== 0) {\n            return priority;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n        // equal priority, use DOM order\n        // eslint-disable-next-line no-bitwise\n        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n    });\n    const visibleItemQueue = createPriorityQueue((a, b)=>{\n        const itemA = overflowItems[a];\n        const itemB = overflowItems[b];\n        // Lower priority at the top of the queue\n        const priority = itemA.priority - itemB.priority;\n        if (priority !== 0) {\n            return priority;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;\n        // equal priority, use DOM order\n        // eslint-disable-next-line no-bitwise\n        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n    });\n    const getOffsetSize = (el)=>{\n        if (sizeCache.has(el)) {\n            return sizeCache.get(el);\n        }\n        const offsetSize = options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;\n        sizeCache.set(el, offsetSize);\n        return offsetSize;\n    };\n    function computeSizeChange(entry) {\n        const dividerWidth = entry.groupId && groupManager.isSingleItemVisible(entry.id, entry.groupId) && overflowDividers[entry.groupId] ? getOffsetSize(overflowDividers[entry.groupId].element) : 0;\n        return getOffsetSize(entry.element) + dividerWidth;\n    }\n    const showItem = ()=>{\n        const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: true\n        });\n        if (item.groupId) {\n            groupManager.showItem(item.id, item.groupId);\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n            }\n        }\n        return computeSizeChange(item);\n    };\n    const hideItem = ()=>{\n        const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n        const width = computeSizeChange(item);\n        options.onUpdateItemVisibility({\n            item,\n            visible: false\n        });\n        if (item.groupId) {\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n            }\n            groupManager.hideItem(item.id, item.groupId);\n        }\n        return width;\n    };\n    const dispatchOverflowUpdate = ()=>{\n        const visibleItemIds = visibleItemQueue.all();\n        const invisibleItemIds = invisibleItemQueue.all();\n        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);\n        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);\n        options.onUpdateOverflow({\n            visibleItems,\n            invisibleItems,\n            groupVisibility: groupManager.groupVisibility()\n        });\n    };\n    const processOverflowItems = ()=>{\n        if (!container) {\n            return false;\n        }\n        sizeCache.clear();\n        const totalDividersWidth = Object.values(overflowDividers).map((dvdr)=>dvdr.groupId ? getOffsetSize(dvdr.element) : 0).reduce((prev, current)=>prev + current, 0);\n        function overflowMenuSize() {\n            return invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n        }\n        const availableSize = getOffsetSize(container) - totalDividersWidth - options.padding;\n        // Snapshot of the visible/invisible state to compare for updates\n        const visibleTop = visibleItemQueue.peek();\n        const invisibleTop = invisibleItemQueue.peek();\n        let currentSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);\n        // Run the show/hide step twice - the first step might not be correct if\n        // it was triggered by a new item being added - new items are always visible by default.\n        for(let i = 0; i < 2; i++){\n            // Add items until available width is filled - can result in overflow\n            while(currentSize + overflowMenuSize() < availableSize && invisibleItemQueue.size() > 0){\n                currentSize += showItem();\n            }\n            // Remove items until there's no more overflow\n            while(currentSize + overflowMenuSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){\n                currentSize -= hideItem();\n            }\n        }\n        // only update when the state of visible/invisible items has changed\n        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n    };\n    const forceUpdate = ()=>{\n        if (processOverflowItems() || forceDispatch) {\n            forceDispatch = false;\n            dispatchOverflowUpdate();\n        }\n    };\n    const update = debounce(forceUpdate);\n    const observe = (observedContainer, userOptions)=>{\n        Object.assign(options, userOptions);\n        observing = true;\n        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));\n        container = observedContainer;\n        resizeObserver.observe(container);\n    };\n    const disconnect = ()=>{\n        observing = false;\n        sizeCache.clear();\n        resizeObserver.disconnect();\n    };\n    const addItem = (item)=>{\n        if (overflowItems[item.id]) {\n            return;\n        }\n        overflowItems[item.id] = item;\n        // some options can affect priority which are only set on `observe`\n        if (observing) {\n            // Updates to elements might not change the queue tops\n            // i.e. new element is enqueued but the top of the queue stays the same\n            // force a dispatch on the next batched update\n            forceDispatch = true;\n            visibleItemQueue.enqueue(item.id);\n        }\n        if (item.groupId) {\n            groupManager.addItem(item.id, item.groupId);\n            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n        }\n        update();\n    };\n    const addOverflowMenu = (el)=>{\n        overflowMenu = el;\n    };\n    const addDivider = (divider)=>{\n        if (!divider.groupId || overflowDividers[divider.groupId]) {\n            return;\n        }\n        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n        overflowDividers[divider.groupId] = divider;\n    };\n    const removeOverflowMenu = ()=>{\n        overflowMenu = undefined;\n    };\n    const removeDivider = (groupId)=>{\n        if (!overflowDividers[groupId]) {\n            return;\n        }\n        const divider = overflowDividers[groupId];\n        if (divider.groupId) {\n            delete overflowDividers[groupId];\n            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n    };\n    const removeItem = (itemId)=>{\n        if (!overflowItems[itemId]) {\n            return;\n        }\n        const item = overflowItems[itemId];\n        visibleItemQueue.remove(itemId);\n        invisibleItemQueue.remove(itemId);\n        if (item.groupId) {\n            groupManager.removeItem(item.id, item.groupId);\n            item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n        sizeCache.delete(item.element);\n        delete overflowItems[itemId];\n        update();\n    };\n    return {\n        addItem,\n        disconnect,\n        forceUpdate,\n        observe,\n        removeItem,\n        update,\n        addOverflowMenu,\n        removeOverflowMenu,\n        addDivider,\n        removeDivider\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}