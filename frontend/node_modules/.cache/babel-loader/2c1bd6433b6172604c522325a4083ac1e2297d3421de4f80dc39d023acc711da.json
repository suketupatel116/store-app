{"ast":null,"code":"function getDirectionalClassName(classes, direction) {\n  return Array.isArray(classes) ? direction === 'rtl' ? classes[1] : classes[0] : classes;\n}\nfunction getDebugClassNames(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {\n  const classesMapping = lookupItem[0];\n  const direction = lookupItem[1];\n  return Object.entries(classesMapping).map(_ref => {\n    let [propertyHash, classes] = _ref;\n    const className = getDirectionalClassName(classes, direction);\n    let overriddenBy;\n    if (parentDebugClassNames && parentLookupItem) {\n      const matching = parentDebugClassNames.find(_ref2 => {\n        let {\n          className: parentClassName\n        } = _ref2;\n        return parentClassName === className;\n      });\n      if (!matching && parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), but has current selector:\n        // style is overriden in current merging by another rule in sibling node\n        overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);\n      } else if (matching && parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), and has current selector:\n        // case 1. style is not overriden during current merging; it may be overriden in higher level of merging\n        // case 2. style is overriden in current merging by exactly the same rule in sibling nodes\n        const siblingHasSameRule = overridingSiblings ? overridingSiblings.filter(_ref3 => {\n          let {\n            debugClassNames\n          } = _ref3;\n          return debugClassNames.filter(_ref4 => {\n            let {\n              className: siblingClassName\n            } = _ref4;\n            return siblingClassName === className;\n          }).length > 0;\n        }).length > 0 : false;\n        overriddenBy = siblingHasSameRule ? matching.className // case 2\n        : matching.overriddenBy; // case 1\n      } else if (!matching && !parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), and does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      } else if (matching && !parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), but does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      }\n    }\n    return {\n      className,\n      overriddenBy\n    };\n  });\n}\nexport { getDebugClassNames };","map":{"version":3,"names":["getDirectionalClassName","classes","direction","Array","isArray","getDebugClassNames","lookupItem","parentLookupItem","parentDebugClassNames","overridingSiblings","classesMapping","Object","entries","map","_ref","propertyHash","className","overriddenBy","matching","find","_ref2","parentClassName","siblingHasSameRule","filter","_ref3","debugClassNames","_ref4","siblingClassName","length","undefined"],"sources":["/Users/suketupatel/Desktop/application/frontend/packages/core/src/devtools/utils.ts"],"sourcesContent":["import { CSSClasses, LookupItem } from '../types';\nimport { DebugAtomicClassName, DebugSequence } from './types';\n\nfunction getDirectionalClassName(classes: CSSClasses, direction: 'ltr' | 'rtl'): string {\n  return Array.isArray(classes) ? (direction === 'rtl' ? classes[1] : classes[0]) : classes;\n}\n\nexport function getDebugClassNames(\n  lookupItem: LookupItem,\n  parentLookupItem?: LookupItem,\n  parentDebugClassNames?: DebugAtomicClassName[],\n  overridingSiblings?: DebugSequence[],\n): DebugAtomicClassName[] {\n  const classesMapping = lookupItem[0];\n  const direction = lookupItem[1];\n\n  return Object.entries(classesMapping).map(([propertyHash, classes]) => {\n    const className = getDirectionalClassName(classes, direction);\n\n    let overriddenBy: string | undefined;\n    if (parentDebugClassNames && parentLookupItem) {\n      const matching = parentDebugClassNames.find(({ className: parentClassName }) => parentClassName === className);\n\n      if (!matching && parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), but has current selector:\n        // style is overriden in current merging by another rule in sibling node\n        overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);\n      } else if (matching && parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), and has current selector:\n        // case 1. style is not overriden during current merging; it may be overriden in higher level of merging\n        // case 2. style is overriden in current merging by exactly the same rule in sibling nodes\n        const siblingHasSameRule = overridingSiblings\n          ? overridingSiblings.filter(\n              ({ debugClassNames }) =>\n                debugClassNames.filter(({ className: siblingClassName }) => siblingClassName === className).length > 0,\n            ).length > 0\n          : false;\n        overriddenBy = siblingHasSameRule\n          ? matching.className // case 2\n          : matching.overriddenBy; // case 1\n      } else if (!matching && !parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), and does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      } else if (matching && !parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), but does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      }\n    }\n\n    return {\n      className,\n      overriddenBy,\n    };\n  });\n}\n"],"mappings":"AAGA,SAASA,uBAAuBA,CAACC,OAAmB,EAAEC,SAAwB;EAC5E,OAAOC,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,GAAIC,SAAS,KAAK,KAAK,GAAGD,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAIA,OAAO;AAC3F;SAEgBI,kBAAkBA,CAChCC,UAAsB,EACtBC,gBAA6B,EAC7BC,qBAA8C,EAC9CC,kBAAoC;EAEpC,MAAMC,cAAc,GAAGJ,UAAU,CAAC,CAAC,CAAC;EACpC,MAAMJ,SAAS,GAAGI,UAAU,CAAC,CAAC,CAAC;EAE/B,OAAOK,MAAM,CAACC,OAAO,CAACF,cAAc,CAAC,CAACG,GAAG,CAACC,IAAA,IAAwB;IAAA,IAAvB,CAACC,YAAY,EAAEd,OAAO,CAAC,GAAAa,IAAA;IAChE,MAAME,SAAS,GAAGhB,uBAAuB,CAACC,OAAO,EAAEC,SAAS,CAAC;IAE7D,IAAIe,YAAgC;IACpC,IAAIT,qBAAqB,IAAID,gBAAgB,EAAE;MAC7C,MAAMW,QAAQ,GAAGV,qBAAqB,CAACW,IAAI,CAACC,KAAA;QAAA,IAAC;UAAEJ,SAAS,EAAEK;SAAiB,GAAAD,KAAA;QAAA,OAAKC,eAAe,KAAKL,SAAS;MAAA,EAAC;MAE9G,IAAI,CAACE,QAAQ,IAAIX,gBAAgB,CAAC,CAAC,CAAC,CAACQ,YAAY,CAAC,EAAE;;;QAGlDE,YAAY,GAAGjB,uBAAuB,CAACO,gBAAgB,CAAC,CAAC,CAAC,CAACQ,YAAY,CAAC,EAAER,gBAAgB,CAAC,CAAC,CAAC,CAAC;OAC/F,MAAM,IAAIW,QAAQ,IAAIX,gBAAgB,CAAC,CAAC,CAAC,CAACQ,YAAY,CAAC,EAAE;;;;QAIxD,MAAMO,kBAAkB,GAAGb,kBAAkB,GACzCA,kBAAkB,CAACc,MAAM,CACvBC,KAAA;UAAA,IAAC;YAAEC;WAAiB,GAAAD,KAAA;UAAA,OAClBC,eAAe,CAACF,MAAM,CAACG,KAAA;YAAA,IAAC;cAAEV,SAAS,EAAEW;aAAkB,GAAAD,KAAA;YAAA,OAAKC,gBAAgB,KAAKX,SAAS;UAAA,EAAC,CAACY,MAAM,GAAG,CAAC;QAAA,EACzG,CAACA,MAAM,GAAG,CAAC,GACZ,KAAK;QACTX,YAAY,GAAGK,kBAAkB,GAC7BJ,QAAQ,CAACF,SAAS;QAAA,EAClBE,QAAQ,CAACD,YAAY,CAAC;OAC3B,MAAM,IAAI,CAACC,QAAQ,IAAI,CAACX,gBAAgB,CAAC,CAAC,CAAC,CAACQ,YAAY,CAAC,EAAE;;;QAG1DE,YAAY,GAAGY,SAAS;OACzB,MAAM,IAAIX,QAAQ,IAAI,CAACX,gBAAgB,CAAC,CAAC,CAAC,CAACQ,YAAY,CAAC,EAAE;;;QAGzDE,YAAY,GAAGY,SAAS;;;IAI5B,OAAO;MACLb,SAAS;MACTC;KACD;GACF,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}