{"ast":null,"code":"import * as React from 'react';\nimport { useControllableState, useFirstMount } from '@fluentui/react-utilities';\nimport { useOptionCollection } from '../utils/useOptionCollection';\nimport { useSelection } from '../utils/useSelection';\n/**\n * State shared between Combobox and Dropdown components\n */\nexport const useComboboxBaseState = props => {\n  const {\n    appearance = 'outline',\n    children,\n    editable = false,\n    inlinePopup = false,\n    multiselect,\n    onOpenChange,\n    size = 'medium'\n  } = props;\n  const optionCollection = useOptionCollection();\n  const {\n    getOptionAtIndex,\n    getOptionsMatchingValue\n  } = optionCollection;\n  const [activeOption, setActiveOption] = React.useState();\n  // track whether keyboard focus outline should be shown\n  // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move\n  const [focusVisible, setFocusVisible] = React.useState(false);\n  // track focused state to conditionally render collapsed listbox\n  const [hasFocus, setHasFocus] = React.useState(false);\n  const ignoreNextBlur = React.useRef(false);\n  const selectionState = useSelection(props);\n  const {\n    selectedOptions\n  } = selectionState;\n  // calculate value based on props, internal value changes, and selected options\n  const isFirstMount = useFirstMount();\n  const [controllableValue, setValue] = useControllableState({\n    state: props.value,\n    initialState: undefined\n  });\n  const value = React.useMemo(() => {\n    // don't compute the value if it is defined through props or setValue,\n    if (controllableValue !== undefined) {\n      return controllableValue;\n    }\n    // handle defaultValue here, so it is overridden by selection\n    if (isFirstMount && props.defaultValue !== undefined) {\n      return props.defaultValue;\n    }\n    const selectedOptionsText = getOptionsMatchingValue(optionValue => {\n      return selectedOptions.includes(optionValue);\n    }).map(option => option.text);\n    if (multiselect) {\n      // editable inputs should not display multiple selected options in the input as text\n      return editable ? '' : selectedOptionsText.join(', ');\n    }\n    return selectedOptionsText[0];\n    // do not change value after isFirstMount changes,\n    // we do not want to accidentally override defaultValue on a second render\n    // unless another value is intentionally set\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [controllableValue, editable, getOptionsMatchingValue, multiselect, props.defaultValue, selectedOptions]);\n  // Handle open state, which is shared with options in context\n  const [open, setOpenState] = useControllableState({\n    state: props.open,\n    defaultState: props.defaultOpen,\n    initialState: false\n  });\n  const setOpen = React.useCallback((event, newState) => {\n    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {\n      open: newState\n    });\n    setOpenState(newState);\n  }, [onOpenChange, setOpenState]);\n  // update active option based on change in open state or children\n  React.useEffect(() => {\n    if (open && !activeOption) {\n      // if it is single-select and there is a selected option, start at the selected option\n      if (!multiselect && selectedOptions.length > 0) {\n        const selectedOption = getOptionsMatchingValue(v => v === selectedOptions[0]).pop();\n        selectedOption && setActiveOption(selectedOption);\n      } else {\n        setActiveOption(getOptionAtIndex(0));\n      }\n    } else if (!open) {\n      // reset the active option when closing\n      setActiveOption(undefined);\n    }\n    // this should only be run in response to changes in the open state or children\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [open, children]);\n  return {\n    ...optionCollection,\n    ...selectionState,\n    activeOption,\n    appearance,\n    focusVisible,\n    hasFocus,\n    ignoreNextBlur,\n    inlinePopup,\n    open,\n    setActiveOption,\n    setFocusVisible,\n    setHasFocus,\n    setOpen,\n    setValue,\n    size,\n    value\n  };\n};","map":{"version":3,"names":["React","useControllableState","useFirstMount","useOptionCollection","useSelection","useComboboxBaseState","props","appearance","children","editable","inlinePopup","multiselect","onOpenChange","size","optionCollection","getOptionAtIndex","getOptionsMatchingValue","activeOption","setActiveOption","useState","focusVisible","setFocusVisible","hasFocus","setHasFocus","ignoreNextBlur","useRef","selectionState","selectedOptions","isFirstMount","controllableValue","setValue","state","value","initialState","undefined","useMemo","defaultValue","selectedOptionsText","optionValue","includes","map","option","text","join","open","setOpenState","defaultState","defaultOpen","setOpen","useCallback","event","newState","useEffect","length","selectedOption","v","pop"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-combobox/lib/utils/useComboboxBaseState.js"],"sourcesContent":["import * as React from 'react';\nimport { useControllableState, useFirstMount } from '@fluentui/react-utilities';\nimport { useOptionCollection } from '../utils/useOptionCollection';\nimport { useSelection } from '../utils/useSelection';\n/**\n * State shared between Combobox and Dropdown components\n */ export const useComboboxBaseState = (props)=>{\n    const { appearance ='outline' , children , editable =false , inlinePopup =false , multiselect , onOpenChange , size ='medium'  } = props;\n    const optionCollection = useOptionCollection();\n    const { getOptionAtIndex , getOptionsMatchingValue  } = optionCollection;\n    const [activeOption, setActiveOption] = React.useState();\n    // track whether keyboard focus outline should be shown\n    // tabster/keyborg doesn't work here, since the actual keyboard focus target doesn't move\n    const [focusVisible, setFocusVisible] = React.useState(false);\n    // track focused state to conditionally render collapsed listbox\n    const [hasFocus, setHasFocus] = React.useState(false);\n    const ignoreNextBlur = React.useRef(false);\n    const selectionState = useSelection(props);\n    const { selectedOptions  } = selectionState;\n    // calculate value based on props, internal value changes, and selected options\n    const isFirstMount = useFirstMount();\n    const [controllableValue, setValue] = useControllableState({\n        state: props.value,\n        initialState: undefined\n    });\n    const value = React.useMemo(()=>{\n        // don't compute the value if it is defined through props or setValue,\n        if (controllableValue !== undefined) {\n            return controllableValue;\n        }\n        // handle defaultValue here, so it is overridden by selection\n        if (isFirstMount && props.defaultValue !== undefined) {\n            return props.defaultValue;\n        }\n        const selectedOptionsText = getOptionsMatchingValue((optionValue)=>{\n            return selectedOptions.includes(optionValue);\n        }).map((option)=>option.text);\n        if (multiselect) {\n            // editable inputs should not display multiple selected options in the input as text\n            return editable ? '' : selectedOptionsText.join(', ');\n        }\n        return selectedOptionsText[0];\n    // do not change value after isFirstMount changes,\n    // we do not want to accidentally override defaultValue on a second render\n    // unless another value is intentionally set\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        controllableValue,\n        editable,\n        getOptionsMatchingValue,\n        multiselect,\n        props.defaultValue,\n        selectedOptions\n    ]);\n    // Handle open state, which is shared with options in context\n    const [open, setOpenState] = useControllableState({\n        state: props.open,\n        defaultState: props.defaultOpen,\n        initialState: false\n    });\n    const setOpen = React.useCallback((event, newState)=>{\n        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {\n            open: newState\n        });\n        setOpenState(newState);\n    }, [\n        onOpenChange,\n        setOpenState\n    ]);\n    // update active option based on change in open state or children\n    React.useEffect(()=>{\n        if (open && !activeOption) {\n            // if it is single-select and there is a selected option, start at the selected option\n            if (!multiselect && selectedOptions.length > 0) {\n                const selectedOption = getOptionsMatchingValue((v)=>v === selectedOptions[0]).pop();\n                selectedOption && setActiveOption(selectedOption);\n            } else {\n                setActiveOption(getOptionAtIndex(0));\n            }\n        } else if (!open) {\n            // reset the active option when closing\n            setActiveOption(undefined);\n        }\n    // this should only be run in response to changes in the open state or children\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        open,\n        children\n    ]);\n    return {\n        ...optionCollection,\n        ...selectionState,\n        activeOption,\n        appearance,\n        focusVisible,\n        hasFocus,\n        ignoreNextBlur,\n        inlinePopup,\n        open,\n        setActiveOption,\n        setFocusVisible,\n        setHasFocus,\n        setOpen,\n        setValue,\n        size,\n        value\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}