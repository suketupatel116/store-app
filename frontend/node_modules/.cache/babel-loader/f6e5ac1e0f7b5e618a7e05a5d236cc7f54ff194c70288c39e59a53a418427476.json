{"ast":null,"code":"import * as React from 'react';\nimport { useMergedRefs, useEventCallback, useControllableState, getNativeElementProps } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useHasParentContext } from '@fluentui/react-context-selector';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MenuContext } from '../../contexts/menuContext';\n/**\n * Returns the props and state required to render the component\n */\nexport const useMenuList_unstable = (props, ref) => {\n  const {\n    findAllFocusable\n  } = useFocusFinders();\n  const menuContext = useMenuContextSelectors();\n  const hasMenuContext = useHasParentContext(MenuContext);\n  const focusAttributes = useArrowNavigationGroup({\n    circular: true,\n    ignoreDefaultKeydown: {\n      Tab: hasMenuContext\n    }\n  });\n  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {\n    // TODO throw warnings in development safely\n    // eslint-disable-next-line no-console\n    console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');\n  }\n  const innerRef = React.useRef(null);\n  const setFocusByFirstCharacter = React.useCallback((e, itemEl) => {\n    // TODO use some kind of children registration to reduce dependency on DOM roles\n    const acceptedRoles = ['menuitem', 'menuitemcheckbox', 'menuitemradio'];\n    if (!innerRef.current) {\n      return;\n    }\n    const menuItems = findAllFocusable(innerRef.current, el => el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1);\n    let startIndex = menuItems.indexOf(itemEl) + 1;\n    if (startIndex === menuItems.length) {\n      startIndex = 0;\n    }\n    const firstChars = menuItems.map(menuItem => {\n      var _menuItem_textContent;\n      return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();\n    });\n    const char = e.key.toLowerCase();\n    const getIndexFirstChars = (start, firstChar) => {\n      for (let i = start; i < firstChars.length; i++) {\n        if (char === firstChars[i]) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    // Check remaining slots in the menu\n    let index = getIndexFirstChars(startIndex, char);\n    // If not found in remaining slots, check from beginning\n    if (index === -1) {\n      index = getIndexFirstChars(0, char);\n    }\n    // If match was found...\n    if (index > -1) {\n      menuItems[index].focus();\n    }\n  }, [findAllFocusable]);\n  var _props_checkedValues;\n  const [checkedValues, setCheckedValues] = useControllableState({\n    state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : undefined,\n    defaultState: props.defaultCheckedValues,\n    initialState: {}\n  });\n  var _props_onCheckedValueChange;\n  const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : undefined;\n  const toggleCheckbox = useEventCallback((e, name, value, checked) => {\n    const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];\n    const newCheckedItems = [...checkedItems];\n    if (checked) {\n      newCheckedItems.splice(newCheckedItems.indexOf(value), 1);\n    } else {\n      newCheckedItems.push(value);\n    }\n    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n      name,\n      checkedItems: newCheckedItems\n    });\n    setCheckedValues(s => ({\n      ...s,\n      [name]: newCheckedItems\n    }));\n  });\n  const selectRadio = useEventCallback((e, name, value) => {\n    const newCheckedItems = [value];\n    setCheckedValues(s => ({\n      ...s,\n      [name]: newCheckedItems\n    }));\n    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n      name,\n      checkedItems: newCheckedItems\n    });\n  });\n  return {\n    components: {\n      root: 'div'\n    },\n    root: getNativeElementProps('div', {\n      ref: useMergedRefs(ref, innerRef),\n      role: 'menu',\n      'aria-labelledby': menuContext.triggerId,\n      ...focusAttributes,\n      ...props\n    }),\n    hasIcons: menuContext.hasIcons || false,\n    hasCheckmarks: menuContext.hasCheckmarks || false,\n    checkedValues,\n    hasMenuContext,\n    setFocusByFirstCharacter,\n    selectRadio,\n    toggleCheckbox\n  };\n};\n/**\n * Adds some sugar to fetching multiple context selector values\n */\nconst useMenuContextSelectors = () => {\n  const checkedValues = useMenuContext_unstable(context => context.checkedValues);\n  const onCheckedValueChange = useMenuContext_unstable(context => context.onCheckedValueChange);\n  const triggerId = useMenuContext_unstable(context => context.triggerId);\n  const hasIcons = useMenuContext_unstable(context => context.hasIcons);\n  const hasCheckmarks = useMenuContext_unstable(context => context.hasCheckmarks);\n  return {\n    checkedValues,\n    onCheckedValueChange,\n    triggerId,\n    hasIcons,\n    hasCheckmarks\n  };\n};\n/**\n * Helper function to detect if props and MenuContext values are both used\n */\nconst usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {\n  let isUsingPropsAndContext = false;\n  for (const val in contextValue) {\n    if (props[val]) {\n      isUsingPropsAndContext = true;\n    }\n  }\n  return hasMenuContext && isUsingPropsAndContext;\n};","map":{"version":3,"names":["React","useMergedRefs","useEventCallback","useControllableState","getNativeElementProps","useArrowNavigationGroup","useFocusFinders","useHasParentContext","useMenuContext_unstable","MenuContext","useMenuList_unstable","props","ref","findAllFocusable","menuContext","useMenuContextSelectors","hasMenuContext","focusAttributes","circular","ignoreDefaultKeydown","Tab","usingPropsAndMenuContext","console","warn","innerRef","useRef","setFocusByFirstCharacter","useCallback","e","itemEl","acceptedRoles","current","menuItems","el","hasAttribute","indexOf","getAttribute","startIndex","length","firstChars","map","menuItem","_menuItem_textContent","textContent","charAt","toLowerCase","char","key","getIndexFirstChars","start","firstChar","i","index","focus","_props_checkedValues","checkedValues","setCheckedValues","state","undefined","defaultState","defaultCheckedValues","initialState","_props_onCheckedValueChange","handleCheckedValueChange","onCheckedValueChange","toggleCheckbox","name","value","checked","checkedItems","newCheckedItems","splice","push","s","selectRadio","components","root","role","triggerId","hasIcons","hasCheckmarks","context","contextValue","isUsingPropsAndContext","val"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuList.js"],"sourcesContent":["import * as React from 'react';\nimport { useMergedRefs, useEventCallback, useControllableState, getNativeElementProps } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useHasParentContext } from '@fluentui/react-context-selector';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MenuContext } from '../../contexts/menuContext';\n/**\n * Returns the props and state required to render the component\n */ export const useMenuList_unstable = (props, ref)=>{\n    const { findAllFocusable  } = useFocusFinders();\n    const menuContext = useMenuContextSelectors();\n    const hasMenuContext = useHasParentContext(MenuContext);\n    const focusAttributes = useArrowNavigationGroup({\n        circular: true,\n        ignoreDefaultKeydown: {\n            Tab: hasMenuContext\n        }\n    });\n    if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {\n        // TODO throw warnings in development safely\n        // eslint-disable-next-line no-console\n        console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');\n    }\n    const innerRef = React.useRef(null);\n    const setFocusByFirstCharacter = React.useCallback((e, itemEl)=>{\n        // TODO use some kind of children registration to reduce dependency on DOM roles\n        const acceptedRoles = [\n            'menuitem',\n            'menuitemcheckbox',\n            'menuitemradio'\n        ];\n        if (!innerRef.current) {\n            return;\n        }\n        const menuItems = findAllFocusable(innerRef.current, (el)=>el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1);\n        let startIndex = menuItems.indexOf(itemEl) + 1;\n        if (startIndex === menuItems.length) {\n            startIndex = 0;\n        }\n        const firstChars = menuItems.map((menuItem)=>{\n            var _menuItem_textContent;\n            return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();\n        });\n        const char = e.key.toLowerCase();\n        const getIndexFirstChars = (start, firstChar)=>{\n            for(let i = start; i < firstChars.length; i++){\n                if (char === firstChars[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        // Check remaining slots in the menu\n        let index = getIndexFirstChars(startIndex, char);\n        // If not found in remaining slots, check from beginning\n        if (index === -1) {\n            index = getIndexFirstChars(0, char);\n        }\n        // If match was found...\n        if (index > -1) {\n            menuItems[index].focus();\n        }\n    }, [\n        findAllFocusable\n    ]);\n    var _props_checkedValues;\n    const [checkedValues, setCheckedValues] = useControllableState({\n        state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : undefined,\n        defaultState: props.defaultCheckedValues,\n        initialState: {}\n    });\n    var _props_onCheckedValueChange;\n    const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : undefined;\n    const toggleCheckbox = useEventCallback((e, name, value, checked)=>{\n        const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];\n        const newCheckedItems = [\n            ...checkedItems\n        ];\n        if (checked) {\n            newCheckedItems.splice(newCheckedItems.indexOf(value), 1);\n        } else {\n            newCheckedItems.push(value);\n        }\n        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n            name,\n            checkedItems: newCheckedItems\n        });\n        setCheckedValues((s)=>({\n                ...s,\n                [name]: newCheckedItems\n            }));\n    });\n    const selectRadio = useEventCallback((e, name, value)=>{\n        const newCheckedItems = [\n            value\n        ];\n        setCheckedValues((s)=>({\n                ...s,\n                [name]: newCheckedItems\n            }));\n        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n            name,\n            checkedItems: newCheckedItems\n        });\n    });\n    return {\n        components: {\n            root: 'div'\n        },\n        root: getNativeElementProps('div', {\n            ref: useMergedRefs(ref, innerRef),\n            role: 'menu',\n            'aria-labelledby': menuContext.triggerId,\n            ...focusAttributes,\n            ...props\n        }),\n        hasIcons: menuContext.hasIcons || false,\n        hasCheckmarks: menuContext.hasCheckmarks || false,\n        checkedValues,\n        hasMenuContext,\n        setFocusByFirstCharacter,\n        selectRadio,\n        toggleCheckbox\n    };\n};\n/**\n * Adds some sugar to fetching multiple context selector values\n */ const useMenuContextSelectors = ()=>{\n    const checkedValues = useMenuContext_unstable((context)=>context.checkedValues);\n    const onCheckedValueChange = useMenuContext_unstable((context)=>context.onCheckedValueChange);\n    const triggerId = useMenuContext_unstable((context)=>context.triggerId);\n    const hasIcons = useMenuContext_unstable((context)=>context.hasIcons);\n    const hasCheckmarks = useMenuContext_unstable((context)=>context.hasCheckmarks);\n    return {\n        checkedValues,\n        onCheckedValueChange,\n        triggerId,\n        hasIcons,\n        hasCheckmarks\n    };\n};\n/**\n * Helper function to detect if props and MenuContext values are both used\n */ const usingPropsAndMenuContext = (props, contextValue, hasMenuContext)=>{\n    let isUsingPropsAndContext = false;\n    for(const val in contextValue){\n        if (props[val]) {\n            isUsingPropsAndContext = true;\n        }\n    }\n    return hasMenuContext && isUsingPropsAndContext;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}