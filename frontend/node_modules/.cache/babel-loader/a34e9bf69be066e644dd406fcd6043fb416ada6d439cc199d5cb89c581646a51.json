{"ast":null,"code":"import { DATA_BUCKET_ATTR } from '../constants.esm.js';\nimport { createIsomorphicStyleSheet } from './createIsomorphicStyleSheet.esm.js';\n\n/**\r\n * Ordered style buckets using their short pseudo name.\r\n *\r\n * @internal\r\n */\nconst styleBucketOrdering = [\n// reset styles\n'r',\n// catch-all\n'd',\n// link\n'l',\n// visited\n'v',\n// focus-within\n'w',\n// focus\n'f',\n// focus-visible\n'i',\n// hover\n'h',\n// active\n'a',\n// at rules for reset styles\n's',\n// keyframes\n'k',\n// at-rules\n't',\n// @media rules\n'm',\n// @container rules\n'c'];\n// avoid repeatedly calling `indexOf`to determine order during new insertions\nconst styleBucketOrderingMap = /*#__PURE__*/styleBucketOrdering.reduce((acc, cur, j) => {\n  acc[cur] = j;\n  return acc;\n}, {});\n/**\r\n * Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.\r\n */\nfunction getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer) {\n  let metadata = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const isMediaBucket = bucketName === 'm';\n  const stylesheetKey = isMediaBucket ? bucketName + metadata['m'] : bucketName;\n  if (!renderer.stylesheets[stylesheetKey]) {\n    const tag = targetDocument && targetDocument.createElement('style');\n    const stylesheet = createIsomorphicStyleSheet(tag, bucketName, {\n      ...renderer.styleElementAttributes,\n      ...(isMediaBucket && {\n        media: metadata['m']\n      })\n    });\n    renderer.stylesheets[stylesheetKey] = stylesheet;\n    if (targetDocument && tag) {\n      targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));\n    }\n  }\n  return renderer.stylesheets[stylesheetKey];\n}\n/**\r\n * Finds an element before which the new bucket style element should be inserted following the bucket sort order.\r\n *\r\n * @param targetDocument - A document\r\n * @param insertionPoint - An element that will be used as an initial insertion point\r\n * @param targetBucket - The bucket that should be inserted to DOM\r\n * @param renderer - Griffel renderer\r\n * @param metadata - metadata for CSS rule\r\n * @returns - Smallest style element with greater sort order than the current bucket\r\n */\nfunction findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata) {\n  const targetOrder = styleBucketOrderingMap[targetBucket];\n  // Similar to javascript sort comparators where\n  // a positive value is increasing sort order\n  // a negative value is decreasing sort order\n  let comparer = el => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];\n  let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);\n  if (targetBucket === 'm' && metadata) {\n    const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}=\"${targetBucket}\"]`);\n    // only reduce the scope of the search and change comparer\n    // if there are other media buckets already on the page\n    if (mediaElements.length) {\n      styleElements = mediaElements;\n      comparer = el => renderer.compareMediaQueries(metadata['m'], el.media);\n    }\n  }\n  const length = styleElements.length;\n  let index = length - 1;\n  while (index >= 0) {\n    const styleElement = styleElements.item(index);\n    if (comparer(styleElement) > 0) {\n      return styleElement.nextSibling;\n    }\n    index--;\n  }\n  if (length > 0) {\n    return styleElements.item(0);\n  }\n  return insertionPoint ? insertionPoint.nextSibling : null;\n}\nexport { getStyleSheetForBucket, styleBucketOrdering };","map":{"version":3,"names":["styleBucketOrdering","styleBucketOrderingMap","reduce","acc","cur","j","getStyleSheetForBucket","bucketName","targetDocument","insertionPoint","renderer","metadata","arguments","length","undefined","isMediaBucket","stylesheetKey","stylesheets","tag","createElement","stylesheet","createIsomorphicStyleSheet","styleElementAttributes","media","head","insertBefore","findInsertionPoint","targetBucket","targetOrder","comparer","el","getAttribute","DATA_BUCKET_ATTR","styleElements","querySelectorAll","mediaElements","compareMediaQueries","index","styleElement","item","nextSibling"],"sources":["/Users/suketupatel/Desktop/application/frontend/packages/core/src/renderer/getStyleSheetForBucket.ts"],"sourcesContent":["import { DATA_BUCKET_ATTR } from '../constants';\nimport { GriffelRenderer, IsomorphicStyleSheet, StyleBucketName } from '../types';\nimport { createIsomorphicStyleSheet } from './createIsomorphicStyleSheet';\n\n/**\n * Ordered style buckets using their short pseudo name.\n *\n * @internal\n */\nexport const styleBucketOrdering: StyleBucketName[] = [\n  // reset styles\n  'r',\n  // catch-all\n  'd',\n  // link\n  'l',\n  // visited\n  'v',\n  // focus-within\n  'w',\n  // focus\n  'f',\n  // focus-visible\n  'i',\n  // hover\n  'h',\n  // active\n  'a',\n  // at rules for reset styles\n  's',\n  // keyframes\n  'k',\n  // at-rules\n  't',\n  // @media rules\n  'm',\n  // @container rules\n  'c',\n];\n\n// avoid repeatedly calling `indexOf`to determine order during new insertions\nconst styleBucketOrderingMap = styleBucketOrdering.reduce((acc, cur, j) => {\n  acc[cur as StyleBucketName] = j;\n  return acc;\n}, {} as Record<StyleBucketName, number>);\n\n/**\n * Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.\n */\nexport function getStyleSheetForBucket(\n  bucketName: StyleBucketName,\n  targetDocument: Document | undefined,\n  insertionPoint: HTMLElement | null,\n  renderer: GriffelRenderer,\n  metadata: Record<string, unknown> = {},\n): IsomorphicStyleSheet {\n  const isMediaBucket = bucketName === 'm';\n  const stylesheetKey: StyleBucketName | string = isMediaBucket ? ((bucketName + metadata['m']) as string) : bucketName;\n\n  if (!renderer.stylesheets[stylesheetKey]) {\n    const tag: HTMLStyleElement | undefined = targetDocument && targetDocument.createElement('style');\n    const stylesheet = createIsomorphicStyleSheet(tag, bucketName, {\n      ...renderer.styleElementAttributes,\n      ...(isMediaBucket && { media: metadata['m'] as string }),\n    });\n\n    renderer.stylesheets[stylesheetKey] = stylesheet;\n\n    if (targetDocument && tag) {\n      targetDocument.head.insertBefore(\n        tag,\n        findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata),\n      );\n    }\n  }\n\n  return renderer.stylesheets[stylesheetKey]!;\n}\n\n/**\n * Finds an element before which the new bucket style element should be inserted following the bucket sort order.\n *\n * @param targetDocument - A document\n * @param insertionPoint - An element that will be used as an initial insertion point\n * @param targetBucket - The bucket that should be inserted to DOM\n * @param renderer - Griffel renderer\n * @param metadata - metadata for CSS rule\n * @returns - Smallest style element with greater sort order than the current bucket\n */\nfunction findInsertionPoint(\n  targetDocument: Document,\n  insertionPoint: HTMLElement | null,\n  targetBucket: StyleBucketName,\n  renderer: GriffelRenderer,\n  metadata?: Record<string, unknown>,\n): Node | null {\n  const targetOrder = styleBucketOrderingMap[targetBucket];\n\n  // Similar to javascript sort comparators where\n  // a positive value is increasing sort order\n  // a negative value is decreasing sort order\n  let comparer: (el: HTMLStyleElement) => number = el =>\n    targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR) as StyleBucketName];\n\n  let styleElements = targetDocument.head.querySelectorAll<HTMLStyleElement>(`[${DATA_BUCKET_ATTR}]`);\n\n  if (targetBucket === 'm' && metadata) {\n    const mediaElements = targetDocument.head.querySelectorAll<HTMLStyleElement>(\n      `[${DATA_BUCKET_ATTR}=\"${targetBucket}\"]`,\n    );\n\n    // only reduce the scope of the search and change comparer\n    // if there are other media buckets already on the page\n    if (mediaElements.length) {\n      styleElements = mediaElements;\n      comparer = (el: HTMLStyleElement) => renderer.compareMediaQueries(metadata['m'] as string, el.media);\n    }\n  }\n\n  const length = styleElements.length;\n  let index = length - 1;\n\n  while (index >= 0) {\n    const styleElement = styleElements.item(index);\n\n    if (comparer(styleElement) > 0) {\n      return styleElement.nextSibling;\n    }\n\n    index--;\n  }\n\n  if (length > 0) {\n    return styleElements.item(0);\n  }\n\n  return insertionPoint ? insertionPoint.nextSibling : null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}