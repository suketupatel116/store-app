{"ast":null,"code":"import { computePosition } from '@floating-ui/dom';\nimport { debounce, writeArrowUpdates, writeContainerUpdates, getScrollParent } from './utils';\nimport { isHTMLElement } from '@fluentui/react-utilities';\n/**\n * @internal\n * @returns manager that handles positioning out of the react lifecycle\n */\nexport function createPositionManager(options) {\n  const {\n    container,\n    target,\n    arrow,\n    strategy,\n    middleware,\n    placement,\n    useTransform = true\n  } = options;\n  let isDestroyed = false;\n  if (!target || !container) {\n    return {\n      updatePosition: () => undefined,\n      dispose: () => undefined\n    };\n  }\n  let isFirstUpdate = true;\n  const scrollParents = new Set();\n  const targetWindow = container.ownerDocument.defaultView;\n  // When the container is first resolved, set position `fixed` to avoid scroll jumps.\n  // Without this scroll jumps can occur when the element is rendered initially and receives focus\n  Object.assign(container.style, {\n    position: 'fixed',\n    left: 0,\n    top: 0,\n    margin: 0\n  });\n  const forceUpdate = () => {\n    // debounced update can still occur afterwards\n    // early return to avoid memory leaks\n    if (isDestroyed) {\n      return;\n    }\n    if (isFirstUpdate) {\n      scrollParents.add(getScrollParent(container));\n      if (isHTMLElement(target)) {\n        scrollParents.add(getScrollParent(target));\n      }\n      scrollParents.forEach(scrollParent => {\n        scrollParent.addEventListener('scroll', updatePosition);\n      });\n      isFirstUpdate = false;\n    }\n    Object.assign(container.style, {\n      position: strategy\n    });\n    computePosition(target, container, {\n      placement,\n      middleware,\n      strategy\n    }).then(_ref => {\n      let {\n        x,\n        y,\n        middlewareData,\n        placement: computedPlacement\n      } = _ref;\n      // Promise can still resolve after destruction\n      // early return to avoid applying outdated position\n      if (isDestroyed) {\n        return;\n      }\n      writeArrowUpdates({\n        arrow,\n        middlewareData\n      });\n      writeContainerUpdates({\n        container,\n        middlewareData,\n        placement: computedPlacement,\n        coordinates: {\n          x,\n          y\n        },\n        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,\n        strategy,\n        useTransform\n      });\n    }).catch(err => {\n      // https://github.com/floating-ui/floating-ui/issues/1845\n      // FIXME for node > 14\n      // node 15 introduces promise rejection which means that any components\n      // tests need to be `it('', async () => {})` otherwise there can be race conditions with\n      // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist\n      // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing\n      // will actually be counter productive\n      if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.error('[usePositioning]: Failed to calculate position', err);\n      }\n    });\n  };\n  const updatePosition = debounce(() => forceUpdate());\n  const dispose = () => {\n    isDestroyed = true;\n    if (targetWindow) {\n      targetWindow.removeEventListener('scroll', updatePosition);\n      targetWindow.removeEventListener('resize', updatePosition);\n    }\n    scrollParents.forEach(scrollParent => {\n      scrollParent.removeEventListener('scroll', updatePosition);\n    });\n  };\n  if (targetWindow) {\n    targetWindow.addEventListener('scroll', updatePosition);\n    targetWindow.addEventListener('resize', updatePosition);\n  }\n  // Update the position on initialization\n  updatePosition();\n  return {\n    updatePosition,\n    dispose\n  };\n}","map":{"version":3,"names":["computePosition","debounce","writeArrowUpdates","writeContainerUpdates","getScrollParent","isHTMLElement","createPositionManager","options","container","target","arrow","strategy","middleware","placement","useTransform","isDestroyed","updatePosition","undefined","dispose","isFirstUpdate","scrollParents","Set","targetWindow","ownerDocument","defaultView","Object","assign","style","position","left","top","margin","forceUpdate","add","forEach","scrollParent","addEventListener","then","_ref","x","y","middlewareData","computedPlacement","coordinates","lowPPI","devicePixelRatio","catch","err","process","env","NODE_ENV","console","error","removeEventListener"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-positioning/lib/createPositionManager.js"],"sourcesContent":["import { computePosition } from '@floating-ui/dom';\nimport { debounce, writeArrowUpdates, writeContainerUpdates, getScrollParent } from './utils';\nimport { isHTMLElement } from '@fluentui/react-utilities';\n/**\n * @internal\n * @returns manager that handles positioning out of the react lifecycle\n */ export function createPositionManager(options) {\n    const { container , target , arrow , strategy , middleware , placement , useTransform =true  } = options;\n    let isDestroyed = false;\n    if (!target || !container) {\n        return {\n            updatePosition: ()=>undefined,\n            dispose: ()=>undefined\n        };\n    }\n    let isFirstUpdate = true;\n    const scrollParents = new Set();\n    const targetWindow = container.ownerDocument.defaultView;\n    // When the container is first resolved, set position `fixed` to avoid scroll jumps.\n    // Without this scroll jumps can occur when the element is rendered initially and receives focus\n    Object.assign(container.style, {\n        position: 'fixed',\n        left: 0,\n        top: 0,\n        margin: 0\n    });\n    const forceUpdate = ()=>{\n        // debounced update can still occur afterwards\n        // early return to avoid memory leaks\n        if (isDestroyed) {\n            return;\n        }\n        if (isFirstUpdate) {\n            scrollParents.add(getScrollParent(container));\n            if (isHTMLElement(target)) {\n                scrollParents.add(getScrollParent(target));\n            }\n            scrollParents.forEach((scrollParent)=>{\n                scrollParent.addEventListener('scroll', updatePosition);\n            });\n            isFirstUpdate = false;\n        }\n        Object.assign(container.style, {\n            position: strategy\n        });\n        computePosition(target, container, {\n            placement,\n            middleware,\n            strategy\n        }).then(({ x , y , middlewareData , placement: computedPlacement  })=>{\n            // Promise can still resolve after destruction\n            // early return to avoid applying outdated position\n            if (isDestroyed) {\n                return;\n            }\n            writeArrowUpdates({\n                arrow,\n                middlewareData\n            });\n            writeContainerUpdates({\n                container,\n                middlewareData,\n                placement: computedPlacement,\n                coordinates: {\n                    x,\n                    y\n                },\n                lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,\n                strategy,\n                useTransform\n            });\n        }).catch((err)=>{\n            // https://github.com/floating-ui/floating-ui/issues/1845\n            // FIXME for node > 14\n            // node 15 introduces promise rejection which means that any components\n            // tests need to be `it('', async () => {})` otherwise there can be race conditions with\n            // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist\n            // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing\n            // will actually be counter productive\n            if (process.env.NODE_ENV === 'development') {\n                // eslint-disable-next-line no-console\n                console.error('[usePositioning]: Failed to calculate position', err);\n            }\n        });\n    };\n    const updatePosition = debounce(()=>forceUpdate());\n    const dispose = ()=>{\n        isDestroyed = true;\n        if (targetWindow) {\n            targetWindow.removeEventListener('scroll', updatePosition);\n            targetWindow.removeEventListener('resize', updatePosition);\n        }\n        scrollParents.forEach((scrollParent)=>{\n            scrollParent.removeEventListener('scroll', updatePosition);\n        });\n    };\n    if (targetWindow) {\n        targetWindow.addEventListener('scroll', updatePosition);\n        targetWindow.addEventListener('resize', updatePosition);\n    }\n    // Update the position on initialization\n    updatePosition();\n    return {\n        updatePosition,\n        dispose\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}