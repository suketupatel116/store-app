{"ast":null,"code":"const DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */\nexport function columnDefinitionsToState(columns) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let columnSizingOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let updated = false;\n  const stateMap = new Map(state.map(s => [s.columnId, s]));\n  const updatedState = columns.map(column => {\n    const existingColumnState = stateMap.get(column.columnId);\n    if (existingColumnState) {\n      var _columnSizingOptions_column_columnId;\n      const {\n        idealWidth = existingColumnState.idealWidth,\n        minWidth = existingColumnState.minWidth,\n        padding = existingColumnState.padding\n      } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};\n      if (idealWidth !== existingColumnState.idealWidth || minWidth !== existingColumnState.minWidth || padding !== existingColumnState.padding) {\n        updated = true;\n        return {\n          ...existingColumnState,\n          idealWidth,\n          width: idealWidth,\n          minWidth,\n          padding\n        };\n      }\n      return existingColumnState;\n    }\n    var _columnSizingOptions_column_columnId1;\n    const {\n      defaultWidth,\n      idealWidth = DEFAULT_WIDTH,\n      minWidth = DEFAULT_MIN_WIDTH,\n      padding\n    } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};\n    updated = true;\n    return {\n      columnId: column.columnId,\n      width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n      minWidth,\n      idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n      padding: padding !== null && padding !== void 0 ? padding : 16\n    };\n  });\n  // If the length of the new state changed (column was added or removed) or any of\n  // the individual states has a new reference (column was replaced),\n  // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n  // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n  if (updatedState.length !== state.length || updated) {\n    const column = updatedState.find(col => col.width > col.idealWidth);\n    if (column) {\n      column.width = column.idealWidth;\n    }\n    updated = true;\n  }\n  return updated ? updatedState : state;\n}\nexport function getColumnById(state, columnId) {\n  return state.find(c => c.columnId === columnId);\n}\nexport function getColumnByIndex(state, index) {\n  return state[index];\n}\nexport function getTotalWidth(state) {\n  return state.reduce((sum, column) => sum + column.width + column.padding, 0);\n}\nexport function getLength(state) {\n  return state.length;\n}\nexport function getColumnWidth(state, columnId) {\n  const column = getColumnById(state, columnId);\n  var _column_width;\n  return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;\n}\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */\nexport function setColumnProperty(localState, columnId, property, value) {\n  const currentColumn = getColumnById(localState, columnId);\n  if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {\n    return localState;\n  }\n  const updatedColumn = {\n    ...currentColumn,\n    [property]: value\n  };\n  const newState = localState.reduce((acc, current) => {\n    if (current.columnId === updatedColumn.columnId) {\n      return [...acc, updatedColumn];\n    }\n    return [...acc, current];\n  }, []);\n  return newState;\n}\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */\nexport function adjustColumnWidthsToFitContainer(state, containerWidth) {\n  let newState = state;\n  const totalWidth = getTotalWidth(newState);\n  // The total width is smaller, we are expanding columns\n  if (totalWidth < containerWidth) {\n    let difference = containerWidth - totalWidth;\n    let i = 0;\n    // We start at the beginning and assign the columns their ideal width\n    while (i < newState.length && difference > 0) {\n      const currentCol = getColumnByIndex(newState, i);\n      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n      newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n      difference -= colAdjustment;\n      // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n      if (i === newState.length - 1 && difference !== 0) {\n        const lastCol = getColumnByIndex(newState, i);\n        newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n      }\n      i++;\n    }\n  } else if (totalWidth >= containerWidth) {\n    let difference = totalWidth - containerWidth;\n    // We start with the last column\n    let j = newState.length - 1;\n    while (j >= 0 && difference > 0) {\n      const currentCol = getColumnByIndex(newState, j);\n      if (currentCol.width > currentCol.minWidth) {\n        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n        difference -= colAdjustment;\n        newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n      }\n      j--;\n    }\n  }\n  return newState;\n}","map":{"version":3,"names":["DEFAULT_WIDTH","DEFAULT_MIN_WIDTH","columnDefinitionsToState","columns","state","arguments","length","undefined","columnSizingOptions","updated","stateMap","Map","map","s","columnId","updatedState","column","existingColumnState","get","_columnSizingOptions_column_columnId","idealWidth","minWidth","padding","width","_columnSizingOptions_column_columnId1","defaultWidth","Math","max","find","col","getColumnById","c","getColumnByIndex","index","getTotalWidth","reduce","sum","getLength","getColumnWidth","_column_width","setColumnProperty","localState","property","value","currentColumn","updatedColumn","newState","acc","current","adjustColumnWidthsToFitContainer","containerWidth","totalWidth","difference","i","currentCol","colAdjustment","min","lastCol","j"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-table/lib/utils/columnResizeUtils.js"],"sourcesContent":["const DEFAULT_WIDTH = 150;\nconst DEFAULT_MIN_WIDTH = 100;\n/**\n * This function takes the column definitions and the curent ColumnWidthState and returns new state.\n *  - It uses existing state for existing columns.\n *  - It removes any state for columns no longer present.\n *  - It checks if any column has been replaced and returns updated state if so\n *  - It returns old state if no changes in the state have been made (so that react doesn't call effects)\n * @param columns\n * @param state\n * @returns\n */ export function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {\n    let updated = false;\n    const stateMap = new Map(state.map((s)=>[\n            s.columnId,\n            s\n        ]));\n    const updatedState = columns.map((column)=>{\n        const existingColumnState = stateMap.get(column.columnId);\n        if (existingColumnState) {\n            var _columnSizingOptions_column_columnId;\n            const { idealWidth =existingColumnState.idealWidth , minWidth =existingColumnState.minWidth , padding =existingColumnState.padding  } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};\n            if (idealWidth !== existingColumnState.idealWidth || minWidth !== existingColumnState.minWidth || padding !== existingColumnState.padding) {\n                updated = true;\n                return {\n                    ...existingColumnState,\n                    idealWidth,\n                    width: idealWidth,\n                    minWidth,\n                    padding\n                };\n            }\n            return existingColumnState;\n        }\n        var _columnSizingOptions_column_columnId1;\n        const { defaultWidth , idealWidth =DEFAULT_WIDTH , minWidth =DEFAULT_MIN_WIDTH , padding  } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};\n        updated = true;\n        return {\n            columnId: column.columnId,\n            width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n            minWidth,\n            idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),\n            padding: padding !== null && padding !== void 0 ? padding : 16\n        };\n    });\n    // If the length of the new state changed (column was added or removed) or any of\n    // the individual states has a new reference (column was replaced),\n    // we have to reset the column widths to their ideal width (because the column which was last may not be last now).\n    // Then the adjustColumnWidthsToFitContainer can do its job and properly stretch the last column.\n    if (updatedState.length !== state.length || updated) {\n        const column = updatedState.find((col)=>col.width > col.idealWidth);\n        if (column) {\n            column.width = column.idealWidth;\n        }\n        updated = true;\n    }\n    return updated ? updatedState : state;\n}\nexport function getColumnById(state, columnId) {\n    return state.find((c)=>c.columnId === columnId);\n}\nexport function getColumnByIndex(state, index) {\n    return state[index];\n}\nexport function getTotalWidth(state) {\n    return state.reduce((sum, column)=>sum + column.width + column.padding, 0);\n}\nexport function getLength(state) {\n    return state.length;\n}\nexport function getColumnWidth(state, columnId) {\n    const column = getColumnById(state, columnId);\n    var _column_width;\n    return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;\n}\n/**\n * This function takes the current state and returns an updated state, so that it can be set.\n * The reason for this is that we can update the state multiple times before commiting to render.\n * This is an optimization and also prevents flickering.\n * It also returns new copy of the state only if the value is different than the one currently in\n * the state, further preventing unnecessary updates.\n * @param localState\n * @param columnId\n * @param property\n * @param value\n * @returns\n */ export function setColumnProperty(localState, columnId, property, value) {\n    const currentColumn = getColumnById(localState, columnId);\n    if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {\n        return localState;\n    }\n    const updatedColumn = {\n        ...currentColumn,\n        [property]: value\n    };\n    const newState = localState.reduce((acc, current)=>{\n        if (current.columnId === updatedColumn.columnId) {\n            return [\n                ...acc,\n                updatedColumn\n            ];\n        }\n        return [\n            ...acc,\n            current\n        ];\n    }, []);\n    return newState;\n}\n/**\n * This function takes the state and container width and makes sure the each column in the state\n * is its optimal width, and that the columns\n * a) fit to the container\n * b) always fill the whole container\n * @param state\n * @param containerWidth\n * @returns\n */ export function adjustColumnWidthsToFitContainer(state, containerWidth) {\n    let newState = state;\n    const totalWidth = getTotalWidth(newState);\n    // The total width is smaller, we are expanding columns\n    if (totalWidth < containerWidth) {\n        let difference = containerWidth - totalWidth;\n        let i = 0;\n        // We start at the beginning and assign the columns their ideal width\n        while(i < newState.length && difference > 0){\n            const currentCol = getColumnByIndex(newState, i);\n            const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);\n            newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width + colAdjustment);\n            difference -= colAdjustment;\n            // if there is still empty space, after all columns are their ideal sizes, assign it to the last column\n            if (i === newState.length - 1 && difference !== 0) {\n                const lastCol = getColumnByIndex(newState, i);\n                newState = setColumnProperty(newState, lastCol.columnId, 'width', lastCol.width + difference);\n            }\n            i++;\n        }\n    } else if (totalWidth >= containerWidth) {\n        let difference = totalWidth - containerWidth;\n        // We start with the last column\n        let j = newState.length - 1;\n        while(j >= 0 && difference > 0){\n            const currentCol = getColumnByIndex(newState, j);\n            if (currentCol.width > currentCol.minWidth) {\n                const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);\n                difference -= colAdjustment;\n                newState = setColumnProperty(newState, currentCol.columnId, 'width', currentCol.width - colAdjustment);\n            }\n            j--;\n        }\n    }\n    return newState;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}