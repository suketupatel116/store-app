{"ast":null,"code":"import { nativeFocus, KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst TabsterAttributeName = \"data-tabster\";\nconst TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nconst DeloserEventName = \"tabster:deloser\";\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nconst ModalizerBeforeFocusOutEventName = \"tabster:modalizer:beforefocusout\";\nconst MoverEventName = \"tabster:mover\";\nconst FocusInEventName = \"tabster:focusin\";\nconst FocusOutEventName = \"tabster:focusout\";\nconst ObservedElementAccesibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst RestorerTypes = {\n  Source: 0,\n  Target: 1\n};\nconst MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3,\n  GridLinear: 4\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2\n};\nvar Types = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TabsterAttributeName: TabsterAttributeName,\n  TabsterDummyInputAttributeName: TabsterDummyInputAttributeName,\n  DeloserEventName: DeloserEventName,\n  ModalizerActiveEventName: ModalizerActiveEventName,\n  ModalizerInactiveEventName: ModalizerInactiveEventName,\n  ModalizerFocusInEventName: ModalizerFocusInEventName,\n  ModalizerFocusOutEventName: ModalizerFocusOutEventName,\n  ModalizerBeforeFocusOutEventName: ModalizerBeforeFocusOutEventName,\n  MoverEventName: MoverEventName,\n  FocusInEventName: FocusInEventName,\n  FocusOutEventName: FocusOutEventName,\n  ObservedElementAccesibilities: ObservedElementAccesibilities,\n  RestoreFocusOrders: RestoreFocusOrders,\n  Visibilities: Visibilities,\n  RestorerTypes: RestorerTypes,\n  MoverDirections: MoverDirections,\n  GroupperTabbabilities: GroupperTabbabilities,\n  SysDummyInputsPositions: SysDummyInputsPositions\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TabsterAttributeName);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"restorer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n          break;\n        case \"observed\":\n          delete tabsterOnElement[key];\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n          break;\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n        break;\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n        break;\n      case \"restorer\":\n        if (tabsterOnElement.restorer) {\n          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);\n        } else {\n          if (tabster.restorer) {\n            if (newTabsterProps.restorer) {\n              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);\n            }\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Restorer API used before initialization, please call `getRestorer()`\");\n          }\n        }\n        break;\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n        break;\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n        break;\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n        break;\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n        break;\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction createEventTarget(getWindow) {\n  const global = getWindow();\n  try {\n    if (global.EventTarget) {\n      return new global.EventTarget();\n    }\n  } catch (error) {\n    // thrown if EventTarget is not constructable or doesn't exit\n    if (!(error instanceof TypeError)) {\n      throw error;\n    }\n  }\n  return global.document.createElement(\"div\");\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nlet _isBrokenIE11;\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n};\nlet _uidCounter = 0;\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n} catch (e) {\n  _isBrokenIE11 = true;\n}\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n  deref() {\n    return this._target;\n  }\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n    return false;\n  }\n}\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n    this._ref = ref;\n    this._data = data;\n  }\n  get() {\n    const ref = this._ref;\n    let element;\n    if (ref) {\n      element = ref.deref();\n      if (!element) {\n        delete this._ref;\n      }\n    }\n    return element;\n  }\n  getData() {\n    return this._data;\n  }\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\n\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  } // TypeScript isn't aware of IE11 behaving badly.\n\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false\n  /* Last argument is not optional for IE11! */);\n}\n\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n  if (cached) {\n    return cached.rect;\n  }\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n  if (!scrollingElement) {\n    return new _DOMRect();\n  } // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n  if (!container) {\n    return false;\n  }\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n  if (doc) {\n    for (let el = element.parentElement; el; el = el.parentElement) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n    return doc.documentElement;\n  }\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n  const srnd = [];\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n    if (el && parent) {\n      if (!parent.contains(el)) {\n        continue;\n      }\n    }\n    delete context.elementByUId[key];\n  }\n} // IE11 doesn't have document.contains()...\n\nfunction documentContains(doc, element) {\n  var _a;\n  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = {\n      ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n  getElement() {\n    return this._element.get();\n  }\n  getProps() {\n    return this._props;\n  }\n  setProps(props) {\n    this._props = {\n      ...props\n    };\n  }\n}\n/**\r\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\r\n */\n\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element) {\n    var _a;\n    this._focusIn = e => {\n      const input = this.input;\n      if (this.onFocusIn && input) {\n        const relatedTarget = DummyInputManager.getLastPhantomFrom() || e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n    this._focusOut = e => {\n      this.useDefaultAction = false;\n      const input = this.input;\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TabsterDummyInputAttributeName, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n    const input = this.input;\n    if (!input) {\n      return;\n    }\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n  setTopLeft(top, left) {\n    var _a;\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n    this.moveOut = backwards => {\n      var _a;\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n    };\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);\n    };\n  }\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n  setTabbable(tabbable) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n      delete this._instance;\n    }\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n  static getLastPhantomFrom() {\n    const ret = DummyInputManager._lastPhantomFrom;\n    delete DummyInputManager._lastPhantomFrom;\n    return ret;\n  }\n  static moveWithPhantomDummy(tabster, element, moveOutside, isBackward) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n    if (input) {\n      const parent = element.parentElement;\n      if (parent) {\n        let insertBefore = moveOutside && !isBackward || !moveOutside && isBackward ? element.nextElementSibling : element;\n        if (insertBefore) {\n          if (isBackward) {\n            const beforeBefore = insertBefore.previousElementSibling;\n            if (beforeBefore && beforeBefore.__tabsterDummyContainer) {\n              insertBefore = beforeBefore;\n            }\n          } else if (insertBefore.__tabsterDummyContainer) {\n            insertBefore = insertBefore.nextElementSibling;\n          }\n        }\n        parent.insertBefore(input, insertBefore);\n        DummyInputManager._lastPhantomFrom = element;\n        tabster.getWindow().setTimeout(() => {\n          delete DummyInputManager._lastPhantomFrom;\n        }, 0);\n        nativeFocus(input);\n      }\n    }\n  }\n}\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TabsterDummyInputAttributeName, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummies = new Map();\n    this._domChanged = parent => {\n      var _a;\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n      this._changedParents.add(parent);\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n        for (const [dummy, callback] of this._dummies) {\n          const dummyParent = dummy.parentElement;\n          if (!dummyParent || this._changedParents.has(dummyParent)) {\n            callback();\n          }\n        }\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n    this._win = win;\n  }\n  add(dummy, callback) {\n    this._dummies.set(dummy, callback);\n    this.domChanged = this._domChanged;\n  }\n  remove(dummy) {\n    const dummyInputElements = this._dummies;\n    dummyInputElements.delete(dummy);\n    if (dummyInputElements.size === 0) {\n      delete this.domChanged;\n    }\n  }\n  dispose() {\n    var _a;\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n    this._changedParents = new WeakSet();\n    this._dummies.clear();\n    delete this._win;\n  }\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n    this._updateQueue.add(compute);\n    this._lastUpdateQueueTime = Date.now();\n    this._scheduledUpdatePositions();\n  }\n  _scheduledUpdatePositions() {\n    var _a;\n    if (this._updateTimer) {\n      return;\n    }\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer; // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n        this._updateQueue.clear(); // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        } // Explicitly clear to not hold references till the next garbage collection.\n\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n}\n/**\r\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\r\n */\n\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n    this.moveOut = backwards => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    /**\r\n     * Prepares to move focus out of the given element by focusing\r\n     * one of the dummy inputs and setting the `useDefaultAction` flag\r\n     * @param backwards focus moving to an element behind the given element\r\n     */\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n      const wrapper = this._getCurrent();\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\r\n     * Adds dummy inputs as the first and last child of the given element\r\n     * Called each time the children under the element is mutated\r\n     */\n\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n        this._ensurePosition();\n        if (process.env.NODE_ENV === 'development') {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n        this._addTransformOffsets();\n      }, 0);\n    };\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n      const win = this._getWindow();\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = element.parentElement) {\n        let scrollTopLeft = scrollTopLeftCache.get(element); // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n    const el = element.get();\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n    if (instance) {\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n      return instance;\n    }\n    el.__tabsterDummy = this; // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element); // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n    this._addDummyInputs();\n  }\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n    if (process.env.NODE_ENV === 'development') {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n      this._transformElements.clear();\n      const win = this._getWindow();\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n    const wrapper = this._getCurrent();\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n      return a.priority - b.priority;\n    });\n    return this._wrappers[0];\n  }\n  _ensurePosition() {\n    var _a, _b, _c;\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n    if (this._isOutside) {\n      const elementParent = element.parentElement;\n      if (elementParent) {\n        const nextSibling = element.nextElementSibling;\n        if (nextSibling !== lastDummyInput) {\n          elementParent.insertBefore(lastDummyInput, nextSibling);\n        }\n        if (element.previousElementSibling !== firstDummyInput) {\n          elementParent.insertBefore(firstDummyInput, element);\n        }\n      }\n    } else {\n      if (element.lastElementChild !== lastDummyInput) {\n        element.appendChild(lastDummyInput);\n      }\n      const firstElementChild = element.firstElementChild;\n      if (firstElementChild && firstElementChild !== firstDummyInput) {\n        element.insertBefore(firstDummyInput, firstElementChild);\n      }\n    }\n  }\n}\nfunction getLastChild(container) {\n  let lastChild = null;\n  for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n    lastChild = i;\n  }\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n  while (cur && !adjacent) {\n    adjacent = prev ? cur.previousElementSibling : cur.nextElementSibling;\n    cur = cur.parentElement;\n  }\n  return adjacent || undefined;\n}\nfunction triggerEvent(target, name, details) {\n  const event = document.createEvent(\"HTMLEvents\");\n  event.initEvent(name, true, true);\n  event.details = details;\n  target.dispatchEvent(event);\n  return !event.defaultPrevented;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n    entry.aug = {};\n  }\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n      ret = true;\n    }\n  } else {\n    let origValue;\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n      ret = true;\n    }\n  }\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n  return ret;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n  if (plain === true) {\n    return attr;\n  }\n  return {\n    [TabsterAttributeName]: attr\n  };\n}\n/**\r\n * Updates Tabster props object with new props.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param props current Tabster props to update.\r\n * @param newProps new Tabster props to add.\r\n *  When the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\r\n * Sets or updates Tabster attribute of the element.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param newProps new Tabster props to set.\r\n * @param update if true, newProps will be merged with the existing props.\r\n *  When true and the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n  if (update) {\n    const attr = element.getAttribute(TabsterAttributeName);\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n  if (!props) {\n    props = {};\n  }\n  mergeTabsterProps(props, newProps);\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TabsterAttributeName);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false, true);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n        const element = this._element.get();\n        if (element) {\n          this._setFocused(true, true);\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n          if (toFocus) {\n            nativeFocus(toFocus);\n            return;\n          }\n        }\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n    this._setHandlers(this._onDummyInputFocus);\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n}\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n    this._setFocused = (hasFocused, fromAdjacent) => {\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n        delete this._setFocusedTimer;\n      }\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n      const element = this._element.get();\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          triggerEvent(this._tabster.root.eventTarget, \"focus\", {\n            element,\n            fromAdjacent\n          });\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            triggerEvent(this._tabster.root.eventTarget, \"blur\", {\n              element,\n              fromAdjacent\n            });\n          }, 0);\n        }\n      }\n    };\n    this._onFocus = e => {\n      var _a;\n      const win = this._tabster.getWindow();\n      if (this._setTabbableTimer) {\n        win.clearTimeout(this._setTabbableTimer);\n        delete this._setTabbableTimer;\n      }\n      if (e) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, e);\n        if (ctx) {\n          this._setFocused(ctx.root.getElement() === this._element.get());\n        }\n        if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          return;\n        }\n      } else {\n        this._setFocused(false);\n      }\n      this._setTabbableTimer = win.setTimeout(() => {\n        var _a;\n        delete this._setTabbableTimer;\n        (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n      }, 0);\n    };\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n    tabster.focusedElement.subscribe(this._onFocus);\n    this._add();\n  }\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const win = this._tabster.getWindow();\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n    if (this._setTabbableTimer) {\n      win.clearTimeout(this._setTabbableTimer);\n      delete this._setTabbableTimer;\n    }\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._remove();\n  }\n  moveOutWithDefaultAction(isBackward) {\n    const dummyManager = this._dummyManager;\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward);\n    } else {\n      const el = this.getElement();\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward);\n      }\n    }\n  }\n  _add() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n    this._autoRootCreate = () => {\n      var _a;\n      const doc = this._win().document;\n      const body = doc.body;\n      if (body) {\n        this._autoRootUnwait(doc);\n        const props = this._autoRoot;\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n      return undefined;\n    };\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    this.eventTarget = createEventTarget(this._win);\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n  dispose() {\n    const win = this._win();\n    this._autoRootUnwait(win.document);\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n  createRoot(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n    return newRoot;\n  }\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\r\n   * Fetches the tabster context for an element walking up its ancestors\r\n   *\r\n   * @param tabster Tabster instance\r\n   * @param element The element the tabster context should represent\r\n   * @param options Additional options\r\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\r\n   */\n\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _a, _b, _c, _d;\n    if (!element.ownerDocument) {\n      return undefined;\n    } // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n\n    tabster.drainInitQueue();\n    const checkRtl = options.checkRtl;\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let isExcludedFromMover = false;\n    let isGroupperFirst;\n    let modalizerInGroupper;\n    let isRtl;\n    let uncontrolled;\n    let curElement = element;\n    const ignoreKeydown = {};\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n      if (checkRtl && isRtl === undefined) {\n        const dir = curElement.dir;\n        if (dir) {\n          isRtl = dir.toLowerCase() === \"rtl\";\n        }\n      }\n      if (!tabsterOnElement) {\n        curElement = curElement.parentElement;\n        continue;\n      }\n      const tagName = curElement.tagName;\n      if (tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") {\n        uncontrolled = curElement;\n      }\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        isExcludedFromMover = true;\n      }\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element)) {\n        mover = curMover;\n        isGroupperFirst = !!groupper && groupper !== curGroupper;\n      }\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n      curElement = curElement.parentElement;\n    } // No root element could be found, try to get an auto root\n\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n    if (groupper && !mover) {\n      isGroupperFirst = true;\n    }\n    if (process.env.NODE_ENV === 'development' && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      isGroupperFirst,\n      modalizerInGroupper,\n      isRtl: checkRtl ? !!isRtl : undefined,\n      uncontrolled,\n      isExcludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n  static getRoot(tabster, element) {\n    var _a;\n    for (let el = element; el; el = el.parentElement) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n      if (root) {\n        return root;\n      }\n    }\n    return undefined;\n  }\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n    return available ? this._tabster.focusedElement.focus(available) : false;\n  }\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n  getLength() {\n    return this._history.length;\n  }\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n}\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n    item.unshift(element);\n    this._history.unshift(item);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip && (await i.focusAvailable())) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    } // Nothing is found, at least try to reset.\n\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass DeloserHistory {\n  constructor(tabster) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    this._history = [];\n    this._tabster = tabster;\n  }\n  dispose() {\n    this._history = [];\n  }\n  process(element) {\n    var _a;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n    return deloser;\n  }\n  make(rootUId, createInstance) {\n    let historyByRoot;\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n    this._history.unshift(historyByRoot);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n    return historyByRoot;\n  }\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip && (await h.focusAvailable(from))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n  const elementId = element.getAttribute(\"id\");\n  if (elementId) {\n    selector.push(\"#\" + elementId.replace(escapeRegExp, escapeReplaceValue));\n  }\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n  let index = 0;\n  let el;\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n  const selector = [buildElementSelector(element)];\n  let el = element.parentElement;\n  while (el) {\n    const isBody = el.tagName === \"BODY\";\n    selector.unshift(buildElementSelector(el, false, !isBody));\n    if (isBody) {\n      break;\n    }\n    el = el.parentElement;\n  }\n  return selector.join(\" \");\n}\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n    this.isActive = () => {\n      return this._isActive;\n    };\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n    this.focusFirst = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n    this.focusDefault = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n    this.resetFocus = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? element.contains(e) : false;\n      });\n    };\n    this.uid = getElementUId(tabster.getWindow, element);\n    this._onDispose = onDispose;\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  dispose() {\n    this._remove();\n    this._onDispose(this);\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n  setActive(active) {\n    this._isActive = active;\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n  findAvailable() {\n    const element = this._element.get();\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    if (!ctx) {\n      return null;\n    }\n    const root = ctx.root;\n    const rootElement = root.getElement();\n    if (!rootElement) {\n      return null;\n    }\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n    if (available) {\n      return available;\n    }\n    const availableInHistory = this._findInHistory();\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n    const availableFirst = this._findFirst(element);\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n  customFocusLostHandler(element) {\n    return triggerEvent(element, DeloserEventName, this.getActions());\n  }\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n    this.clearHistory(true);\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n      const element = this._element.get();\n      if (e && element && element.contains(e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n        if (selector && element) {\n          let els;\n          try {\n            els = element.ownerDocument.querySelectorAll(selector);\n          } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n            continue;\n          }\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n      if (first) {\n        return first;\n      }\n    }\n    return null;\n  }\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\r\n     * Tracks if focus is inside a deloser\r\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n        this._restoreFocusTimer = undefined;\n      }\n      if (!e) {\n        this._scheduleRestoreFocus();\n        return;\n      }\n      const deloser = this._history.process(e);\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const doc = this._win().document;\n      const activeElement = doc.activeElement;\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    this._history.dispose();\n    delete this._curDeloser;\n  }\n  createDeloser(element, props) {\n    var _a;\n    if (process.env.NODE_ENV === 'development') ;\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n    return deloser;\n  }\n  getActions(element) {\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n    return undefined;\n  }\n  pause() {\n    this._isPaused = true;\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n  }\n  resume(restore) {\n    this._isPaused = false;\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\r\n   * Activates and sets the current deloser\r\n   */\n\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\r\n   * Called when focus should no longer be in a deloser\r\n   */\n\n  _deactivate() {\n    var _a;\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n      if (!force && (this._isRestoringFocus || !this._inDeloser || !!(lastFocused === null || lastFocused === void 0 ? void 0 : lastFocused.offsetParent))) {\n        return;\n      }\n      const curDeloser = this._curDeloser;\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n        const el = curDeloser.findAvailable();\n        if (el && this._tabster.focusedElement.focus(el)) {\n          return;\n        }\n      }\n      this._deactivate();\n      this._isRestoringFocus = true;\n      if (!(await this._history.focusAvailable(null))) {\n        await this._history.resetFocus(null);\n      }\n      this._isRestoringFocus = false;\n    };\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n  static getDeloser(tabster, element) {\n    var _a;\n    let root;\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n        const deloser = tabsterOnElement.deloser;\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n    const deloserAPI = tabster.deloser && tabster.deloser;\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n      const autoDeloserProps = deloserAPI._autoDeloser;\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n      return deloserAPI._autoDeloserInstance;\n    }\n    return undefined;\n  }\n  static getHistory(instance) {\n    return instance._history;\n  }\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n    callbacks.unshift(callback);\n  }\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n  setVal(val, details) {\n    if (this._val === val) {\n      return;\n    }\n    this._val = val;\n    this._callCallbacks(val, details);\n  }\n  getVal() {\n    return this._val;\n  }\n  trigger(val, details) {\n    this._callCallbacks(val, details);\n  }\n  _callCallbacks(val, details) {\n    this._callbacks.forEach(callback => callback(val, details));\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n  async focusAvailable() {\n    const data = {\n      ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n  async resetFocus() {\n    const data = {\n      ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n}\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n  unshift(deloser) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n    this._history.unshift(item);\n    this._history.splice(10, this._history.length - 10);\n  }\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = {\n      ...this._sentTo\n    };\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n    return this._promise;\n  }\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n    this._isDone = true;\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n  onResponse(data) {\n    const endData = data.endData;\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n}\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n}\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n}\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n    return true;\n  }\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n    return true;\n  }\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n    return true;\n  }\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (name && element) {\n      CrossOriginObservedElementState.trigger(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n    return true;\n  }\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n      return true;\n    });\n  }\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n    return true;\n  }\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n    return true;\n  }\n}\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static findElement(tabster, getOwner, data) {\n    let element;\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = getOwner().document.getElementById(data.id);\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n    return element || null;\n  }\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n}\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n    return !!forwardRet;\n  }\n}\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse() {\n    return true;\n  }\n}\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const data = e.data;\n      let transactionId;\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n      let knownTarget = this._knownTargets[data.owner];\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n        const forwardResult = this.forwardTransaction(data);\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n    this._onPageHide = () => {\n      this._dead();\n    };\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n      this._ping();\n    }\n    return this._onMessage;\n  }\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n    this.sendUp = sendUp || undefined;\n    const owner = this._owner();\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = (\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n    return this._onMessage;\n  }\n  async dispose() {\n    const owner = this._owner();\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n      t.transaction.end();\n    }\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n  forwardTransaction(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n    const Transaction = this._getTransactionClass(data.type);\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n  _getTransactionClass(type // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n      default:\n        return null;\n    }\n  }\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n        return false;\n      })));\n    }\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n      this._ping();\n    }, _pingTimeout);\n  }\n}\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, {\n      ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n  static setVal(instance, val, details) {\n    instance.setVal(val, details);\n  }\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ?\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      tabster.observedElement.subscribe(this._onObserved);\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        tabster.outline.setup = this._outlineSetup;\n      }\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n    this._onFocus = element => {\n      const win = this._win();\n      const ownerUId = getWindowUId(win);\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, {\n          ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n    this._onObserved = (element, details) => {\n      var _a;\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n      return this._transactions.setup(sendUp);\n    }\n  }\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n  dispose() {\n    var _a;\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n    this._transactions.dispose();\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n}\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n    return uid;\n  }\n  return undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _focusableSelector = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\"].join(\", \");\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n  dispose() {\n    /**/\n  }\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, _focusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n    return false;\n  }\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n    if (el.offsetParent === null && el.ownerDocument.body !== el) {\n      return false;\n    }\n    const win = el.ownerDocument.defaultView;\n    if (!win) {\n      return false;\n    }\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n    const computedStyle = win.getComputedStyle(el);\n    if (computedStyle.visibility === \"hidden\") {\n      return false;\n    }\n    return true;\n  }\n  isAccessible(el) {\n    var _a;\n    for (let e = el; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (this._isHidden(e)) {\n        return false;\n      }\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n  _isHidden(el) {\n    var _a;\n    const attrVal = el.getAttribute(\"aria-hidden\");\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  findFirst(options) {\n    return this.findElement({\n      ...options\n    });\n  }\n  findLast(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n  findNext(options) {\n    return this.findElement({\n      ...options\n    });\n  }\n  findPrev(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n  findDefault(options) {\n    return this.findElement({\n      ...options,\n      acceptCondition: el => this._tabster.focusable.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }) || null;\n  }\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n  findElement(options) {\n    const found = this._findElements(false, options);\n    return found ? found[0] : found;\n  }\n  _findElements(findAll, options) {\n    var _a, _b, _c;\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onUncontrolled,\n      onElement\n    } = options;\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n    if (!container) {\n      return null;\n    }\n    if (!acceptCondition) {\n      acceptCondition = el => this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      acceptCondition,\n      includeProgrammaticallyFocusable,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      cachedGrouppers: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n    if (!walker) {\n      return null;\n    }\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      const foundElement = acceptElementState.foundElement;\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n      if (findAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n    if (currentElement) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild(container);\n      if (!lastChild) {\n        return null;\n      }\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        return elements;\n      }\n      walker.currentNode = lastChild;\n    }\n    let foundElement;\n    do {\n      foundElement = (isBackward ? walker.previousNode() : walker.nextNode()) || undefined;\n    } while (prepareForNextElement());\n    if (!findAll) {\n      const nextUncontrolled = acceptElementState.nextUncontrolled;\n      if (nextUncontrolled) {\n        if (onUncontrolled) {\n          onUncontrolled(nextUncontrolled);\n        }\n        if (foundElement) {\n          // We have an uncontrolled area and there is a controlled element after it.\n          // Return undefined for the default Tab action.\n          return undefined;\n        } else {\n          // Otherwise, return null to moveOutWithDefaultAction().\n          return null;\n        }\n      }\n    }\n    return elements.length ? elements : null;\n  }\n  _acceptElement(element, state) {\n    var _a, _b, _c, _d, _e;\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    const container = state.container;\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (!container.contains(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (element.__tabsterDummyContainer) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    let lastToIgnore = state.lastToIgnore;\n    if (lastToIgnore) {\n      if (lastToIgnore.contains(element)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        lastToIgnore = state.lastToIgnore = undefined;\n      }\n    }\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special\n\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (state.ignoreUncontrolled) {\n      if (shouldIgnoreFocus(element)) {\n        return NodeFilter.FILTER_SKIP;\n      }\n    } else if (ctx.uncontrolled && !state.nextUncontrolled && this._tabster.focusable.isFocusable(element, undefined, true, true)) {\n      if (!ctx.groupper && !ctx.mover) {\n        if (((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n          if (this.isVisible(ctx.uncontrolled)) {\n            state.nextUncontrolled = ctx.uncontrolled;\n          }\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    } // We assume iframes are focusable because native tab behaviour would tab inside\n\n    if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n      if (((_c = ctx.modalizer) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.activeId)) {\n        state.found = true;\n        state.lastToIgnore = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    let result;\n    let fromCtx = state.fromCtx;\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_e = this._tabster.modalizer) === null || _e === void 0 ? void 0 : _e.acceptElement(element, state);\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n      if (moverElement && fromMoverElement && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n      if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {\n        groupper = undefined;\n      }\n      if (moverElement && !container.contains(moverElement)) {\n        mover = undefined;\n      }\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      state.found = true;\n      state.foundElement = element;\n    }\n    return result;\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst Keys = {\n  Tab: 9,\n  Enter: 13,\n  Esc: 27,\n  Space: 32,\n  PageUp: 33,\n  PageDown: 34,\n  End: 35,\n  Home: 36,\n  Left: 37,\n  Up: 38,\n  Right: 39,\n  Down: 40\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n    this._init = () => {\n      const win = this._win();\n      const doc = win.document; // Add these event listeners as capture - we want Tabster to run before user event handlers\n\n      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(\"focusout\", this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = doc.activeElement;\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n      this.subscribe(this._onChanged);\n    };\n    this._onFocusIn = e => {\n      this._setFocusedElement(e.target, e.details.relatedTarget, e.details.isFocusedProgrammatically);\n    };\n    this._onFocusOut = e => {\n      this._setFocusedElement(undefined, e.relatedTarget);\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._validateFocusedElement = element => {// TODO: Make sure this is not needed anymore and write tests.\n    };\n    this._onKeyDown = e => {\n      var _a, _b, _c, _d, _e, _f;\n      if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n        return;\n      }\n      const currentElement = this.getVal();\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n      if (!ctx || ctx.ignoreKeydown(e)) {\n        return;\n      }\n      const isBackward = e.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, isBackward, undefined, true);\n      let nextElement;\n      if (next) {\n        let uncontrolled = next.uncontrolled;\n        if (uncontrolled) {\n          const isGroupperFirst = ctx.isGroupperFirst;\n          let moveOutside = false;\n          if (isGroupperFirst !== undefined) {\n            const groupper = (_a = ctx.groupper) === null || _a === void 0 ? void 0 : _a.getElement();\n            const mover = (_b = ctx.mover) === null || _b === void 0 ? void 0 : _b.getElement();\n            let moveFrom;\n            if (isGroupperFirst && groupper && uncontrolled.contains(groupper)) {\n              moveFrom = groupper;\n            } else if (!isGroupperFirst && mover && uncontrolled.contains(mover)) {\n              moveFrom = mover;\n            }\n            if (moveFrom) {\n              uncontrolled = moveFrom;\n              moveOutside = true;\n            }\n          }\n          if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n            // We have met an uncontrolled area, just allow default action.\n            DummyInputManager.moveWithPhantomDummy(this._tabster, uncontrolled, moveOutside, isBackward);\n          }\n          return;\n        }\n        nextElement = next.element;\n      }\n      if (nextElement) {\n        const preventDefault = () => {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }; // For iframes just allow normal Tab behaviour\n\n        if (!controlTab) {\n          const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n          let outOfDOMOrder = next === null || next === void 0 ? void 0 : next.outOfDOMOrder;\n          if (!outOfDOMOrder && currentElement.compareDocumentPosition(nextElement) & (isBackward ? document.DOCUMENT_POSITION_FOLLOWING : document.DOCUMENT_POSITION_PRECEDING)) {\n            outOfDOMOrder = true;\n          }\n          if (outOfDOMOrder) {\n            // The next element is out of DOM order (for example because of a trapped groupper),\n            // do not let the browser to move focus.\n            preventDefault();\n            nativeFocus(nextElement);\n          } else if (lastMoverOrGroupper) {\n            (_c = lastMoverOrGroupper.dummyManager) === null || _c === void 0 ? void 0 : _c.moveOutWithDefaultAction(isBackward);\n          } else if (ctx.modalizer) {\n            const nextElementCtx = RootAPI.getTabsterContext(tabster, nextElement);\n            if ((!nextElementCtx || ctx.root.uid !== nextElementCtx.root.uid || !((_d = nextElementCtx.modalizer) === null || _d === void 0 ? void 0 : _d.isActive())) && ctx.modalizer.triggerFocusEvent(ModalizerBeforeFocusOutEventName, true)) {\n              preventDefault();\n            } else if (!((_e = ctx.modalizer.getElement()) === null || _e === void 0 ? void 0 : _e.contains(nextElement))) {\n              preventDefault();\n              (_f = ctx.modalizer.dummyManager) === null || _f === void 0 ? void 0 : _f.moveOut(isBackward);\n            }\n          }\n        } else if (nextElement.tagName !== \"IFRAME\") {\n          preventDefault();\n          nativeFocus(nextElement);\n        }\n      } else {\n        ctx.root.moveOutWithDefaultAction(isBackward);\n      }\n    };\n    this._onChanged = (element, details) => {\n      var _a, _b;\n      if (element) {\n        triggerEvent(element, FocusInEventName, details);\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n        if (last) {\n          const d = {\n            ...details\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n          triggerEvent(last, FocusOutEventName, d);\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    super.dispose();\n    const win = this._win();\n    win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n    win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n    if (el && parent.contains(el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n    if (el && parent.contains(el)) {\n      delete instance._nextVal;\n    }\n    wel = instance._lastVal;\n    el = wel && wel.get();\n    if (el && parent.contains(el)) {\n      delete instance._lastVal;\n    }\n  }\n  getFocusedElement() {\n    return this.getVal();\n  }\n  getLastFocusedElement() {\n    var _a;\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n    return el;\n  }\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n    element.focus();\n    return true;\n  }\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n      return true;\n    }\n    return false;\n  }\n  getFirstOrLastTabbable(isFirst, props) {\n    const tabsterFocusable = this._tabster.focusable;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let uncontrolled;\n    let toFocus;\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n      if (ctx) {\n        let next = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, !isFirst, undefined, ignoreAccessibility);\n        if (next) {\n          toFocus = next.element;\n          uncontrolled = next.uncontrolled;\n          while (!toFocus && uncontrolled) {\n            if (tabsterFocusable.isFocusable(uncontrolled, false, true, true)) {\n              toFocus = uncontrolled;\n            } else {\n              toFocus = tabsterFocusable[isFirst ? \"findFirst\" : \"findLast\"]({\n                container: uncontrolled,\n                ignoreUncontrolled: true,\n                ignoreAccessibility,\n                useActiveModalizer: true\n              });\n            }\n            if (!toFocus) {\n              next = FocusedElementState.findNextTabbable(this._tabster, ctx, uncontrolled, undefined, !isFirst, undefined, ignoreAccessibility);\n              if (next) {\n                toFocus = next.element;\n                uncontrolled = next.uncontrolled;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {\n      toFocus = undefined;\n    }\n    return toFocus || undefined;\n  }\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n    return false;\n  }\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n    return true;\n  }\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n    if (this._tabster._noop) {\n      return;\n    }\n    const details = {\n      relatedTarget\n    };\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n      details.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n      if (modalizerId) {\n        details.modalizerId = modalizerId;\n      }\n    }\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      details\n    };\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    } // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n\n    if (this._nextVal === nextVal) {\n      this.setVal(element, details);\n    }\n    this._nextVal = undefined;\n  }\n  setVal(val, details) {\n    super.setVal(val, details);\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n  static findNextTabbable(tabster, ctx, container, currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n    if (!actualContainer) {\n      return null;\n    }\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n    const callFindNext = (what, cur) => {\n      next = what.findNextTabbable(cur || currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility);\n      const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n      if (lastMoverOrGroupper && !(next === null || next === void 0 ? void 0 : next.element) && !(next === null || next === void 0 ? void 0 : next.uncontrolled)) {\n        // Handling nested Movers and Grouppers. If not found in the current one,\n        // try the parent one.\n        const lastMoverOrGroupperElement = lastMoverOrGroupper.getElement();\n        const parentElement = lastMoverOrGroupperElement === null || lastMoverOrGroupperElement === void 0 ? void 0 : lastMoverOrGroupperElement.parentElement;\n        const parentCtx = parentElement && RootAPI.getTabsterContext(tabster, parentElement);\n        if (parentCtx) {\n          const isGroupperFirst = parentCtx.isGroupperFirst;\n          const parentMoverOrGroupper = isGroupperFirst ? parentCtx.groupper : parentCtx.mover;\n          if (parentMoverOrGroupper) {\n            const newCurrent = isBackward ? lastMoverOrGroupperElement : getLastChild(lastMoverOrGroupperElement);\n            callFindNext(parentMoverOrGroupper, newCurrent);\n            if (next) {\n              next.outOfDOMOrder = true;\n            }\n          }\n        }\n      }\n    };\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n    if (groupper && mover) {\n      callFindNext(ctx.isGroupperFirst ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      let uncontrolled;\n      const onUncontrolled = el => {\n        uncontrolled = el;\n      };\n      const nextElement = isBackward ? tabster.focusable.findPrev({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n      next = {\n        element: uncontrolled ? undefined : nextElement,\n        uncontrolled\n      };\n    }\n    const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n    const lastMoverOrGroupperElement = lastMoverOrGroupper === null || lastMoverOrGroupper === void 0 ? void 0 : lastMoverOrGroupper.getElement();\n    if (lastMoverOrGroupperElement) {\n      next = null;\n      const adjacentElement = getAdjacentElement(lastMoverOrGroupperElement, isBackward);\n      if (adjacentElement) {\n        const adjacentCtx = RootAPI.getTabsterContext(tabster, adjacentElement, {\n          checkRtl: true\n        });\n        if (adjacentCtx) {\n          let adjacentFrom = getAdjacentElement(adjacentElement, !isBackward);\n          if (adjacentFrom) {\n            if (!isBackward) {\n              adjacentFrom = getLastChild(adjacentFrom) || adjacentFrom;\n            }\n            next = FocusedElementState.findNextTabbable(tabster, adjacentCtx, actualContainer, adjacentFrom, isBackward, ignoreUncontrolled, ignoreAccessibility);\n            if (next && !next.lastMoverOrGroupper) {\n              next.lastMoverOrGroupper = lastMoverOrGroupper;\n            }\n          }\n        }\n      }\n    }\n    return next;\n  }\n}\nFocusedElementState.isTabbing = false;\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n      const container = element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, isBackward, true, true)) === null || _a === void 0 ? void 0 : _a.element;\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), isBackward, true, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n          if (next) {\n            nativeFocus(next);\n          }\n        }\n      }\n    });\n  }\n}\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const element = this._element.get();\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    if (element) {\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n    delete this._first;\n  }\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n    const groupperElement = this.getElement();\n    if (!groupperElement) {\n      return null;\n    }\n    const currentIsDummy = ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === groupperElement;\n    if (!this._shouldTabInside && currentElement && groupperElement.contains(currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        lastMoverOrGroupper: this\n      };\n    }\n    const groupperFirstFocusable = this.getFirst(true);\n    if (!currentElement || !groupperElement.contains(currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        lastMoverOrGroupper: groupperFirstFocusable ? undefined : this\n      };\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      next = isBackward ? tabster.focusable.findPrev({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n      if (!uncontrolled && !next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = isBackward ? tabster.focusable.findLast({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }) : tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n  isActive(noIfFirstIsFocused) {\n    var _a;\n    const element = this.getElement() || null;\n    let isParentActive = true;\n    for (let e = element === null || element === void 0 ? void 0 : element.parentElement; e; e = e.parentElement) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n    return ret;\n  }\n  getFirst(orContainer) {\n    var _a;\n    const groupperElement = this.getElement();\n    let first;\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        }) || undefined;\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n    return first;\n  }\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n  acceptElement(element, state) {\n    var _a;\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = (_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement;\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.isGroupperFirst) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n      return isActive;\n    };\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && state.container.contains(parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && state.container.contains(parentGroupperElement) && parentGroupperElement !== state.container) {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n        if (groupperElement !== element && groupperElement.contains(element)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        const cached = cachedGrouppers[this.id];\n        let first;\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n        if (first && state.acceptCondition(first)) {\n          state.lastToIgnore = groupperElement;\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n    this._init = () => {\n      const win = this._win(); // Making sure groupper's onFocus is called before modalizer's onFocus.\n\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n      win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element, true, true);\n      }\n    };\n    this._onMouseDown = e => {\n      if (e.target) {\n        this._updateCurrent(e.target, true);\n      }\n    };\n    this._onKeyDown = event => {\n      if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n        return;\n      } // Give a chance to other listeners to handle the event.\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      const element = this._tabster.focusedElement.getFocusedElement();\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    const win = this._win();\n    this._current = {};\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n  createGroupper(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n    const newGroupper = new Groupper(this._tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n    const focusedElement = this._tabster.focusedElement.getFocusedElement(); // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n\n    if (focusedElement && element.contains(focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer; // Making sure the focused element hasn't changed.\n\n        if (focusedElement === this._tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement, true, true);\n        }\n      }, 0);\n    }\n    return newGroupper;\n  }\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n  _updateCurrent(element, includeTarget, checkTarget) {\n    var _a;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    const newIds = {};\n    let isTarget = true;\n    for (let el = element; el; el = el.parentElement) {\n      const groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (groupper) {\n        newIds[groupper.id] = true;\n        if (isTarget && checkTarget && el !== element) {\n          isTarget = false;\n        }\n        if (includeTarget || !isTarget) {\n          this._current[groupper.id] = groupper;\n          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n          groupper.makeTabbable(isTabbable);\n        }\n        isTarget = false;\n      }\n    }\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n  handleKeyPress(element, event, noGoUp) {\n    var _a;\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const modalizerInGroupper = ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper;\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || modalizerInGroupper;\n    if (ctx && groupper) {\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n      let next;\n      const groupperElement = groupper.getElement();\n      if (event.keyCode === Keys.Enter) {\n        if (groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n          next = tabster.focusable.findNext({\n            container: groupperElement,\n            currentElement: element,\n            useActiveModalizer: true\n          });\n        }\n      } else if (event.keyCode === Keys.Esc) {\n        if (groupperElement && groupperElement.contains(element)) {\n          if (element !== groupperElement || noGoUp) {\n            next = groupper.getFirst(true);\n          } else {\n            const parentElement = groupperElement.parentElement;\n            const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n            groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n            next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n          }\n        }\n        if (groupper) {\n          groupper.makeTabbable(false);\n          if (modalizerInGroupper) {\n            (_a = tabster.modalizer) === null || _a === void 0 ? void 0 : _a.setActive(undefined);\n          }\n        }\n      }\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        next.focus();\n      }\n    }\n  }\n}\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n    this._keyborg = createKeyborg(getWindow());\n    this._keyborg.subscribe(this._onChange);\n  }\n  dispose() {\n    super.dispose();\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n      disposeKeyborg(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n  isNavigatingWithKeyboard() {\n    var _a;\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\r\n * Manages the dummy inputs for the Modalizer.\r\n */\n\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b, _c;\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n      if (container && input) {\n        const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n        if (ctx) {\n          toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, isBackward, true, true)) === null || _c === void 0 ? void 0 : _c.element;\n        }\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    });\n  }\n}\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.deref()).indexOf(element);\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakRef(element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n      this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);\n    }\n  }\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n    return this._wasFocused;\n  }\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n    this._props = {\n      ...props\n    };\n  }\n  dispose() {\n    var _a;\n    this.makeActive(false);\n    this._onDispose(this);\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._activeElements = [];\n    this._remove();\n  }\n  isActive() {\n    return !!this._isActive;\n  }\n  contains(element) {\n    var _a;\n    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));\n  }\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a, _b;\n    const modalizerElement = this.getElement();\n    if (!modalizerElement) {\n      return null;\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n    if (container) {\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n        container,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n      if (!uncontrolled && !next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n    return {\n      element: next,\n      uncontrolled\n    };\n  }\n  triggerFocusEvent(eventName, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.deref()) : [element];\n      for (const el of elements) {\n        if (el && !triggerEvent(el, eventName, {\n          id: this.userId,\n          element,\n          eventName\n        })) {\n          defaultPrevented = true;\n        }\n      }\n    }\n    return defaultPrevented;\n  }\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass ModalizerAPI {\n  constructor(tabster,\n  // @deprecated use accessibleCheck.\n  alwaysAccessibleSelector, accessibleCheck) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n      if (part) {\n        delete part[id];\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n          if (this.activeId === userId) {\n            this.setActive(undefined);\n          }\n        }\n      }\n    };\n    this._onKeyDown = event => {\n      var _a;\n      if (event.keyCode !== Keys.Esc) {\n        return;\n      }\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n          if (activeId) {\n            const part = this._parts[activeId];\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Subscribes to the focus state and handles modalizer related focus events\r\n     * @param e - Element that is focused\r\n     * @param details - Additional data about the focus event\r\n     */\n\n    this._onFocus = (focusedElement, details) => {\n      var _a, _b;\n      const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n\n      if (!ctx || !focusedElement) {\n        return;\n      }\n      const augmentedMap = this._augMap;\n      for (let e = focusedElement; e; e = e.parentElement) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(this._tabster, e, _ariaHidden);\n        }\n      }\n      const modalizer = ctx.modalizer; // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n\n      (_b = modalizer || ((_a = getTabsterOnElement(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      } // Developers calling `element.focus()` should change/deactivate active modalizer\n\n      if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n        win.clearTimeout(this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this._accessibleCheck = accessibleCheck;\n    this.activeElements = [];\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n    const win = this._win();\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    const win = this._win();\n    win.removeEventListener(\"keydown\", this._onKeyDown, true); // Dispose all modalizers managed by the API\n\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n  createModalizer(element, props, sys) {\n    var _a;\n    if (process.env.NODE_ENV === 'development') ;\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n    part[id] = modalizer; // Adding a modalizer which is already focused, activate it\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n    return modalizer;\n  }\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n      this._hiddenUpdate();\n    }, 250);\n  }\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n    if (activeId === userId) {\n      return;\n    }\n    this.activeId = userId;\n    if (activeId) {\n      const part = this._parts[activeId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n    if (userId) {\n      const part = this._parts[userId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n  }\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n        this._tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n    return false;\n  }\n  acceptElement(element, state) {\n    var _a;\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.deref();\n        if (el && (element.contains(el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n    return modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n  }\n  _hiddenUpdate() {\n    var _a;\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];\n    const activeModalizerElements = [];\n    for (const userId of Object.keys(parts)) {\n      const modalizerParts = parts[userId];\n      for (const id of Object.keys(modalizerParts)) {\n        const modalizer = modalizerParts[id];\n        const el = modalizer.getElement();\n        const props = modalizer.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n        if (el) {\n          if (userId === activeId) {\n            activeModalizerElements.push(el);\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n    const toggle = (element, hide) => {\n      var _a;\n      const tagName = element.tagName;\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n      let isAugmented = false;\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && !((_a = this._accessibleCheck) === null || _a === void 0 ? void 0 : _a.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n      if (isAugmented) {\n        newAugmented.push(new WeakRef(element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n    const walk = element => {\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        let skip = false;\n        let containsModalizer = false;\n        if (allVisibleElements) {\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n            if (el.contains(c)) {\n              containsModalizer = true;\n              break;\n            }\n          }\n          if (containsModalizer) {\n            walk(el);\n          } else if (!skip) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n    hiddenElements.forEach(e => toggle(e, true));\n    if (body) {\n      walk(body);\n    }\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.deref()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\r\n   * Called when an element is focused outside of an active modalizer.\r\n   * Attempts to pull focus back into the active modalizer\r\n   * @param outsideElement - An element being focused outside of the modalizer\r\n   */\n\n  _restoreModalizerFocus(outsideElement) {\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n    const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n    if (container) {\n      let toFocus = this._tabster.focusable.findFirst({\n        container,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = this._tabster.focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n        this._tabster.focusedElement.focus(toFocus);\n        return;\n      }\n    } // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n\n    outsideElement.blur();\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n      const container = this._element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n        if (memorized) {\n          toFocus = memorized;\n        }\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n    this._setHandlers(this._onFocusDummyInput);\n  }\n} // TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\n\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n    super(tabster, element, props);\n    this._visible = {};\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n          const state = this.getState(el);\n          if (state) {\n            triggerEvent(el, MoverEventName, state);\n          }\n        }\n      }\n    };\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n      this._observeState();\n    }\n    this._onDispose = onDispose;\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n      delete this._intersectionObserver;\n    }\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n    if (this._unobserve) {\n      this._unobserve();\n      delete this._unobserve;\n    }\n    const win = this._win();\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n        delete this._setCurrentTimer;\n        const changed = [];\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n              if (state) {\n                triggerEvent(el, MoverEventName, state);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n  getCurrent() {\n    var _a;\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n    const container = this.getElement();\n    const currentIsDummy = container && ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === container;\n    if (!container) {\n      return null;\n    }\n    const tabster = this._tabster;\n    const focusable = tabster.focusable;\n    let next = null;\n    let uncontrolled;\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n    if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {\n      next = isBackward ? focusable.findPrev({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : focusable.findNext({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n    }\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n  acceptElement(element, state) {\n    var _a, _b, _c;\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.isExcludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {\n      let found;\n      if (memorizeCurrent) {\n        const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        });\n      }\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.lastToIgnore = moverElement;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n    return undefined;\n  }\n  _observeState() {\n    const element = this.getElement();\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n    const win = this._win();\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = new MutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n      requestUpdate();\n    });\n    const setElement = (element, remove) => {\n      var _a, _b;\n      const current = allElements.get(element);\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n        return NodeFilter.FILTER_SKIP;\n      });\n      if (walker) {\n        walker.currentNode = element;\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n    const removeWalk = element => {\n      const current = allElements.get(element);\n      if (current) {\n        setElement(element, true);\n      }\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        removeWalk(el);\n      }\n    };\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n    const getMoverGroupper = element => {\n      const ret = {};\n      for (let el = element; el; el = el.parentElement) {\n        const toe = getTabsterOnElement(this._tabster, el);\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n      return ret;\n    };\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n  getState(element) {\n    const id = getElementUId(this._win, element);\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n    return undefined;\n  }\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\r\n * Calculates distance between two rectangles.\r\n *\r\n * @param ax1 first rectangle left\r\n * @param ay1 first rectangle top\r\n * @param ax2 first rectangle right\r\n * @param ay2 first rectangle bottom\r\n * @param bx1 second rectangle left\r\n * @param by1 second rectangle top\r\n * @param bx2 second rectangle right\r\n * @param by2 second rectangle bottom\r\n * @returns number, shortest distance between the rectangles.\r\n */\n\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n    this._onFocus = e => {\n      var _a;\n      for (let el = e; el; el = el.parentElement) {\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n        if (mover) {\n          mover.setCurrent(e);\n          break;\n        }\n      }\n    };\n    this._onKeyDown = async event => {\n      var _a, _b, _c, _d;\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n        delete this._ignoredInputTimer;\n      }\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      let keyCode = event.keyCode; // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      switch (keyCode) {\n        case Keys.Down:\n        case Keys.Right:\n        case Keys.Up:\n        case Keys.Left:\n        case Keys.PageDown:\n        case Keys.PageUp:\n        case Keys.Home:\n        case Keys.End:\n          break;\n        default:\n          return;\n      }\n      const tabster = this._tabster;\n      const focused = tabster.focusedElement.getFocusedElement();\n      if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n        return;\n      }\n      const ctx = RootAPI.getTabsterContext(tabster, focused, {\n        checkRtl: true\n      });\n      if (!ctx || !ctx.mover || ctx.isExcludedFromMover || ctx.ignoreKeydown(event)) {\n        return;\n      }\n      const mover = ctx.mover;\n      const container = mover.getElement();\n      if (ctx.isGroupperFirst) {\n        const groupper = ctx.groupper;\n        if (groupper && !groupper.isActive(true)) {\n          // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n          // the grouppers between the current element and the current mover.\n          for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {\n            if ((_d = (_c = getTabsterOnElement(tabster, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {\n              return;\n            }\n          }\n        } else {\n          return;\n        }\n      }\n      if (!container) {\n        return;\n      }\n      const focusable = tabster.focusable;\n      const moverProps = mover.getProps();\n      const direction = moverProps.direction || MoverDirections.Both;\n      const isBoth = direction === MoverDirections.Both;\n      const isVertical = isBoth || direction === MoverDirections.Vertical;\n      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n      const isGridLinear = direction === MoverDirections.GridLinear;\n      const isGrid = isGridLinear || direction === MoverDirections.Grid;\n      const isCyclic = moverProps.cyclic;\n      let next;\n      let focusedElementRect;\n      let focusedElementX1 = 0;\n      let focusedElementX2 = 0;\n      if (isGrid) {\n        focusedElementRect = focused.getBoundingClientRect();\n        focusedElementX1 = Math.ceil(focusedElementRect.left);\n        focusedElementX2 = Math.floor(focusedElementRect.right);\n      }\n      if (ctx.isRtl) {\n        if (keyCode === Keys.Right) {\n          keyCode = Keys.Left;\n        } else if (keyCode === Keys.Left) {\n          keyCode = Keys.Right;\n        }\n      }\n      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {\n        next = focusable.findNext({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n        if (next && isGrid) {\n          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n          if (!isGridLinear && focusedElementX2 > nextElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {\n        next = focusable.findPrev({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n        if (next && isGrid) {\n          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n          if (!isGridLinear && nextElementX2 > focusedElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Home) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              var _a;\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n              if (el !== focused && focusedElementX1 <= nextElementX1) {\n                return true;\n              }\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.End) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              var _a;\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n              if (el !== focused && focusedElementX1 >= nextElementX1) {\n                return true;\n              }\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.PageUp) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n            return true;\n          }\n        }); // will be on the first column move forward and preserve previous column\n\n        if (isGrid && next) {\n          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n                return true;\n              }\n              next = el;\n              return false;\n            }\n          });\n        }\n        if (next) {\n          scrollIntoView(this._win, next, false);\n        }\n      } else if (keyCode === Keys.PageDown) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n            return true;\n          }\n        }); // will be on the last column move backwards and preserve previous column\n\n        if (isGrid && next) {\n          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n                return true;\n              }\n              next = el;\n              return false;\n            }\n          });\n        }\n        if (next) {\n          scrollIntoView(this._win, next, true);\n        }\n      } else if (isGrid) {\n        const isBackward = keyCode === Keys.Up;\n        const ax1 = focusedElementX1; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay1 = Math.ceil(focusedElementRect.top);\n        const ax2 = focusedElementX2; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay2 = Math.floor(focusedElementRect.bottom);\n        let targetElement;\n        let lastDistance;\n        let lastIntersection = 0;\n        focusable.findAll({\n          container,\n          currentElement: focused,\n          isBackward,\n          onElement: el => {\n            // Find element which has maximal intersection with the focused element horizontally,\n            // or the closest one.\n            const rect = el.getBoundingClientRect();\n            const bx1 = Math.ceil(rect.left);\n            const by1 = Math.ceil(rect.top);\n            const bx2 = Math.floor(rect.right);\n            const by2 = Math.floor(rect.bottom);\n            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n              // Only consider elements which are below/above curretly focused.\n              return true;\n            }\n            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n              // Element intersects with the focused element on X axis.\n              const intersection = xIntersectionWidth / minWidth;\n              if (intersection > lastIntersection) {\n                targetElement = el;\n                lastIntersection = intersection;\n              }\n            } else if (lastIntersection === 0) {\n              // If we didn't have intersection, try just the closest one.\n              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n              if (lastDistance === undefined || distance < lastDistance) {\n                lastDistance = distance;\n                targetElement = el;\n              }\n            } else if (lastIntersection > 0) {\n              // Element doesn't intersect, but we had intersection already, stop search.\n              return false;\n            }\n            return true;\n          }\n        });\n        next = targetElement;\n      }\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        nativeFocus(next);\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    var _a;\n    const win = this._win();\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n        delete this._movers[moverId];\n      }\n    });\n  }\n  createMover(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n  async _isIgnoredInput(element, keyCode) {\n    var _a;\n    if (element.getAttribute(\"aria-expanded\") === \"true\") {\n      return true;\n    }\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = (_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n          const win = this._win();\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = win.getSelection() || {}; // Get selection gives incorrect value if we call it syncronously onKeyDown.\n\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = win.getSelection() || {};\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n            if (anchorNode && focusNode) {\n              if (element.contains(anchorNode) && element.contains(focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n                    const nodeText = node.textContent;\n                    if (nodeText && !node.firstChild) {\n                      const len = nodeText.length;\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n                    let stop = false;\n                    for (let e = node.firstChild; e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n                    return stop;\n                  };\n                  addOffsets(element);\n                }\n              }\n            }\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n      if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {\n        return true;\n      }\n      if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TabsterAttributeName) {\n          updateTabsterByAttribute(tabster, target);\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          updateTabsterElements(removed[i], true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n  function processNode(element, removed) {\n    var _a;\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n    const uid = element.__tabsterElementUID;\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n    return NodeFilter.FILTER_SKIP;\n  }\n  const observer = new MutationObserver(onMutation);\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TabsterAttributeName]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n          const settleTime = 300;\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n    this.onObservedElementUpdate = element => {\n      var _a;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n          info.prevNames = observedNames;\n        }\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          obn[uid] = info;\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n        delete this._observedById[uid];\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n    this._observedById = {};\n    this._observedByName = {};\n  }\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n    if (w) {\n      const win = this._win();\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n      delete this._waiting[key];\n    }\n  }\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\r\n   * Returns existing element by observed name\r\n   *\r\n   * @param observedName An observed name\r\n   * @param accessibility Optionally, return only if the element is accessible or focusable\r\n   * @returns HTMLElement | null\r\n   */\n\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n        if (el) {\n          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n        return el;\n      }\n    }\n    return null;\n  }\n  /**\r\n   * Waits for the element to appear in the DOM and returns it.\r\n   *\r\n   * @param observedName An observed name\r\n   * @param timeout Wait no longer than this timeout\r\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\r\n   * @returns Promise<HTMLElement | null>\r\n   */\n\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        }\n      };\n    }\n    let prefix;\n    if (accessibility === ObservedElementAccesibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccesibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n    if (w && w.request) {\n      return w.request;\n    }\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n        delete this._waiting[key];\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    });\n    w.request = {\n      result: promise,\n      cancel: () => {\n        this._rejectWaiting(key, true);\n      }\n    };\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n    return w.request;\n  }\n  requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n    const request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n    });\n    return {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true) : false),\n      cancel: () => {\n        request.cancel();\n      }\n    };\n  }\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n    const win = this._win();\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n      delete this._waiting[key];\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);\n      }\n    }\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n      resolveAccessible();\n    }\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n      resolveFocusable();\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n}\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const win = this._win();\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n      const target = e.target.body || e.target;\n      const outlineElements = this._getDOM(target);\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n      this._curPos = undefined;\n      this._setOutlinePosition();\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n  setup(props) {\n    _props = {\n      ..._props,\n      ...props\n    };\n    const win = this._win();\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._curPos = undefined;\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n        this._updateOutline();\n      }\n      return true;\n    }\n    return false;\n  }\n  _updateOutline() {\n    this._setOutlinePosition();\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    if (!this._outlinedElement) {\n      return;\n    }\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n      this._updateOutline();\n    }, 30);\n  }\n  _setVisibility(visible) {\n    this._isVisible = visible;\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n        this._curPos = undefined;\n      }\n    }\n  }\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n    const outlineElements = this._getDOM(this._outlinedElement);\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n    if (!outlineElements || !win) {\n      return;\n    }\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n      this._curOutlineElements = outlineElements;\n    }\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n    if (!scrollingElement) {\n      return;\n    }\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n      if (!win) {\n        return;\n      }\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n\n      this._allOutlineElements.push(outlineElements);\n    }\n    return win.__tabsterOutline.elements;\n  }\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n    if (!outline) {\n      return;\n    }\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n    const outlineElements = outline && outline.elements;\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n      delete outline.elements;\n    }\n  }\n  static _isParentChild(parent, child) {\n    return child === parent ||\n    // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n}\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Allows default or user focus behaviour on the DOM subtree\r\n * i.e. Tabster will not control focus events within an uncontrolled area\r\n */\nclass UncontrolledAPI {\n  constructor() {\n    /**/\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst EVENT_NAME = \"restorer:restorefocus\";\nconst HISOTRY_DEPTH = 10;\nclass Restorer extends TabsterPart {\n  constructor(tabster, element, props) {\n    var _a;\n    super(tabster, element, props);\n    this._onFocusOut = e => {\n      var _a;\n      if (e.relatedTarget === null) {\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        element === null || element === void 0 ? void 0 : element.dispatchEvent(new Event(EVENT_NAME, {\n          bubbles: true\n        }));\n      }\n    };\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusout\", this._onFocusOut);\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusout\", this._onFocusOut);\n    }\n  }\n}\nclass RestorerAPI {\n  constructor(tabster) {\n    this._history = [];\n    this._restoreFocusTimeout = 0;\n    this._onRestoreFocus = e => {\n      const win = this._getWindow();\n      if (this._restoreFocusTimeout) {\n        win.clearTimeout(this._restoreFocusTimeout);\n      }\n      this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e.target));\n    };\n    this._onFocusIn = element => {\n      var _a, _b;\n      if (!element) {\n        return;\n      }\n      const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {\n        return;\n      } // Don't duplicate the top of history\n\n      if (((_b = this._history[this._history.length - 1]) === null || _b === void 0 ? void 0 : _b.deref()) === element) {\n        return;\n      }\n      if (this._history.length > HISOTRY_DEPTH) {\n        this._history.shift();\n      }\n      this._history.push(new WeakRef(element));\n    };\n    this._restoreFocus = source => {\n      var _a, _b, _c; // don't restore focus if focus isn't lost to body\n\n      const doc = this._getWindow().document;\n      if (doc.activeElement !== document.body) {\n        return;\n      }\n      if (\n      // clicking on any empty space focuses body - this is can be a false positive\n      !this._keyboardNavState.isNavigatingWithKeyboard() &&\n      // Source no longer exists on DOM - always restore focus\n      doc.body.contains(source)) {\n        return;\n      }\n      let weakRef = this._history.pop();\n      while (weakRef && !doc.body.contains((_b = (_a = weakRef.deref()) === null || _a === void 0 ? void 0 : _a.parentElement) !== null && _b !== void 0 ? _b : null)) {\n        weakRef = this._history.pop();\n      }\n      (_c = weakRef === null || weakRef === void 0 ? void 0 : weakRef.deref()) === null || _c === void 0 ? void 0 : _c.focus();\n    };\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);\n    this._keyboardNavState = tabster.keyboardNavigation;\n    this._focusedElementState = tabster.focusedElement;\n    this._focusedElementState.subscribe(this._onFocusIn);\n  }\n  dispose() {\n    const win = this._getWindow();\n    this._focusedElementState.unsubscribe(this._onFocusIn);\n    win.removeEventListener(EVENT_NAME, this._onRestoreFocus);\n    if (this._restoreFocusTimeout) {\n      win.clearTimeout(this._restoreFocusTimeout);\n    }\n  }\n  createRestorer(element, props) {\n    return new Restorer(this._tabster, element, props);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n}\n/**\r\n * Extends Window to include an internal Tabster instance.\r\n */\n\nclass TabsterCore {\n  constructor(win, props) {\n    var _a;\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"4.7.0\";\n    this._noop = false;\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n      return this._win;\n    };\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI();\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow); // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n  createTabster(noRefCount) {\n    const wrapper = new Tabster(this);\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n    return wrapper;\n  }\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n    this._dummyObserver.dispose();\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n    this._wrappers.clear();\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n    return entry;\n  }\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n    this._forgetMemorizedElements.push(this._win.document.body);\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n  queueInit(callback) {\n    var _a;\n    if (!this._win) {\n      return;\n    }\n    this._initQueue.push(callback);\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n    const queue = this._initQueue; // Resetting the queue before calling the callbacks to avoid recursion.\n\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n}\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\r\n * Creates an instance of Tabster, returns the current window instance if it already exists.\r\n */\n\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n  if (tabster) {\n    return tabster.createTabster();\n  }\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\r\n * Returns an instance of Tabster if it was created before or null.\r\n */\n\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\n/**\r\n * Creates a new groupper instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.groupper;\n}\n/**\r\n * Creates a new mover instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n  return tabsterCore.outline;\n}\n/**\r\n * Creates a new new deloser instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param props Deloser props\r\n */\n\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n  return tabsterCore.deloser;\n}\n/**\r\n * Creates a new modalizer instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param alwaysAccessibleSelector When Modalizer is active, we put\r\n * aria-hidden to everything else to hide it from screen readers. This CSS\r\n * selector allows to exclude some elements from this behaviour. For example,\r\n * this could be used to exclude aria-live region with the application-wide\r\n * status announcements.\r\n * @param accessibleCheck An optional callback that will be called when\r\n * active Modalizer wants to hide an element that doesn't belong to it from\r\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\r\n * but allows to address the elements programmatically rather than with a selector.\r\n * If the callback returns true, the element will not receive aria-hidden.\r\n */\n\nfunction getModalizer(tabster,\n// @deprecated use accessibleCheck.\nalwaysAccessibleSelector, accessibleCheck) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);\n  }\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction getRestorer(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.restorer) {\n    tabsterCore.restorer = new RestorerAPI(tabsterCore);\n  }\n  return tabsterCore.restorer;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\r\n * Returns an instance of Tabster if it already exists on the window .\r\n * @param win window instance that could contain an Tabster instance.\r\n */\n\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\r\n * Allows to make Tabster non operational. Intended for performance debugging (and other\r\n * kinds of debugging), you can switch Tabster off without changing the application code\r\n * that consumes it.\r\n * @param tabster a reference created by createTabster().\r\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\r\n */\n\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n  if (core._noop !== noop) {\n    core._noop = noop;\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TabsterAttributeName)) {\n        updateTabsterByAttribute(core, element);\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\nexport { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getRestorer, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };","map":{"version":3,"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","Source","Target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","getTabsterOnElement","tabster","element","_a","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","process","env","NODE_ENV","console","error","tabsterOnElement","oldTabsterProps","_b","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","createEventTarget","getWindow","global","EventTarget","TypeError","document","createElement","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","left","top","right","bottom","_uidCounter","createTreeWalker","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","_focusIn","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","_focusOut","useDefaultAction","onFocusOut","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","dummy","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","nativeFocus","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","_updateQueue","Set","_lastUpdateQueueTime","_changedParents","WeakSet","_dummies","Map","_domChanged","has","add","_updateDummyInputsTimer","_win","callback","dummyParent","set","domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","_wrappers","_isOutside","_transformElements","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","wrapper","_getCurrent","_addDummyInputs","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","dummyElement","force","_c","_d","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","augmentAttribute","value","aug","origVal","removeAttribute","origValue","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle$3","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_onDummyInputFocus","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","onDispose","_isFocused","hasFocused","fromAdjacent","_setFocusedTimer","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootWaiting","_roots","_forceDummy","rootById","_autoRootCreate","_autoRootUnwait","_autoRoot","_onRootDispose","queueInit","forEach","rootId","newRoot","roots","getRootByUId","__tabsterInstance","options","drainInitQueue","checkRtl","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","_history","getLength","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","resetQueue","DeloserHistory","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","_setInformativeStyle$2","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","elementId","replace","className","split","cls","trim","index","buildSelector","isBody","Deloser","_isActive","_snapshotIndex","setSnapshot","focusFirst","focusDefault","clearHistory","preserveExisting","we","setActive","active","getActions","pop","isVisible","restoreFocusOrder","rootElement","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","slice","noSelectorCheck","els","querySelectorAll","isNavigatingWithKeyboard","findFirst","ignoreUncontrolled","useActiveModalizer","_inDeloser","_isRestoringFocus","_isPaused","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","_onDeloserDispose","activeElement","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","getFocusedElement","pause","resume","restore","curDeloser","restoreFocus","lastFocused","getLastFocusedElement","offsetParent","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","_inProgress","_isDone","_isSelfResponding","_sentCount","owner","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","type","isResponse","timestamp","sentto","endData","end","_send","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","getElementById","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","result","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_isDefaultSendUp","isSetUp","_onMessage","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_onPageHide","_dead","_onBrowserMessage","source","postMessage","setup","setSendUp","_ping","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","focusByObservedName","elementData","_lastRequestFocusId","requestFocus","requestId","CrossOriginAPI","_init","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","deloserElement","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","defaultView","computedStyle","visibility","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","fromMover","_e","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Enter","Esc","Space","PageUp","PageDown","End","Home","Left","Up","Right","Down","FocusedElementState","KEYBORG_FOCUSIN","_onKeyDown","_setFocusedElement","_onChanged","_validateFocusedElement","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_f","_lastVal","lastCtx","_lastResetElement","_nextVal","forgetMemorized","tabsterFocusable","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","GroupperDummyManager","_shouldTabInside","makeTabbable","_setInformativeStyle$1","_first","currentIsDummy","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_current","_grouppers","_onMouseDown","_onGroupperDispose","_updateCurrent","altKey","metaKey","handleKeyPress","groupperId","newGroupper","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","noGoUp","KeyboardNavigationState","_onChange","_keyborg","createKeyborg","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_wasFocused","_activeElements","makeActive","noIncrement","modalizerElement","isTrapped","eventName","allElements","ModalizerAPI","alwaysAccessibleSelector","accessibleCheck","_onModalizerDispose","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_alwaysAccessibleSelector","_accessibleCheck","_hiddenUpdateTimer","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","Array","activeModalizerElements","modalizerParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","outsideElement","_inputSelector","MoverDummyManager","getMemorized","_onFocusDummyInput","memorized","_getMemorized","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","_visible","_onIntersection","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","MutationObserver","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_onMoverDispose","_movers","_ignoredInputTimer","_ignoredInputResolve","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","selectionStart","selectionEnd","textLength","asyncRet","selection","getSelection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","observeMutations","syncState","onMutation","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_waiting","_observedById","_observedByName","_currentRequestTimestamp","_currentRequest","delta","settleTime","cancel","info","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_waitConditional","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_isVisible","_allOutlineElements","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","parentNode","child","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","EVENT_NAME","HISOTRY_DEPTH","Restorer","Event","bubbles","RestorerAPI","_restoreFocusTimeout","_onRestoreFocus","_restoreFocus","tabsterAttribute","shift","_keyboardNavState","weakRef","_focusedElementState","Tabster","core","TabsterCore","_forgetMemorizedElements","_initQueue","_version","_storage","internal","stopObserver","resumeObserver","createTabster","noRefCount","disposeTabster","allInstances","_initTimer","_forgetMemorizedTimer","_g","_h","addremove","storage","forceCleanup","queue","tabsterCore","getCurrentTabster","getTabster","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","getRestorer","makeNoOp","noop","isNoOp"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Types.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Instance.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/EventTarget.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Utils.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/AttributeHelpers.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Root.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Deloser.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/State/Subscribable.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/CrossOrigin.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Focusable.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Keys.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/State/FocusedElement.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Groupper.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/State/KeyboardNavigation.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Modalizer.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Mover.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/MutationEvent.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/State/ObservedElement.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Outline.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Uncontrolled.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Restorer.ts","/Users/suketupatel/Desktop/application/frontend/node_modules/tabster/src/Tabster.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nexport const DeloserEventName = \"tabster:deloser\";\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nexport const ModalizerBeforeFocusOutEventName =\n    \"tabster:modalizer:beforefocusout\";\nexport const MoverEventName = \"tabster:mover\";\nexport const FocusInEventName = \"tabster:focusin\";\nexport const FocusOutEventName = \"tabster:focusout\";\n\nexport interface TabsterEventWithDetails<D> extends Event {\n    details: D;\n}\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    details: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetails>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n    Any: 0;\n    Accessible: 1;\n    Focusable: 2;\n}\nexport type ObservedElementAccesibility =\n    ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n    History: 0;\n    DeloserDefault: 1;\n    RootDefault: 2;\n    DeloserFirst: 3;\n    RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n};\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    lastToIgnore?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    nextUncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreUncontrolled?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore uncontrolled areas.\n     */\n    ignoreUncontrolled?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called if an uncontrolled area is met.\n     * @param el uncontrolled element.\n     */\n    onUncontrolled?(el: HTMLElement): void;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onUncontrolled\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (backwards: boolean) => void;\n}\n\nexport interface Visibilities {\n    Invisible: 0;\n    PartiallyVisible: 1;\n    Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\n\nexport const RestorerTypes = {\n    Source: 0,\n    Target: 1,\n} as const;\n\nexport type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];\n\nexport const MoverDirections: MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement;\n    lastMoverOrGroupper?: Mover | Groupper;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {}\n\nexport interface GroupperTabbabilities {\n    Unlimited: 0;\n    Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1,\n    LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability =\n    GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n    | typeof ModalizerActiveEventName\n    | typeof ModalizerInactiveEventName\n    | typeof ModalizerBeforeFocusOutEventName\n    | typeof ModalizerFocusInEventName\n    | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n    id: string;\n    element: HTMLElement;\n    eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n    triggerFocusEvent(\n        eventName: ModalizerEventName,\n        allElements: boolean\n    ): boolean;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(backwards: boolean): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport interface SysDummyInputsPositions {\n    Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1; // Tabster will always place dummy inputs inside the container.\n    Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n    Auto: 0,\n    Inside: 1,\n    Outside: 2,\n};\nexport type SysDummyInputsPosition =\n    SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    isGroupperFirst?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    isRtl?: boolean;\n    /**\n     * The uncontrolled container of this element (if any).\n     */\n    uncontrolled?: HTMLElement;\n    isExcludedFromMover?: boolean;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n    element: HTMLElement;\n    fromAdjacent?: boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n    eventTarget: EventTarget;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UncontrolledAPI {}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakRef<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\ninterface RestorerAPIInternal {\n    /** @internal */\n    createRestorer(element: HTMLElement, props: RestorerProps): Restorer;\n}\n\nexport interface RestorerAPI extends RestorerAPIInternal, Disposable {}\n\nexport interface Restorer extends Disposable, TabsterPart<RestorerProps> {}\n/**\n * A signature for the accessibleCheck callback from getModalizer().\n * It is called when active Modalizer sets aria-hidden on elements outsidef of it.\n *\n * @param element The element that is about to receive aria-hidden.\n * @param activeModalizerElements The container elements of the active modalizer.\n * @returns true if the element should remain accessible and should not receive\n * aria-hidden.\n */\nexport type ModalizerElementAccessibleCheck = (\n    element: HTMLElement,\n    activeModalizerElements?: HTMLElement[]\n) => boolean;\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface RestorerOnElement {\n    restorer: Restorer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: Record<string, never>;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport interface RestorerProps {\n    type: RestorerType;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledOnElement[\"uncontrolled\"];\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n    restorer: RestorerProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement &\n        RestorerOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n    /** @internal */\n    restorer?: RestorerAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"restorer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"restorer\":\n                if (tabsterOnElement.restorer) {\n                    tabsterOnElement.restorer.setProps(\n                        newTabsterProps.restorer as Types.RestorerProps\n                    );\n                } else {\n                    if (tabster.restorer) {\n                        if (newTabsterProps.restorer) {\n                            tabsterOnElement.restorer =\n                                tabster.restorer.createRestorer(\n                                    element,\n                                    newTabsterProps.restorer\n                                );\n                        }\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Restorer API used before initialization, please call `getRestorer()`\"\n                        );\n                    }\n                }\n\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { GetWindow } from \"./Types\";\n\nexport function createEventTarget(getWindow: GetWindow): EventTarget {\n    const global = getWindow() as unknown as typeof globalThis;\n\n    try {\n        if (global.EventTarget) {\n            return new global.EventTarget();\n        }\n    } catch (error) {\n        // thrown if EventTarget is not constructable or doesn't exit\n        if (!(error instanceof TypeError)) {\n            throw error;\n        }\n    }\n\n    return global.document.createElement(\"div\");\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = element.parentElement;\n            el;\n            el = el.parentElement\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!parent.contains(el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return !!doc?.body?.contains(element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        input.parentElement?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget =\n                DummyInputManager.getLastPhantomFrom() ||\n                (e.relatedTarget as HTMLElement | null);\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n    private static _lastPhantomFrom: HTMLElement | undefined;\n\n    moveOut: DummyInputManagerCore[\"moveOut\"];\n    moveOutWithDefaultAction: DummyInputManagerCore[\"moveOutWithDefaultAction\"];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n\n        this.moveOut = (backwards: boolean) => {\n            this._instance?.moveOut(backwards);\n        };\n\n        this.moveOutWithDefaultAction = (backwards: boolean) => {\n            this._instance?.moveOutWithDefaultAction(backwards);\n        };\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static getLastPhantomFrom(): HTMLElement | undefined {\n        const ret = DummyInputManager._lastPhantomFrom;\n        delete DummyInputManager._lastPhantomFrom;\n        return ret;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        moveOutside: boolean,\n        isBackward: boolean\n    ): void {\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            const parent = element.parentElement;\n\n            if (parent) {\n                let insertBefore = (\n                    (moveOutside && !isBackward) || (!moveOutside && isBackward)\n                        ? element.nextElementSibling\n                        : element\n                ) as HTMLElementWithDummyContainer | null;\n\n                if (insertBefore) {\n                    if (isBackward) {\n                        const beforeBefore =\n                            insertBefore.previousElementSibling as HTMLElementWithDummyContainer | null;\n\n                        if (\n                            beforeBefore &&\n                            beforeBefore.__tabsterDummyContainer\n                        ) {\n                            insertBefore = beforeBefore;\n                        }\n                    } else if (insertBefore.__tabsterDummyContainer) {\n                        insertBefore =\n                            insertBefore.nextElementSibling as HTMLElementWithDummyContainer | null;\n                    }\n                }\n\n                parent.insertBefore(input, insertBefore);\n\n                DummyInputManager._lastPhantomFrom = element;\n\n                tabster.getWindow().setTimeout(() => {\n                    delete DummyInputManager._lastPhantomFrom;\n                }, 0);\n\n                nativeFocus(input);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<HTMLElement> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummies: Map<HTMLElement, () => void> = new Map();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        this._dummies.set(dummy, callback);\n        this.domChanged = this._domChanged;\n    }\n\n    remove(dummy: HTMLElement): void {\n        const dummyInputElements = this._dummies;\n        dummyInputElements.delete(dummy);\n\n        if (dummyInputElements.size === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummies.clear();\n\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const [dummy, callback] of this._dummies) {\n                const dummyParent = dummy.parentElement;\n\n                if (!dummyParent || this._changedParents.has(dummyParent)) {\n                    callback();\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = element.parentElement;\n\n            if (elementParent) {\n                const nextSibling = element.nextElementSibling;\n\n                if (nextSibling !== lastDummyInput) {\n                    elementParent.insertBefore(lastDummyInput, nextSibling);\n                }\n\n                if (element.previousElementSibling !== firstDummyInput) {\n                    elementParent.insertBefore(firstDummyInput, element);\n                }\n            }\n        } else {\n            if (element.lastElementChild !== lastDummyInput) {\n                element.appendChild(lastDummyInput);\n            }\n\n            const firstElementChild = element.firstElementChild;\n\n            if (firstElementChild && firstElementChild !== firstDummyInput) {\n                element.insertBefore(firstDummyInput, firstElementChild);\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = element.parentElement\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev ? cur.previousElementSibling : cur.nextElementSibling\n        ) as HTMLElement | null;\n        cur = cur.parentElement;\n    }\n\n    return adjacent || undefined;\n}\n\nexport function triggerEvent<D>(\n    target: HTMLElement | EventTarget,\n    name: string,\n    details: D\n): boolean {\n    const event = document.createEvent(\n        \"HTMLEvents\"\n    ) as Types.TabsterEventWithDetails<D>;\n\n    event.initEvent(name, true, true);\n\n    event.details = details;\n\n    target.dispatchEvent(event);\n\n    return !event.defaultPrevented;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n\nexport function getTabsterAttributeOnElement(\n    element: HTMLElement\n): Types.TabsterAttributeProps | null {\n    if (!element.hasAttribute(Types.TabsterAttributeName)) {\n        return null;\n    }\n\n    // We already checked the presence with `hasAttribute`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const rawAttribute = element.getAttribute(Types.TabsterAttributeName)!;\n    let tabsterAttribute: Types.TabsterAttributeProps;\n    try {\n        tabsterAttribute = JSON.parse(rawAttribute);\n    } catch {\n        console.error(\"Tabster: failed to parse attribute\", rawAttribute);\n        tabsterAttribute = {};\n    }\n\n    return tabsterAttribute;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { createEventTarget } from \"./EventTarget\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean, fromAdjacent?: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean, fromAdjacent?: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false, true);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true, true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _setTabbableTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        tabster.focusedElement.subscribe(this._onFocus);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward\n                );\n            }\n        }\n    }\n\n    private _setFocused = (\n        hasFocused: boolean,\n        fromAdjacent?: boolean\n    ): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                triggerEvent<Types.RootFocusEventDetails>(\n                    this._tabster.root.eventTarget,\n                    \"focus\",\n                    { element, fromAdjacent }\n                );\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n                        this._isFocused = false;\n                        triggerEvent<Types.RootFocusEventDetails>(\n                            this._tabster.root.eventTarget,\n                            \"blur\",\n                            { element, fromAdjacent }\n                        );\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined) => {\n        const win = this._tabster.getWindow();\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        if (e) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n            if (ctx) {\n                this._setFocused(ctx.root.getElement() === this._element.get());\n            }\n\n            if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n                this._dummyManager?.setTabbable(false);\n                return;\n            }\n        } else {\n            this._setFocused(false);\n        }\n\n        this._setTabbableTimer = win.setTimeout(() => {\n            delete this._setTabbableTimer;\n            this._dummyManager?.setTabbable(true);\n        }, 0);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n    eventTarget: EventTarget;\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n        this.eventTarget = createEventTarget(this._win);\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        const checkRtl = options.checkRtl;\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let isExcludedFromMover = false;\n        let isGroupperFirst: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let isRtl: boolean | undefined;\n        let uncontrolled: HTMLElement | undefined;\n        let curElement: Node | null = element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && isRtl === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    isRtl = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = curElement.parentElement;\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                isExcludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                isGroupperFirst = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = curElement.parentElement;\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            isGroupperFirst = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[event.key as \"Tab\"];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  isGroupperFirst,\n                  modalizerInGroupper,\n                  isRtl: checkRtl ? !!isRtl : undefined,\n                  uncontrolled,\n                  isExcludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const available = this._deloser.findAvailable();\n        return available\n            ? this._tabster.focusedElement.focus(available)\n            : false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await i.focusAvailable())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.focusAvailable(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    const elementId = element.getAttribute(\"id\");\n\n    if (elementId) {\n        selector.push(\n            \"#\" + elementId.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let el = element.parentElement;\n\n    while (el) {\n        const isBody = el.tagName === \"BODY\";\n        selector.unshift(buildElementSelector(el, false, !isBody));\n\n        if (isBody) {\n            break;\n        }\n\n        el = el.parentElement;\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? element.contains(e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return triggerEvent(element, Types.DeloserEventName, this.getActions());\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && element.contains(e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: NodeListOf<Element>;\n\n                    try {\n                        els = element.ownerDocument.querySelectorAll(selector);\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            const activeElement = doc.activeElement;\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    !!lastFocused?.offsetParent)\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                const el = curDeloser.findAvailable();\n\n                if (el && this._tabster.focusedElement.focus(el)) {\n                    return;\n                }\n            }\n\n            this._deactivate();\n\n            this._isRestoringFocus = true;\n\n            if (!(await this._history.focusAvailable(null))) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, details: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, details);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, details: B): void {\n        this._callCallbacks(val, details);\n    }\n\n    private _callCallbacks(val: A, details: B): void {\n        this._callbacks.forEach((callback) => callback(val, details));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = getOwner().document.getElementById(data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetails\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, details);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n} from \"./Utils\";\n\nconst _focusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n].join(\", \");\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, _focusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (el.offsetParent === null && el.ownerDocument.body !== el) {\n            return false;\n        }\n\n        const win = el.ownerDocument.defaultView;\n\n        if (!win) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        const computedStyle = win.getComputedStyle(el);\n\n        if (computedStyle.visibility === \"hidden\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findLast(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findNext(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findPrev(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findDefault(options: Types.FindDefaultProps): HTMLElement | null {\n        return (\n            this.findElement({\n                ...options,\n                acceptCondition: (el) =>\n                    this._tabster.focusable.isFocusable(\n                        el,\n                        options.includeProgrammaticallyFocusable\n                    ) && !!this.getProps(el).isDefault,\n            }) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onUncontrolled,\n            onElement,\n        } = options;\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this._tabster.focusable.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            includeProgrammaticallyFocusable,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement = acceptElementState.foundElement;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (currentElement) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        let foundElement: HTMLElement | null | undefined;\n        do {\n            foundElement =\n                ((isBackward\n                    ? walker.previousNode()\n                    : walker.nextNode()) as HTMLElement | null) || undefined;\n        } while (prepareForNextElement());\n\n        if (!findAll) {\n            const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n            if (nextUncontrolled) {\n                if (onUncontrolled) {\n                    onUncontrolled(nextUncontrolled);\n                }\n\n                if (foundElement) {\n                    // We have an uncontrolled area and there is a controlled element after it.\n                    // Return undefined for the default Tab action.\n                    return undefined;\n                } else {\n                    // Otherwise, return null to moveOutWithDefaultAction().\n                    return null;\n                }\n            }\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!container.contains(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let lastToIgnore = state.lastToIgnore;\n\n        if (lastToIgnore) {\n            if (lastToIgnore.contains(element)) {\n                return NodeFilter.FILTER_REJECT;\n            } else {\n                lastToIgnore = state.lastToIgnore = undefined;\n            }\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (state.ignoreUncontrolled) {\n            if (shouldIgnoreFocus(element)) {\n                return NodeFilter.FILTER_SKIP;\n            }\n        } else if (\n            ctx.uncontrolled &&\n            !state.nextUncontrolled &&\n            this._tabster.focusable.isFocusable(element, undefined, true, true)\n        ) {\n            if (!ctx.groupper && !ctx.mover) {\n                if (\n                    ctx.modalizer?.userId === this._tabster.modalizer?.activeId\n                ) {\n                    if (this.isVisible(ctx.uncontrolled)) {\n                        state.nextUncontrolled = ctx.uncontrolled;\n                    }\n                    return NodeFilter.FILTER_REJECT;\n                }\n            }\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside\n        if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.lastToIgnore = state.foundElement = element;\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                fromMoverElement &&\n                container.contains(fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    fromMoverElement.contains(groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !container.contains(groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !container.contains(moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !groupperElement.contains(moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            state.found = true;\n            state.foundElement = element;\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: 9;\n    Enter: 13;\n    Esc: 27;\n    Space: 32;\n    PageUp: 33;\n    PageDown: 34;\n    End: 35;\n    Home: 36;\n    Left: 37;\n    Up: 38;\n    Right: 39;\n    Down: 40;\n} = {\n    Tab: 9,\n    Enter: 13,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Left: 37,\n    Up: 38,\n    Right: 39,\n    Down: 40,\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KeyborgFocusInEvent, KEYBORG_FOCUSIN, nativeFocus } from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    getAdjacentElement,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n    triggerEvent,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetails>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              details: Types.FocusedElementDetails;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(\"focusout\", this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = doc.activeElement;\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n\n        win.document.removeEventListener(\n            KEYBORG_FOCUSIN,\n            this._onFocusIn,\n            true\n        );\n        win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const tabsterFocusable = this._tabster.focusable;\n        const { container, ignoreAccessibility } = props;\n        let uncontrolled: HTMLElement | undefined;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                let next = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    !isFirst,\n                    undefined,\n                    ignoreAccessibility\n                );\n\n                if (next) {\n                    toFocus = next.element;\n                    uncontrolled = next.uncontrolled;\n\n                    while (!toFocus && uncontrolled) {\n                        if (\n                            tabsterFocusable.isFocusable(\n                                uncontrolled,\n                                false,\n                                true,\n                                true\n                            )\n                        ) {\n                            toFocus = uncontrolled;\n                        } else {\n                            toFocus = tabsterFocusable[\n                                isFirst ? \"findFirst\" : \"findLast\"\n                            ]({\n                                container: uncontrolled,\n                                ignoreUncontrolled: true,\n                                ignoreAccessibility,\n                                useActiveModalizer: true,\n                            });\n                        }\n\n                        if (!toFocus) {\n                            next = FocusedElementState.findNextTabbable(\n                                this._tabster,\n                                ctx,\n                                uncontrolled,\n                                undefined,\n                                !isFirst,\n                                undefined,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                toFocus = next.element;\n                                uncontrolled = next.uncontrolled;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (toFocus && !container?.contains(toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const details: Types.FocusedElementDetails = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            details.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                details.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            details,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, details);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        super.setVal(val, details);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        this._setFocusedElement(\n            e.target as HTMLElement,\n            e.details.relatedTarget as HTMLElement | undefined,\n            e.details.isFocusedProgrammatically\n        );\n    };\n\n    private _onFocusOut = (e: FocusEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer,\n            cur?: HTMLElement\n        ) => {\n            next = what.findNextTabbable(\n                cur || currentElement,\n                isBackward,\n                ignoreUncontrolled,\n                ignoreAccessibility\n            );\n\n            const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n\n            if (lastMoverOrGroupper && !next?.element && !next?.uncontrolled) {\n                // Handling nested Movers and Grouppers. If not found in the current one,\n                // try the parent one.\n                const lastMoverOrGroupperElement =\n                    lastMoverOrGroupper.getElement();\n                const parentElement = lastMoverOrGroupperElement?.parentElement;\n                const parentCtx =\n                    parentElement &&\n                    RootAPI.getTabsterContext(tabster, parentElement);\n\n                if (parentCtx) {\n                    const isGroupperFirst = parentCtx.isGroupperFirst;\n                    const parentMoverOrGroupper = isGroupperFirst\n                        ? parentCtx.groupper\n                        : parentCtx.mover;\n\n                    if (parentMoverOrGroupper) {\n                        const newCurrent = isBackward\n                            ? lastMoverOrGroupperElement\n                            : getLastChild(lastMoverOrGroupperElement);\n\n                        callFindNext(parentMoverOrGroupper, newCurrent);\n\n                        if (next) {\n                            next.outOfDOMOrder = true;\n                        }\n                    }\n                }\n            }\n        };\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        if (groupper && mover) {\n            callFindNext(ctx.isGroupperFirst ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            let uncontrolled: HTMLElement | undefined;\n            const onUncontrolled = (el: HTMLElement) => {\n                uncontrolled = el;\n            };\n            const nextElement = isBackward\n                ? tabster.focusable.findPrev({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            next = {\n                element: uncontrolled ? undefined : nextElement,\n                uncontrolled,\n            };\n        }\n\n        const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n        const lastMoverOrGroupperElement = lastMoverOrGroupper?.getElement();\n\n        if (lastMoverOrGroupperElement) {\n            next = null;\n\n            const adjacentElement = getAdjacentElement(\n                lastMoverOrGroupperElement,\n                isBackward\n            );\n\n            if (adjacentElement) {\n                const adjacentCtx = RootAPI.getTabsterContext(\n                    tabster,\n                    adjacentElement,\n                    {\n                        checkRtl: true,\n                    }\n                );\n\n                if (adjacentCtx) {\n                    let adjacentFrom = getAdjacentElement(\n                        adjacentElement,\n                        !isBackward\n                    );\n\n                    if (adjacentFrom) {\n                        if (!isBackward) {\n                            adjacentFrom =\n                                getLastChild(adjacentFrom) || adjacentFrom;\n                        }\n\n                        next = FocusedElementState.findNextTabbable(\n                            tabster,\n                            adjacentCtx,\n                            actualContainer,\n                            adjacentFrom,\n                            isBackward,\n                            ignoreUncontrolled,\n                            ignoreAccessibility\n                        );\n\n                        if (next && !next.lastMoverOrGroupper) {\n                            next.lastMoverOrGroupper = lastMoverOrGroupper;\n                        }\n                    }\n                }\n            }\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (e: KeyboardEvent): void => {\n        if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(e)) {\n            return;\n        }\n\n        const isBackward = e.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            isBackward,\n            undefined,\n            true\n        );\n\n        let nextElement: HTMLElement | null | undefined;\n\n        if (next) {\n            let uncontrolled = next.uncontrolled;\n\n            if (uncontrolled) {\n                const isGroupperFirst = ctx.isGroupperFirst;\n                let moveOutside = false;\n\n                if (isGroupperFirst !== undefined) {\n                    const groupper = ctx.groupper?.getElement();\n                    const mover = ctx.mover?.getElement();\n                    let moveFrom: HTMLElement | undefined;\n\n                    if (\n                        isGroupperFirst &&\n                        groupper &&\n                        uncontrolled.contains(groupper)\n                    ) {\n                        moveFrom = groupper;\n                    } else if (\n                        !isGroupperFirst &&\n                        mover &&\n                        uncontrolled.contains(mover)\n                    ) {\n                        moveFrom = mover;\n                    }\n\n                    if (moveFrom) {\n                        uncontrolled = moveFrom;\n                        moveOutside = true;\n                    }\n                }\n\n                if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n                    // We have met an uncontrolled area, just allow default action.\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        uncontrolled,\n                        moveOutside,\n                        isBackward\n                    );\n                }\n\n                return;\n            }\n\n            nextElement = next.element;\n        }\n\n        if (nextElement) {\n            const preventDefault = () => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            };\n\n            // For iframes just allow normal Tab behaviour\n            if (!controlTab) {\n                const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n                let outOfDOMOrder = next?.outOfDOMOrder;\n\n                if (\n                    !outOfDOMOrder &&\n                    currentElement.compareDocumentPosition(nextElement) &\n                        (isBackward\n                            ? document.DOCUMENT_POSITION_FOLLOWING\n                            : document.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    outOfDOMOrder = true;\n                }\n\n                if (outOfDOMOrder) {\n                    // The next element is out of DOM order (for example because of a trapped groupper),\n                    // do not let the browser to move focus.\n                    preventDefault();\n\n                    nativeFocus(nextElement);\n                } else if (lastMoverOrGroupper) {\n                    lastMoverOrGroupper.dummyManager?.moveOutWithDefaultAction(\n                        isBackward\n                    );\n                } else if (ctx.modalizer) {\n                    const nextElementCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        nextElement\n                    );\n\n                    if (\n                        (!nextElementCtx ||\n                            ctx.root.uid !== nextElementCtx.root.uid ||\n                            !nextElementCtx.modalizer?.isActive()) &&\n                        ctx.modalizer.triggerFocusEvent(\n                            Types.ModalizerBeforeFocusOutEventName,\n                            true\n                        )\n                    ) {\n                        preventDefault();\n                    } else if (\n                        !ctx.modalizer.getElement()?.contains(nextElement)\n                    ) {\n                        preventDefault();\n                        ctx.modalizer.dummyManager?.moveOut(isBackward);\n                    }\n                }\n            } else if (nextElement.tagName !== \"IFRAME\") {\n                preventDefault();\n\n                nativeFocus(nextElement);\n            }\n        } else {\n            ctx.root.moveOutWithDefaultAction(isBackward);\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        if (element) {\n            triggerEvent(element, Types.FocusInEventName, details);\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...details };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                triggerEvent(last, Types.FocusOutEventName, d);\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            isBackward,\n                            true,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                isBackward,\n                                true,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            groupperElement.contains(currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, lastMoverOrGroupper: this };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !groupperElement.contains(currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                lastMoverOrGroupper: groupperFirstFocusable ? undefined : this,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            next = isBackward\n                ? tabster.focusable.findPrev({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = isBackward\n                    ? tabster.focusable.findLast({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      })\n                    : tabster.focusable.findFirst({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      });\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (let e = element?.parentElement; e; e = e.parentElement) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = this.getElement()?.parentElement;\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.isGroupperFirst\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                state.container.contains(parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        state.container.contains(parentGroupperElement) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    groupperElement.contains(element)\n                ) {\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.lastToIgnore = groupperElement;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            element.contains(focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n\n        if (ctx && groupper) {\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            let next: HTMLElement | null | undefined;\n\n            const groupperElement = groupper.getElement();\n\n            if (event.keyCode === Keys.Enter) {\n                if (\n                    groupperElement &&\n                    (element === groupperElement ||\n                        (groupper.getProps().delegated &&\n                            element === groupper.getFirst(false)))\n                ) {\n                    next = tabster.focusable.findNext({\n                        container: groupperElement,\n                        currentElement: element,\n                        useActiveModalizer: true,\n                    });\n                }\n            } else if (event.keyCode === Keys.Esc) {\n                if (groupperElement && groupperElement.contains(element)) {\n                    if (element !== groupperElement || noGoUp) {\n                        next = groupper.getFirst(true);\n                    } else {\n                        const parentElement = groupperElement.parentElement;\n                        const parentCtx = parentElement\n                            ? RootAPI.getTabsterContext(tabster, parentElement)\n                            : undefined;\n\n                        groupper = parentCtx?.groupper;\n                        next = groupper?.getFirst(true);\n                    }\n                }\n\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n            }\n\n            if (next) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n\n                next.focus();\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    triggerEvent,\n    augmentAttribute,\n} from \"./Utils\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        isBackward,\n                        true,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakRef<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakRef<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.deref())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(new WeakRef(element));\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this.triggerFocusEvent(\n                isActive\n                    ? Types.ModalizerActiveEventName\n                    : Types.ModalizerInactiveEventName\n            );\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return !!this.getElement()?.contains(element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n                container,\n                currentElement,\n                onUncontrolled,\n                ignoreUncontrolled,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.isTrapped &&\n                tabster.modalizer?.activeId\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreUncontrolled: true,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    }\n                );\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n        };\n    }\n\n    triggerFocusEvent(\n        eventName: Types.ModalizerEventName,\n        allElements?: boolean\n    ): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.deref())\n                : [element];\n\n            for (const el of elements) {\n                if (\n                    el &&\n                    !triggerEvent<Types.ModalizerEventDetails>(el, eventName, {\n                        id: this.userId,\n                        element,\n                        eventName,\n                    })\n                ) {\n                    defaultPrevented = true;\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakRef<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n    private _alwaysAccessibleSelector: string | undefined;\n    private _accessibleCheck: Types.ModalizerElementAccessibleCheck | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakRef<HTMLElement>[];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        // @deprecated use accessibleCheck.\n        alwaysAccessibleSelector?: string,\n        accessibleCheck?: Types.ModalizerElementAccessibleCheck\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n        this._accessibleCheck = accessibleCheck;\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.deref();\n\n                if (el && (element.contains(el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        return modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n            ? undefined\n            : NodeFilter.FILTER_SKIP;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n        const alwaysAccessibleElements: HTMLElement[] = alwaysAccessibleSelector\n            ? Array.from(body.querySelectorAll(alwaysAccessibleSelector))\n            : [];\n        const activeModalizerElements: HTMLElement[] = [];\n\n        for (const userId of Object.keys(parts)) {\n            const modalizerParts = parts[userId];\n\n            for (const id of Object.keys(modalizerParts)) {\n                const modalizer = modalizerParts[id];\n                const el = modalizer.getElement();\n                const props = modalizer.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        activeModalizerElements.push(el);\n\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakRef<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                !this._accessibleCheck?.(element, activeModalizerElements) &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(new WeakRef(element));\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n\n                if (allVisibleElements) {\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (el.contains(c)) {\n                            containsModalizer = true;\n                            break;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.deref())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param e - Element that is focused\n     * @param details - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = e.parentElement\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            details.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                triggerEvent(el, Types.MoverEventName, state);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        const focusable = tabster.focusable;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !container.contains(currentElement))\n        ) {\n            next = isBackward\n                ? focusable.findPrev({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : focusable.findNext({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.isExcludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!moverElement.contains(state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.lastToIgnore = moverElement;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    triggerEvent(el, Types.MoverEventName, state);\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = new MutationObserver((mutations: MutationRecord[]) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                if (mutation.type === \"attributes\") {\n                    if (mutation.attributeName === \"tabindex\") {\n                        updateQueue.push({\n                            element: target as HTMLElement,\n                            type: _moverUpdateAttr,\n                        });\n                    }\n                } else {\n                    for (let i = 0; i < removed.length; i++) {\n                        updateQueue.push({\n                            element: removed[i] as HTMLElement as HTMLElement,\n                            type: _moverUpdateRemove,\n                        });\n                    }\n\n                    for (let i = 0; i < added.length; i++) {\n                        updateQueue.push({\n                            element: added[i] as HTMLElement,\n                            type: _moverUpdateAdd,\n                        });\n                    }\n                }\n            }\n\n            requestUpdate();\n        });\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = el.parentElement\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        for (\n            let el: HTMLElement | null | undefined = e;\n            el;\n            el = el.parentElement\n        ) {\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(e);\n                break;\n            }\n        }\n    };\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        let keyCode = event.keyCode;\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        switch (keyCode) {\n            case Keys.Down:\n            case Keys.Right:\n            case Keys.Up:\n            case Keys.Left:\n            case Keys.PageDown:\n            case Keys.PageUp:\n            case Keys.Home:\n            case Keys.End:\n                break;\n            default:\n                return;\n        }\n\n        const tabster = this._tabster;\n        const focused = tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(tabster, focused, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.isExcludedFromMover ||\n            ctx.ignoreKeydown(event)\n        ) {\n            return;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.isGroupperFirst) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        groupper.getElement()?.parentElement;\n                    el && el !== container;\n                    el = el.parentElement\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (!container) {\n            return;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = focused.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.isRtl) {\n            if (keyCode === Keys.Right) {\n                keyCode = Keys.Left;\n            } else if (keyCode === Keys.Left) {\n                keyCode = Keys.Right;\n            }\n        }\n\n        if (\n            (keyCode === Keys.Down && isVertical) ||\n            (keyCode === Keys.Right && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (keyCode === Keys.Up && isVertical) ||\n            (keyCode === Keys.Left && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.PageUp) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, false);\n            }\n        } else if (keyCode === Keys.PageDown) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, true);\n            }\n        } else if (isGrid) {\n            const isBackward = keyCode === Keys.Up;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: focused,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (next) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n            nativeFocus(next);\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        keyCode: number\n    ): Promise<boolean> {\n        if (element.getAttribute(\"aria-expanded\") === \"true\") {\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection =\n                            element.ownerDocument.defaultView?.getSelection();\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                keyCode === Keys.Left || keyCode === Keys.Up;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = win.getSelection() || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = win.getSelection() || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                element.contains(anchorNode) &&\n                                element.contains(focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (nodeText && !node.firstChild) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = node.firstChild;\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (keyCode === Keys.Left ||\n                    keyCode === Keys.Up ||\n                    keyCode === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (keyCode === Keys.Right ||\n                    keyCode === Keys.Down ||\n                    keyCode === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nexport function observeMutations(\n    doc: HTMLDocument,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    updateTabsterByAttribute(tabster, target as HTMLElement);\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    updateTabsterElements(removed[i], true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = new MutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    constructor() {\n        /**/\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport type {\n    RestorerAPI as RestorerAPIType,\n    GetWindow,\n    Restorer as RestorerInterface,\n    RestorerProps,\n    KeyboardNavigationState,\n    FocusedElementState,\n    TabsterCore,\n} from \"./Types\";\nimport { RestorerTypes } from \"./Types\";\nimport { TabsterPart } from \"./Utils\";\n\nconst EVENT_NAME = \"restorer:restorefocus\";\nconst HISOTRY_DEPTH = 10;\n\nclass Restorer extends TabsterPart<RestorerProps> implements RestorerInterface {\n    constructor(\n        tabster: TabsterCore,\n        element: HTMLElement,\n        props: RestorerProps\n    ) {\n        super(tabster, element, props);\n        if (this._props.type === RestorerTypes.Source) {\n            const element = this._element?.get();\n            element?.addEventListener(\"focusout\", this._onFocusOut);\n        }\n    }\n\n    dispose(): void {\n        if (this._props.type === RestorerTypes.Source) {\n            const element = this._element?.get();\n            element?.removeEventListener(\"focusout\", this._onFocusOut);\n        }\n    }\n\n    private _onFocusOut = (e: FocusEvent) => {\n        if (e.relatedTarget === null) {\n            const element = this._element?.get();\n            element?.dispatchEvent(\n                new Event(EVENT_NAME, {\n                    bubbles: true,\n                })\n            );\n        }\n    };\n}\n\nexport class RestorerAPI implements RestorerAPIType {\n    private _tabster: TabsterCore;\n    private _history: WeakRef<HTMLElement>[] = [];\n    private _keyboardNavState: KeyboardNavigationState;\n    private _focusedElementState: FocusedElementState;\n    private _restoreFocusTimeout = 0;\n    private _getWindow: GetWindow;\n\n    constructor(tabster: TabsterCore) {\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        this._keyboardNavState = tabster.keyboardNavigation;\n        this._focusedElementState = tabster.focusedElement;\n\n        this._focusedElementState.subscribe(this._onFocusIn);\n    }\n\n    dispose(): void {\n        const win = this._getWindow();\n        this._focusedElementState.unsubscribe(this._onFocusIn);\n        win.removeEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n    }\n\n    private _onRestoreFocus = (e: Event) => {\n        const win = this._getWindow();\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n\n        this._restoreFocusTimeout = win.setTimeout(() =>\n            this._restoreFocus(e.target as HTMLElement)\n        );\n    };\n\n    private _onFocusIn = (element: HTMLElement | undefined) => {\n        if (!element) {\n            return;\n        }\n\n        const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n        if (\n            tabsterAttribute?.restorer?.getProps().type !== RestorerTypes.Target\n        ) {\n            return;\n        }\n\n        // Don't duplicate the top of history\n        if (this._history[this._history.length - 1]?.deref() === element) {\n            return;\n        }\n\n        if (this._history.length > HISOTRY_DEPTH) {\n            this._history.shift();\n        }\n\n        this._history.push(new WeakRef<HTMLElement>(element));\n    };\n\n    private _restoreFocus = (source: HTMLElement) => {\n        // don't restore focus if focus isn't lost to body\n        const doc = this._getWindow().document;\n        if (doc.activeElement !== document.body) {\n            return;\n        }\n\n        if (\n            // clicking on any empty space focuses body - this is can be a false positive\n            !this._keyboardNavState.isNavigatingWithKeyboard() &&\n            // Source no longer exists on DOM - always restore focus\n            doc.body.contains(source)\n        ) {\n            return;\n        }\n\n        let weakRef = this._history.pop();\n        while (\n            weakRef &&\n            !doc.body.contains(weakRef.deref()?.parentElement ?? null)\n        ) {\n            weakRef = this._history.pop();\n        }\n\n        weakRef?.deref()?.focus();\n    };\n\n    public createRestorer(element: HTMLElement, props: RestorerProps) {\n        return new Restorer(this._tabster, element, props);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\nimport { RestorerAPI } from \"./Restorer\";\n\nexport { Types };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n    restorer?: Types.RestorerAPI;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI();\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    createTabster(noRefCount?: boolean): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n        this.restorer?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster();\n    }\n\n    tabster = new TabsterCore(win, props);\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n * @param accessibleCheck An optional callback that will be called when\n * active Modalizer wants to hide an element that doesn't belong to it from\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\n * but allows to address the elements programmatically rather than with a selector.\n * If the callback returns true, the element will not receive aria-hidden.\n */\nexport function getModalizer(\n    tabster: Types.Tabster,\n    // @deprecated use accessibleCheck.\n    alwaysAccessibleSelector?: string,\n    accessibleCheck?: Types.ModalizerElementAccessibleCheck\n): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(\n            tabsterCore,\n            alwaysAccessibleSelector,\n            accessibleCheck\n        );\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function getRestorer(tabster: Types.Tabster): Types.RestorerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.restorer) {\n        tabsterCore.restorer = new RestorerAPI(tabsterCore);\n    }\n\n    return tabsterCore.restorer;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}