{"ast":null,"code":"import * as React from 'react';\nfunction isFactoryDispatch(newState) {\n  return typeof newState === 'function';\n}\n/**\n * @internal\n *\n * A [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate)-like hook\n * to manage a value that could be either `controlled` or `uncontrolled`,\n * such as a checked state or text input string.\n *\n * @see https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components for more details on `controlled`/`uncontrolled`\n *\n * @returns an array of the current value and an updater (dispatcher) function.\n * The updater function is referentially stable (won't change during the component's lifecycle).\n * It can take either a new value, or a function which is passed the previous value and returns the new value.\n *\n * ❗️❗️ Calls to the dispatcher will only modify the state if the state is `uncontrolled`.\n * Meaning that if a state is `controlled`, calls to the dispatcher do not modify the state.\n *\n */\nexport const useControllableState = options => {\n  const [internalState, setInternalState] = React.useState(() => {\n    if (options.defaultState === undefined) {\n      return options.initialState;\n    }\n    return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;\n  });\n  // Heads up!\n  // This part is specific for controlled mode and mocks behavior of React dispatcher function.\n  const stateValueRef = React.useRef(options.state);\n  React.useEffect(() => {\n    stateValueRef.current = options.state;\n  }, [options.state]);\n  const setControlledState = React.useCallback(newState => {\n    if (isFactoryDispatch(newState)) {\n      newState(stateValueRef.current);\n    }\n  }, []);\n  return useIsControlled(options.state) ? [options.state, setControlledState] : [internalState, setInternalState];\n};\nfunction isInitializer(value) {\n  return typeof value === 'function';\n}\n/**\n * Helper hook to handle previous comparison of controlled/uncontrolled\n * Prints an error when isControlled value switches between subsequent renders\n * @returns - whether the value is controlled\n */\nconst useIsControlled = controlledValue => {\n  const [isControlled] = React.useState(() => controlledValue !== undefined);\n  if (process.env.NODE_ENV !== 'production') {\n    // We don't want these warnings in production even though it is against native behaviour\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      if (isControlled !== (controlledValue !== undefined)) {\n        const error = new Error();\n        const controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';\n        const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined';\n        // eslint-disable-next-line no-console\n        console.error([\n        // Default react error\n        'A component is changing ' + controlWarning + '. This is likely caused by the value', 'changing from ' + undefinedWarning + ' value, which should not happen.', 'Decide between using a controlled or uncontrolled input element for the lifetime of the component.', 'More info: https://reactjs.org/link/controlled-components', error.stack].join(' '));\n      }\n    }, [isControlled, controlledValue]);\n  }\n  return isControlled;\n};","map":{"version":3,"names":["React","isFactoryDispatch","newState","useControllableState","options","internalState","setInternalState","useState","defaultState","undefined","initialState","isInitializer","stateValueRef","useRef","state","useEffect","current","setControlledState","useCallback","useIsControlled","value","controlledValue","isControlled","process","env","NODE_ENV","error","Error","controlWarning","undefinedWarning","console","stack","join"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js"],"sourcesContent":["import * as React from 'react';\nfunction isFactoryDispatch(newState) {\n    return typeof newState === 'function';\n}\n/**\n * @internal\n *\n * A [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate)-like hook\n * to manage a value that could be either `controlled` or `uncontrolled`,\n * such as a checked state or text input string.\n *\n * @see https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components for more details on `controlled`/`uncontrolled`\n *\n * @returns an array of the current value and an updater (dispatcher) function.\n * The updater function is referentially stable (won't change during the component's lifecycle).\n * It can take either a new value, or a function which is passed the previous value and returns the new value.\n *\n * ❗️❗️ Calls to the dispatcher will only modify the state if the state is `uncontrolled`.\n * Meaning that if a state is `controlled`, calls to the dispatcher do not modify the state.\n *\n */ export const useControllableState = (options)=>{\n    const [internalState, setInternalState] = React.useState(()=>{\n        if (options.defaultState === undefined) {\n            return options.initialState;\n        }\n        return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;\n    });\n    // Heads up!\n    // This part is specific for controlled mode and mocks behavior of React dispatcher function.\n    const stateValueRef = React.useRef(options.state);\n    React.useEffect(()=>{\n        stateValueRef.current = options.state;\n    }, [\n        options.state\n    ]);\n    const setControlledState = React.useCallback((newState)=>{\n        if (isFactoryDispatch(newState)) {\n            newState(stateValueRef.current);\n        }\n    }, []);\n    return useIsControlled(options.state) ? [\n        options.state,\n        setControlledState\n    ] : [\n        internalState,\n        setInternalState\n    ];\n};\nfunction isInitializer(value) {\n    return typeof value === 'function';\n}\n/**\n * Helper hook to handle previous comparison of controlled/uncontrolled\n * Prints an error when isControlled value switches between subsequent renders\n * @returns - whether the value is controlled\n */ const useIsControlled = (controlledValue)=>{\n    const [isControlled] = React.useState(()=>controlledValue !== undefined);\n    if (process.env.NODE_ENV !== 'production') {\n        // We don't want these warnings in production even though it is against native behaviour\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useEffect(()=>{\n            if (isControlled !== (controlledValue !== undefined)) {\n                const error = new Error();\n                const controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';\n                const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined';\n                // eslint-disable-next-line no-console\n                console.error([\n                    // Default react error\n                    'A component is changing ' + controlWarning + '. This is likely caused by the value',\n                    'changing from ' + undefinedWarning + ' value, which should not happen.',\n                    'Decide between using a controlled or uncontrolled input element for the lifetime of the component.',\n                    'More info: https://reactjs.org/link/controlled-components',\n                    error.stack\n                ].join(' '));\n            }\n        }, [\n            isControlled,\n            controlledValue\n        ]);\n    }\n    return isControlled;\n};\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,iBAAiBA,CAACC,QAAQ,EAAE;EACjC,OAAO,OAAOA,QAAQ,KAAK,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,OAAO,MAAMC,oBAAoB,GAAIC,OAAO,IAAG;EAC/C,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGN,KAAK,CAACO,QAAQ,CAAC,MAAI;IACzD,IAAIH,OAAO,CAACI,YAAY,KAAKC,SAAS,EAAE;MACpC,OAAOL,OAAO,CAACM,YAAY;IAC/B;IACA,OAAOC,aAAa,CAACP,OAAO,CAACI,YAAY,CAAC,GAAGJ,OAAO,CAACI,YAAY,CAAC,CAAC,GAAGJ,OAAO,CAACI,YAAY;EAC9F,CAAC,CAAC;EACF;EACA;EACA,MAAMI,aAAa,GAAGZ,KAAK,CAACa,MAAM,CAACT,OAAO,CAACU,KAAK,CAAC;EACjDd,KAAK,CAACe,SAAS,CAAC,MAAI;IAChBH,aAAa,CAACI,OAAO,GAAGZ,OAAO,CAACU,KAAK;EACzC,CAAC,EAAE,CACCV,OAAO,CAACU,KAAK,CAChB,CAAC;EACF,MAAMG,kBAAkB,GAAGjB,KAAK,CAACkB,WAAW,CAAEhB,QAAQ,IAAG;IACrD,IAAID,iBAAiB,CAACC,QAAQ,CAAC,EAAE;MAC7BA,QAAQ,CAACU,aAAa,CAACI,OAAO,CAAC;IACnC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAOG,eAAe,CAACf,OAAO,CAACU,KAAK,CAAC,GAAG,CACpCV,OAAO,CAACU,KAAK,EACbG,kBAAkB,CACrB,GAAG,CACAZ,aAAa,EACbC,gBAAgB,CACnB;AACL,CAAC;AACD,SAASK,aAAaA,CAACS,KAAK,EAAE;EAC1B,OAAO,OAAOA,KAAK,KAAK,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AAAI,MAAMD,eAAe,GAAIE,eAAe,IAAG;EAC3C,MAAM,CAACC,YAAY,CAAC,GAAGtB,KAAK,CAACO,QAAQ,CAAC,MAAIc,eAAe,KAAKZ,SAAS,CAAC;EACxE,IAAIc,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACvC;IACA;IACAzB,KAAK,CAACe,SAAS,CAAC,MAAI;MAChB,IAAIO,YAAY,MAAMD,eAAe,KAAKZ,SAAS,CAAC,EAAE;QAClD,MAAMiB,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC;QACzB,MAAMC,cAAc,GAAGN,YAAY,GAAG,uCAAuC,GAAG,wCAAwC;QACxH,MAAMO,gBAAgB,GAAGP,YAAY,GAAG,yBAAyB,GAAG,wBAAwB;QAC5F;QACAQ,OAAO,CAACJ,KAAK,CAAC;QACV;QACA,0BAA0B,GAAGE,cAAc,GAAG,sCAAsC,EACpF,gBAAgB,GAAGC,gBAAgB,GAAG,kCAAkC,EACxE,oGAAoG,EACpG,2DAA2D,EAC3DH,KAAK,CAACK,KAAK,CACd,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;MAChB;IACJ,CAAC,EAAE,CACCV,YAAY,EACZD,eAAe,CAClB,CAAC;EACN;EACA,OAAOC,YAAY;AACvB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}