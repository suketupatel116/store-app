{"ast":null,"code":"import { isHTMLElement } from '@fluentui/react-utilities';\nimport { KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\nimport { FOCUS_VISIBLE_ATTR } from './constants';\n/**\n * @internal\n * @param scope - Applies the ponyfill to all DOM children\n * @param targetWindow - window\n */\nexport function applyFocusVisiblePolyfill(scope, targetWindow) {\n  if (alreadyInScope(scope)) {\n    // Focus visible polyfill already applied at this scope\n    return () => undefined;\n  }\n  const state = {\n    current: undefined\n  };\n  const keyborg = createKeyborg(targetWindow);\n  // When navigation mode changes remove the focus-visible selector\n  keyborg.subscribe(isNavigatingWithKeyboard => {\n    if (!isNavigatingWithKeyboard && state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n  });\n  // Keyborg's focusin event is delegated so it's only registered once on the window\n  // and contains metadata about the focus event\n  const keyborgListener = e => {\n    if (state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {\n      // Griffel can't create chained global styles so use the parent element for now\n      state.current = e.target;\n      applyFocusVisibleClass(state.current);\n    }\n  };\n  // Make sure that when focus leaves the scope, the focus visible class is removed\n  const blurListener = e => {\n    if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {\n      if (state.current) {\n        removeFocusVisibleClass(state.current);\n        state.current = undefined;\n      }\n    }\n  };\n  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);\n  scope.addEventListener('focusout', blurListener);\n  scope.focusVisible = true;\n  // Return disposer\n  return () => {\n    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);\n    scope.removeEventListener('focusout', blurListener);\n    delete scope.focusVisible;\n    disposeKeyborg(keyborg);\n  };\n}\nfunction applyFocusVisibleClass(el) {\n  el.setAttribute(FOCUS_VISIBLE_ATTR, '');\n}\nfunction removeFocusVisibleClass(el) {\n  el.removeAttribute(FOCUS_VISIBLE_ATTR);\n}\nfunction alreadyInScope(el) {\n  if (!el) {\n    return false;\n  }\n  if (el.focusVisible) {\n    return true;\n  }\n  return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);\n}","map":{"version":3,"names":["isHTMLElement","KEYBORG_FOCUSIN","createKeyborg","disposeKeyborg","FOCUS_VISIBLE_ATTR","applyFocusVisiblePolyfill","scope","targetWindow","alreadyInScope","undefined","state","current","keyborg","subscribe","isNavigatingWithKeyboard","removeFocusVisibleClass","keyborgListener","e","target","applyFocusVisibleClass","blurListener","relatedTarget","contains","addEventListener","focusVisible","removeEventListener","el","setAttribute","removeAttribute","parentElement"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js"],"sourcesContent":["import { isHTMLElement } from '@fluentui/react-utilities';\nimport { KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\nimport { FOCUS_VISIBLE_ATTR } from './constants';\n/**\n * @internal\n * @param scope - Applies the ponyfill to all DOM children\n * @param targetWindow - window\n */ export function applyFocusVisiblePolyfill(scope, targetWindow) {\n    if (alreadyInScope(scope)) {\n        // Focus visible polyfill already applied at this scope\n        return ()=>undefined;\n    }\n    const state = {\n        current: undefined\n    };\n    const keyborg = createKeyborg(targetWindow);\n    // When navigation mode changes remove the focus-visible selector\n    keyborg.subscribe((isNavigatingWithKeyboard)=>{\n        if (!isNavigatingWithKeyboard && state.current) {\n            removeFocusVisibleClass(state.current);\n            state.current = undefined;\n        }\n    });\n    // Keyborg's focusin event is delegated so it's only registered once on the window\n    // and contains metadata about the focus event\n    const keyborgListener = (e)=>{\n        if (state.current) {\n            removeFocusVisibleClass(state.current);\n            state.current = undefined;\n        }\n        if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {\n            // Griffel can't create chained global styles so use the parent element for now\n            state.current = e.target;\n            applyFocusVisibleClass(state.current);\n        }\n    };\n    // Make sure that when focus leaves the scope, the focus visible class is removed\n    const blurListener = (e)=>{\n        if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {\n            if (state.current) {\n                removeFocusVisibleClass(state.current);\n                state.current = undefined;\n            }\n        }\n    };\n    scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);\n    scope.addEventListener('focusout', blurListener);\n    scope.focusVisible = true;\n    // Return disposer\n    return ()=>{\n        scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);\n        scope.removeEventListener('focusout', blurListener);\n        delete scope.focusVisible;\n        disposeKeyborg(keyborg);\n    };\n}\nfunction applyFocusVisibleClass(el) {\n    el.setAttribute(FOCUS_VISIBLE_ATTR, '');\n}\nfunction removeFocusVisibleClass(el) {\n    el.removeAttribute(FOCUS_VISIBLE_ATTR);\n}\nfunction alreadyInScope(el) {\n    if (!el) {\n        return false;\n    }\n    if (el.focusVisible) {\n        return true;\n    }\n    return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,2BAA2B;AACzD,SAASC,eAAe,EAAEC,aAAa,EAAEC,cAAc,QAAQ,SAAS;AACxE,SAASC,kBAAkB,QAAQ,aAAa;AAChD;AACA;AACA;AACA;AACA;AAAI,OAAO,SAASC,yBAAyBA,CAACC,KAAK,EAAEC,YAAY,EAAE;EAC/D,IAAIC,cAAc,CAACF,KAAK,CAAC,EAAE;IACvB;IACA,OAAO,MAAIG,SAAS;EACxB;EACA,MAAMC,KAAK,GAAG;IACVC,OAAO,EAAEF;EACb,CAAC;EACD,MAAMG,OAAO,GAAGV,aAAa,CAACK,YAAY,CAAC;EAC3C;EACAK,OAAO,CAACC,SAAS,CAAEC,wBAAwB,IAAG;IAC1C,IAAI,CAACA,wBAAwB,IAAIJ,KAAK,CAACC,OAAO,EAAE;MAC5CI,uBAAuB,CAACL,KAAK,CAACC,OAAO,CAAC;MACtCD,KAAK,CAACC,OAAO,GAAGF,SAAS;IAC7B;EACJ,CAAC,CAAC;EACF;EACA;EACA,MAAMO,eAAe,GAAIC,CAAC,IAAG;IACzB,IAAIP,KAAK,CAACC,OAAO,EAAE;MACfI,uBAAuB,CAACL,KAAK,CAACC,OAAO,CAAC;MACtCD,KAAK,CAACC,OAAO,GAAGF,SAAS;IAC7B;IACA,IAAIG,OAAO,CAACE,wBAAwB,CAAC,CAAC,IAAId,aAAa,CAACiB,CAAC,CAACC,MAAM,CAAC,IAAID,CAAC,CAACC,MAAM,EAAE;MAC3E;MACAR,KAAK,CAACC,OAAO,GAAGM,CAAC,CAACC,MAAM;MACxBC,sBAAsB,CAACT,KAAK,CAACC,OAAO,CAAC;IACzC;EACJ,CAAC;EACD;EACA,MAAMS,YAAY,GAAIH,CAAC,IAAG;IACtB,IAAI,CAACA,CAAC,CAACI,aAAa,IAAIrB,aAAa,CAACiB,CAAC,CAACI,aAAa,CAAC,IAAI,CAACf,KAAK,CAACgB,QAAQ,CAACL,CAAC,CAACI,aAAa,CAAC,EAAE;MACxF,IAAIX,KAAK,CAACC,OAAO,EAAE;QACfI,uBAAuB,CAACL,KAAK,CAACC,OAAO,CAAC;QACtCD,KAAK,CAACC,OAAO,GAAGF,SAAS;MAC7B;IACJ;EACJ,CAAC;EACDH,KAAK,CAACiB,gBAAgB,CAACtB,eAAe,EAAEe,eAAe,CAAC;EACxDV,KAAK,CAACiB,gBAAgB,CAAC,UAAU,EAAEH,YAAY,CAAC;EAChDd,KAAK,CAACkB,YAAY,GAAG,IAAI;EACzB;EACA,OAAO,MAAI;IACPlB,KAAK,CAACmB,mBAAmB,CAACxB,eAAe,EAAEe,eAAe,CAAC;IAC3DV,KAAK,CAACmB,mBAAmB,CAAC,UAAU,EAAEL,YAAY,CAAC;IACnD,OAAOd,KAAK,CAACkB,YAAY;IACzBrB,cAAc,CAACS,OAAO,CAAC;EAC3B,CAAC;AACL;AACA,SAASO,sBAAsBA,CAACO,EAAE,EAAE;EAChCA,EAAE,CAACC,YAAY,CAACvB,kBAAkB,EAAE,EAAE,CAAC;AAC3C;AACA,SAASW,uBAAuBA,CAACW,EAAE,EAAE;EACjCA,EAAE,CAACE,eAAe,CAACxB,kBAAkB,CAAC;AAC1C;AACA,SAASI,cAAcA,CAACkB,EAAE,EAAE;EACxB,IAAI,CAACA,EAAE,EAAE;IACL,OAAO,KAAK;EAChB;EACA,IAAIA,EAAE,CAACF,YAAY,EAAE;IACjB,OAAO,IAAI;EACf;EACA,OAAOhB,cAAc,CAACkB,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,aAAa,CAAC;AACnF"},"metadata":{},"sourceType":"module","externalDependencies":[]}