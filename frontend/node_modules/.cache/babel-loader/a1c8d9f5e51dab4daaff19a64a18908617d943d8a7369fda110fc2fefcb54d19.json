{"ast":null,"code":"/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n// IE11 compat, checks if WeakRef is supported\nconst _canUseWeakRef = typeof WeakRef !== \"undefined\";\n/**\r\n * WeakRef wrapper around a HTMLElement that also supports IE11\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef}\r\n * @internal\r\n */\n\nclass WeakRefInstance {\n  constructor(instance) {\n    if (_canUseWeakRef && typeof instance === \"object\") {\n      this._weakRef = new WeakRef(instance);\n    } else {\n      this._instance = instance;\n    }\n  }\n  /**\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}\r\n   */\n\n  deref() {\n    var _a, _b, _c;\n    let instance;\n    if (this._weakRef) {\n      instance = (_a = this._weakRef) === null || _a === void 0 ? void 0 : _a.deref();\n      if (!instance) {\n        delete this._weakRef;\n      }\n    } else {\n      instance = this._instance;\n      if ((_c = (_b = instance) === null || _b === void 0 ? void 0 : _b.isDisposed) === null || _c === void 0 ? void 0 : _c.call(_b)) {\n        delete this._instance;\n      }\n    }\n    return instance;\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst KEYBORG_FOCUSIN = \"keyborg:focusin\";\nfunction canOverrideNativeFocus(win) {\n  const HTMLElement = win.HTMLElement;\n  const origFocus = HTMLElement.prototype.focus;\n  let isCustomFocusCalled = false;\n  HTMLElement.prototype.focus = function focus() {\n    isCustomFocusCalled = true;\n  };\n  const btn = win.document.createElement(\"button\");\n  btn.focus();\n  HTMLElement.prototype.focus = origFocus;\n  return isCustomFocusCalled;\n}\nlet _canOverrideNativeFocus = false;\n/**\r\n * Guarantees that the native `focus` will be used\r\n */\n\nfunction nativeFocus(element) {\n  const focus = element.focus;\n  if (focus.__keyborgNativeFocus) {\n    focus.__keyborgNativeFocus.call(element);\n  } else {\n    element.focus();\n  }\n}\n/**\r\n * Overrides the native `focus` and setups the keyborg focus event\r\n */\n\nfunction setupFocusEvent(win) {\n  const kwin = win;\n  if (!_canOverrideNativeFocus) {\n    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);\n  }\n  const origFocus = kwin.HTMLElement.prototype.focus;\n  if (origFocus.__keyborgNativeFocus) {\n    // Already set up.\n    return;\n  }\n  kwin.HTMLElement.prototype.focus = focus;\n  const data = kwin.__keyborgData = {\n    focusInHandler: e => {\n      var _a;\n      const target = e.target;\n      if (!target) {\n        return;\n      }\n      const event = document.createEvent(\"HTMLEvents\");\n      event.initEvent(KEYBORG_FOCUSIN, true, true);\n      const details = {\n        relatedTarget: e.relatedTarget || undefined\n      };\n      if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {\n        details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref());\n        data.lastFocusedProgrammatically = undefined;\n      }\n      event.details = details;\n      target.dispatchEvent(event);\n    }\n  };\n  kwin.document.addEventListener(\"focusin\", kwin.__keyborgData.focusInHandler, true);\n  function focus() {\n    const keyborgNativeFocusEvent = kwin.__keyborgData;\n    if (keyborgNativeFocusEvent) {\n      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);\n    } // eslint-disable-next-line prefer-rest-params\n\n    return origFocus.apply(this, arguments);\n  }\n  focus.__keyborgNativeFocus = origFocus;\n}\n/**\r\n * Removes keyborg event listeners and custom focus override\r\n * @param win The window that stores keyborg focus events\r\n */\n\nfunction disposeFocusEvent(win) {\n  const kwin = win;\n  const proto = kwin.HTMLElement.prototype;\n  const origFocus = proto.focus.__keyborgNativeFocus;\n  const keyborgNativeFocusEvent = kwin.__keyborgData;\n  if (keyborgNativeFocusEvent) {\n    kwin.document.removeEventListener(\"focusin\", keyborgNativeFocusEvent.focusInHandler, true);\n    delete kwin.__keyborgData;\n  }\n  if (origFocus) {\n    proto.focus = origFocus;\n  }\n}\n/**\r\n * @param win The window that stores keyborg focus events\r\n * @returns The last element focused with element.focus()\r\n */\n\nfunction getLastFocusedProgrammatically(win) {\n  var _a;\n  const keyborgNativeFocusEvent = win.__keyborgData;\n  return keyborgNativeFocusEvent ? ((_a = keyborgNativeFocusEvent.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref()) || null : undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _dismissTimeout = 500; // When a key from dismissKeys is pressed and the focus is not moved\n// during _dismissTimeout time, dismiss the keyboard navigation mode.\n\nlet _lastId = 0;\n/**\r\n * Source of truth for all the keyborg core instances and the current keyboard navigation state\r\n */\n\nclass KeyborgState {\n  constructor() {\n    this.__keyborgCoreRefs = {};\n    this._isNavigatingWithKeyboard = false;\n  }\n  add(keyborg) {\n    const id = keyborg.id;\n    if (!(id in this.__keyborgCoreRefs)) {\n      this.__keyborgCoreRefs[id] = new WeakRefInstance(keyborg);\n    }\n  }\n  remove(id) {\n    delete this.__keyborgCoreRefs[id];\n    if (Object.keys(this.__keyborgCoreRefs).length === 0) {\n      this._isNavigatingWithKeyboard = false;\n    }\n  }\n  setVal(isNavigatingWithKeyboard) {\n    if (this._isNavigatingWithKeyboard === isNavigatingWithKeyboard) {\n      return;\n    }\n    this._isNavigatingWithKeyboard = isNavigatingWithKeyboard;\n    for (const id of Object.keys(this.__keyborgCoreRefs)) {\n      const ref = this.__keyborgCoreRefs[id];\n      const keyborg = ref.deref();\n      if (keyborg) {\n        keyborg.update(isNavigatingWithKeyboard);\n      } else {\n        this.remove(id);\n      }\n    }\n  }\n  getVal() {\n    return this._isNavigatingWithKeyboard;\n  }\n}\nconst _state = /*#__PURE__*/new KeyborgState();\n/**\r\n * Manages a collection of Keyborg instances in a window/document and updates keyborg state\r\n */\n\nclass KeyborgCore {\n  constructor(win, props) {\n    this._isMouseUsed = false;\n    this._onFocusIn = e => {\n      if (this._isMouseUsed) {\n        this._isMouseUsed = false;\n        return;\n      }\n      if (_state.getVal()) {\n        return;\n      }\n      const details = e.details;\n      if (!details.relatedTarget) {\n        return;\n      }\n      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === undefined) {\n        // The element is focused programmatically, or the programmatic focus detection\n        // is not working.\n        return;\n      }\n      _state.setVal(true);\n    };\n    this._onMouseDown = e => {\n      if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {\n        // This is most likely an event triggered by the screen reader to perform\n        // an action on an element, do not dismiss the keyboard navigation mode.\n        return;\n      }\n      this._isMouseUsed = true;\n      _state.setVal(false);\n    };\n    this._onKeyDown = e => {\n      var _a;\n      const isNavigatingWithKeyboard = _state.getVal();\n      const keyCode = e.keyCode;\n      const triggerKeys = this._triggerKeys;\n      if (!isNavigatingWithKeyboard && (!triggerKeys || triggerKeys.has(keyCode))) {\n        _state.setVal(true);\n      } else if (isNavigatingWithKeyboard && ((_a = this._dismissKeys) === null || _a === void 0 ? void 0 : _a.has(keyCode))) {\n        this._scheduleDismiss();\n      }\n    };\n    this.id = \"c\" + ++_lastId;\n    this._win = win;\n    const doc = win.document;\n    if (props) {\n      const triggerKeys = props.triggerKeys;\n      const dismissKeys = props.dismissKeys;\n      if (triggerKeys === null || triggerKeys === void 0 ? void 0 : triggerKeys.length) {\n        this._triggerKeys = new Set(triggerKeys);\n      }\n      if (dismissKeys === null || dismissKeys === void 0 ? void 0 : dismissKeys.length) {\n        this._dismissKeys = new Set(dismissKeys);\n      }\n    }\n    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n\n    doc.addEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n    setupFocusEvent(win);\n    _state.add(this);\n  }\n  dispose() {\n    const win = this._win;\n    if (win) {\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n      disposeFocusEvent(win);\n      const doc = win.document;\n      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n\n      doc.removeEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n\n      win.removeEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n      delete this._win;\n      _state.remove(this.id);\n    }\n  }\n  isDisposed() {\n    return !!this._win;\n  }\n  /**\r\n   * Updates all keyborg instances with the keyboard navigation state\r\n   */\n\n  update(isNavigatingWithKeyboard) {\n    var _a, _b;\n    const keyborgs = (_b = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg) === null || _b === void 0 ? void 0 : _b.refs;\n    if (keyborgs) {\n      for (const id of Object.keys(keyborgs)) {\n        Keyborg.update(keyborgs[id], isNavigatingWithKeyboard);\n      }\n    }\n  }\n  _scheduleDismiss() {\n    const win = this._win;\n    if (win) {\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n      const was = win.document.activeElement;\n      this._dismissTimer = win.setTimeout(() => {\n        this._dismissTimer = undefined;\n        const cur = win.document.activeElement;\n        if (was && cur && was === cur) {\n          // Esc was pressed, currently focused element hasn't changed.\n          // Just dismiss the keyboard navigation mode.\n          _state.setVal(false);\n        }\n      }, _dismissTimeout);\n    }\n  }\n}\n/**\r\n * Used to determine the keyboard navigation state\r\n */\n\nclass Keyborg {\n  constructor(win, props) {\n    this._cb = [];\n    this._id = \"k\" + ++_lastId;\n    this._win = win;\n    const current = win.__keyborg;\n    if (current) {\n      this._core = current.core;\n      current.refs[this._id] = this;\n    } else {\n      this._core = new KeyborgCore(win, props);\n      win.__keyborg = {\n        core: this._core,\n        refs: {\n          [this._id]: this\n        }\n      };\n    }\n  }\n  static create(win, props) {\n    return new Keyborg(win, props);\n  }\n  static dispose(instance) {\n    instance.dispose();\n  }\n  /**\r\n   * Updates all subscribed callbacks with the keyboard navigation state\r\n   */\n\n  static update(instance, isNavigatingWithKeyboard) {\n    instance._cb.forEach(callback => callback(isNavigatingWithKeyboard));\n  }\n  dispose() {\n    var _a;\n    const current = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg;\n    if (current === null || current === void 0 ? void 0 : current.refs[this._id]) {\n      delete current.refs[this._id];\n      if (Object.keys(current.refs).length === 0) {\n        current.core.dispose(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        delete this._win.__keyborg;\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Keyborg instance \" + this._id + \" is being disposed incorrectly.\");\n    }\n    this._cb = [];\n    delete this._core;\n    delete this._win;\n  }\n  /**\r\n   * @returns Whether the user is navigating with keyboard\r\n   */\n\n  isNavigatingWithKeyboard() {\n    return _state.getVal();\n  }\n  /**\r\n   * @param callback - Called when the keyboard navigation state changes\r\n   */\n\n  subscribe(callback) {\n    this._cb.push(callback);\n  }\n  /**\r\n   * @param callback - Registered with subscribe\r\n   */\n\n  unsubscribe(callback) {\n    const index = this._cb.indexOf(callback);\n    if (index >= 0) {\n      this._cb.splice(index, 1);\n    }\n  }\n  /**\r\n   * Manually set the keyboard navigtion state\r\n   */\n\n  setVal(isNavigatingWithKeyboard) {\n    _state.setVal(isNavigatingWithKeyboard);\n  }\n}\nfunction createKeyborg(win, props) {\n  return Keyborg.create(win, props);\n}\nfunction disposeKeyborg(instance) {\n  Keyborg.dispose(instance);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst version = \"2.0.0\";\nexport { KEYBORG_FOCUSIN, Keyborg, createKeyborg, disposeKeyborg, getLastFocusedProgrammatically, nativeFocus, version };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n// IE11 compat, checks if WeakRef is supported\nconst _canUseWeakRef = typeof WeakRef !== \"undefined\";\n/**\r\n * WeakRef wrapper around a HTMLElement that also supports IE11\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef}\r\n * @internal\r\n */\n\nclass WeakRefInstance {\n  constructor(instance) {\n    if (_canUseWeakRef && typeof instance === \"object\") {\n      this._weakRef = new WeakRef(instance);\n    } else {\n      this._instance = instance;\n    }\n  }\n  /**\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}\r\n   */\n\n\n  deref() {\n    var _a, _b, _c;\n\n    let instance;\n\n    if (this._weakRef) {\n      instance = (_a = this._weakRef) === null || _a === void 0 ? void 0 : _a.deref();\n\n      if (!instance) {\n        delete this._weakRef;\n      }\n    } else {\n      instance = this._instance;\n\n      if ((_c = (_b = instance) === null || _b === void 0 ? void 0 : _b.isDisposed) === null || _c === void 0 ? void 0 : _c.call(_b)) {\n        delete this._instance;\n      }\n    }\n\n    return instance;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst KEYBORG_FOCUSIN = \"keyborg:focusin\";\n\nfunction canOverrideNativeFocus(win) {\n  const HTMLElement = win.HTMLElement;\n  const origFocus = HTMLElement.prototype.focus;\n  let isCustomFocusCalled = false;\n\n  HTMLElement.prototype.focus = function focus() {\n    isCustomFocusCalled = true;\n  };\n\n  const btn = win.document.createElement(\"button\");\n  btn.focus();\n  HTMLElement.prototype.focus = origFocus;\n  return isCustomFocusCalled;\n}\n\nlet _canOverrideNativeFocus = false;\n/**\r\n * Guarantees that the native `focus` will be used\r\n */\n\nfunction nativeFocus(element) {\n  const focus = element.focus;\n\n  if (focus.__keyborgNativeFocus) {\n    focus.__keyborgNativeFocus.call(element);\n  } else {\n    element.focus();\n  }\n}\n/**\r\n * Overrides the native `focus` and setups the keyborg focus event\r\n */\n\nfunction setupFocusEvent(win) {\n  const kwin = win;\n\n  if (!_canOverrideNativeFocus) {\n    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);\n  }\n\n  const origFocus = kwin.HTMLElement.prototype.focus;\n\n  if (origFocus.__keyborgNativeFocus) {\n    // Already set up.\n    return;\n  }\n\n  kwin.HTMLElement.prototype.focus = focus;\n  const data = kwin.__keyborgData = {\n    focusInHandler: e => {\n      var _a;\n\n      const target = e.target;\n\n      if (!target) {\n        return;\n      }\n\n      const event = document.createEvent(\"HTMLEvents\");\n      event.initEvent(KEYBORG_FOCUSIN, true, true);\n      const details = {\n        relatedTarget: e.relatedTarget || undefined\n      };\n\n      if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {\n        details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref());\n        data.lastFocusedProgrammatically = undefined;\n      }\n\n      event.details = details;\n      target.dispatchEvent(event);\n    }\n  };\n  kwin.document.addEventListener(\"focusin\", kwin.__keyborgData.focusInHandler, true);\n\n  function focus() {\n    const keyborgNativeFocusEvent = kwin.__keyborgData;\n\n    if (keyborgNativeFocusEvent) {\n      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    return origFocus.apply(this, arguments);\n  }\n\n  focus.__keyborgNativeFocus = origFocus;\n}\n/**\r\n * Removes keyborg event listeners and custom focus override\r\n * @param win The window that stores keyborg focus events\r\n */\n\nfunction disposeFocusEvent(win) {\n  const kwin = win;\n  const proto = kwin.HTMLElement.prototype;\n  const origFocus = proto.focus.__keyborgNativeFocus;\n  const keyborgNativeFocusEvent = kwin.__keyborgData;\n\n  if (keyborgNativeFocusEvent) {\n    kwin.document.removeEventListener(\"focusin\", keyborgNativeFocusEvent.focusInHandler, true);\n    delete kwin.__keyborgData;\n  }\n\n  if (origFocus) {\n    proto.focus = origFocus;\n  }\n}\n/**\r\n * @param win The window that stores keyborg focus events\r\n * @returns The last element focused with element.focus()\r\n */\n\nfunction getLastFocusedProgrammatically(win) {\n  var _a;\n\n  const keyborgNativeFocusEvent = win.__keyborgData;\n  return keyborgNativeFocusEvent ? ((_a = keyborgNativeFocusEvent.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref()) || null : undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _dismissTimeout = 500; // When a key from dismissKeys is pressed and the focus is not moved\n// during _dismissTimeout time, dismiss the keyboard navigation mode.\n\nlet _lastId = 0;\n/**\r\n * Source of truth for all the keyborg core instances and the current keyboard navigation state\r\n */\n\nclass KeyborgState {\n  constructor() {\n    this.__keyborgCoreRefs = {};\n    this._isNavigatingWithKeyboard = false;\n  }\n\n  add(keyborg) {\n    const id = keyborg.id;\n\n    if (!(id in this.__keyborgCoreRefs)) {\n      this.__keyborgCoreRefs[id] = new WeakRefInstance(keyborg);\n    }\n  }\n\n  remove(id) {\n    delete this.__keyborgCoreRefs[id];\n\n    if (Object.keys(this.__keyborgCoreRefs).length === 0) {\n      this._isNavigatingWithKeyboard = false;\n    }\n  }\n\n  setVal(isNavigatingWithKeyboard) {\n    if (this._isNavigatingWithKeyboard === isNavigatingWithKeyboard) {\n      return;\n    }\n\n    this._isNavigatingWithKeyboard = isNavigatingWithKeyboard;\n\n    for (const id of Object.keys(this.__keyborgCoreRefs)) {\n      const ref = this.__keyborgCoreRefs[id];\n      const keyborg = ref.deref();\n\n      if (keyborg) {\n        keyborg.update(isNavigatingWithKeyboard);\n      } else {\n        this.remove(id);\n      }\n    }\n  }\n\n  getVal() {\n    return this._isNavigatingWithKeyboard;\n  }\n\n}\n\nconst _state = /*#__PURE__*/new KeyborgState();\n/**\r\n * Manages a collection of Keyborg instances in a window/document and updates keyborg state\r\n */\n\n\nclass KeyborgCore {\n  constructor(win, props) {\n    this._isMouseUsed = false;\n\n    this._onFocusIn = e => {\n      if (this._isMouseUsed) {\n        this._isMouseUsed = false;\n        return;\n      }\n\n      if (_state.getVal()) {\n        return;\n      }\n\n      const details = e.details;\n\n      if (!details.relatedTarget) {\n        return;\n      }\n\n      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === undefined) {\n        // The element is focused programmatically, or the programmatic focus detection\n        // is not working.\n        return;\n      }\n\n      _state.setVal(true);\n    };\n\n    this._onMouseDown = e => {\n      if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {\n        // This is most likely an event triggered by the screen reader to perform\n        // an action on an element, do not dismiss the keyboard navigation mode.\n        return;\n      }\n\n      this._isMouseUsed = true;\n\n      _state.setVal(false);\n    };\n\n    this._onKeyDown = e => {\n      var _a;\n\n      const isNavigatingWithKeyboard = _state.getVal();\n\n      const keyCode = e.keyCode;\n      const triggerKeys = this._triggerKeys;\n\n      if (!isNavigatingWithKeyboard && (!triggerKeys || triggerKeys.has(keyCode))) {\n        _state.setVal(true);\n      } else if (isNavigatingWithKeyboard && ((_a = this._dismissKeys) === null || _a === void 0 ? void 0 : _a.has(keyCode))) {\n        this._scheduleDismiss();\n      }\n    };\n\n    this.id = \"c\" + ++_lastId;\n    this._win = win;\n    const doc = win.document;\n\n    if (props) {\n      const triggerKeys = props.triggerKeys;\n      const dismissKeys = props.dismissKeys;\n\n      if (triggerKeys === null || triggerKeys === void 0 ? void 0 : triggerKeys.length) {\n        this._triggerKeys = new Set(triggerKeys);\n      }\n\n      if (dismissKeys === null || dismissKeys === void 0 ? void 0 : dismissKeys.length) {\n        this._dismissKeys = new Set(dismissKeys);\n      }\n    }\n\n    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n\n    doc.addEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n    setupFocusEvent(win);\n\n    _state.add(this);\n  }\n\n  dispose() {\n    const win = this._win;\n\n    if (win) {\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n\n      disposeFocusEvent(win);\n      const doc = win.document;\n      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!\n\n      doc.removeEventListener(\"mousedown\", this._onMouseDown, true); // Capture!\n\n      win.removeEventListener(\"keydown\", this._onKeyDown, true); // Capture!\n\n      delete this._win;\n\n      _state.remove(this.id);\n    }\n  }\n\n  isDisposed() {\n    return !!this._win;\n  }\n  /**\r\n   * Updates all keyborg instances with the keyboard navigation state\r\n   */\n\n\n  update(isNavigatingWithKeyboard) {\n    var _a, _b;\n\n    const keyborgs = (_b = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg) === null || _b === void 0 ? void 0 : _b.refs;\n\n    if (keyborgs) {\n      for (const id of Object.keys(keyborgs)) {\n        Keyborg.update(keyborgs[id], isNavigatingWithKeyboard);\n      }\n    }\n  }\n\n  _scheduleDismiss() {\n    const win = this._win;\n\n    if (win) {\n      if (this._dismissTimer) {\n        win.clearTimeout(this._dismissTimer);\n        this._dismissTimer = undefined;\n      }\n\n      const was = win.document.activeElement;\n      this._dismissTimer = win.setTimeout(() => {\n        this._dismissTimer = undefined;\n        const cur = win.document.activeElement;\n\n        if (was && cur && was === cur) {\n          // Esc was pressed, currently focused element hasn't changed.\n          // Just dismiss the keyboard navigation mode.\n          _state.setVal(false);\n        }\n      }, _dismissTimeout);\n    }\n  }\n\n}\n/**\r\n * Used to determine the keyboard navigation state\r\n */\n\n\nclass Keyborg {\n  constructor(win, props) {\n    this._cb = [];\n    this._id = \"k\" + ++_lastId;\n    this._win = win;\n    const current = win.__keyborg;\n\n    if (current) {\n      this._core = current.core;\n      current.refs[this._id] = this;\n    } else {\n      this._core = new KeyborgCore(win, props);\n      win.__keyborg = {\n        core: this._core,\n        refs: {\n          [this._id]: this\n        }\n      };\n    }\n  }\n\n  static create(win, props) {\n    return new Keyborg(win, props);\n  }\n\n  static dispose(instance) {\n    instance.dispose();\n  }\n  /**\r\n   * Updates all subscribed callbacks with the keyboard navigation state\r\n   */\n\n\n  static update(instance, isNavigatingWithKeyboard) {\n    instance._cb.forEach(callback => callback(isNavigatingWithKeyboard));\n  }\n\n  dispose() {\n    var _a;\n\n    const current = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg;\n\n    if (current === null || current === void 0 ? void 0 : current.refs[this._id]) {\n      delete current.refs[this._id];\n\n      if (Object.keys(current.refs).length === 0) {\n        current.core.dispose(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        delete this._win.__keyborg;\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Keyborg instance \" + this._id + \" is being disposed incorrectly.\");\n    }\n\n    this._cb = [];\n    delete this._core;\n    delete this._win;\n  }\n  /**\r\n   * @returns Whether the user is navigating with keyboard\r\n   */\n\n\n  isNavigatingWithKeyboard() {\n    return _state.getVal();\n  }\n  /**\r\n   * @param callback - Called when the keyboard navigation state changes\r\n   */\n\n\n  subscribe(callback) {\n    this._cb.push(callback);\n  }\n  /**\r\n   * @param callback - Registered with subscribe\r\n   */\n\n\n  unsubscribe(callback) {\n    const index = this._cb.indexOf(callback);\n\n    if (index >= 0) {\n      this._cb.splice(index, 1);\n    }\n  }\n  /**\r\n   * Manually set the keyboard navigtion state\r\n   */\n\n\n  setVal(isNavigatingWithKeyboard) {\n    _state.setVal(isNavigatingWithKeyboard);\n  }\n\n}\nfunction createKeyborg(win, props) {\n  return Keyborg.create(win, props);\n}\nfunction disposeKeyborg(instance) {\n  Keyborg.dispose(instance);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst version = \"2.0.0\";\n\nexport { KEYBORG_FOCUSIN, Keyborg, createKeyborg, disposeKeyborg, getLastFocusedProgrammatically, nativeFocus, version };\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}