{"ast":null,"code":"import { Enter, Space } from '@fluentui/keyboard-keys';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport * as React from 'react';\n/**\n * @internal\n *\n * Button keyboard handling, role, disabled and tabIndex implementation that ensures ARIA spec\n * for multiple scenarios of non native button elements. Ensuring 1st rule of ARIA for cases\n * where no attribute addition is required.\n *\n * @param type - the proper scenario to be interpreted by the hook.\n *  1. `button` - Minimal interference from the hook, as semantic button already supports most of the states\n *  2. `a` or `div` - Proper keyboard/mouse handling plus other support to ensure ARIA behavior\n * @param props - the props to be passed down the line to the desired element.\n * This hook will encapsulate proper properties, such as `onClick`, `onKeyDown`, `onKeyUp`, etc,.\n *\n * @example\n * ```tsx\n * const buttonProps = useARIAButtonProps('a', {\n *   href: './some-route'\n *   onClick: () => console.log('this should run both on click and Space and Enter')\n * })\n *\n * // ...\n *\n * return (\n *  <a {...buttonProps}>This anchor will behave as a proper button</a>\n * )\n * ```\n */\nexport function useARIAButtonProps(type, props) {\n  const {\n    disabled,\n    disabledFocusable = false,\n    ['aria-disabled']: ariaDisabled,\n    onClick,\n    onKeyDown,\n    onKeyUp,\n    ...rest\n  } = props !== null && props !== void 0 ? props : {};\n  const normalizedARIADisabled = typeof ariaDisabled === 'string' ? ariaDisabled === 'true' : ariaDisabled;\n  const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;\n  const handleClick = useEventCallback(ev => {\n    if (isDisabled) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else {\n      onClick === null || onClick === void 0 ? void 0 : onClick(ev);\n    }\n  });\n  const handleKeyDown = useEventCallback(ev => {\n    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n    const key = ev.key;\n    if (isDisabled && (key === Enter || key === Space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n      return;\n    }\n    if (key === Space) {\n      ev.preventDefault();\n      return;\n    } else if (key === Enter) {\n      ev.preventDefault();\n      ev.currentTarget.click();\n    }\n  });\n  const handleKeyUp = useEventCallback(ev => {\n    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n    const key = ev.key;\n    if (isDisabled && (key === Enter || key === Space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n      return;\n    }\n    if (key === Space) {\n      ev.preventDefault();\n      ev.currentTarget.click();\n    }\n  });\n  // If a <button> tag is to be rendered we just need to set disabled and aria-disabled correctly\n  if (type === 'button' || type === undefined) {\n    return {\n      ...rest,\n      disabled: disabled && !disabledFocusable,\n      'aria-disabled': disabledFocusable ? true : normalizedARIADisabled,\n      // onclick should still use internal handler to ensure prevention if disabled\n      // if disabledFocusable then there's no requirement for handlers as those events should not be propagated\n      onClick: disabledFocusable ? undefined : handleClick,\n      onKeyUp: disabledFocusable ? undefined : onKeyUp,\n      onKeyDown: disabledFocusable ? undefined : onKeyDown\n    };\n  } else {\n    const resultProps = {\n      role: 'button',\n      tabIndex: disabled && !disabledFocusable ? undefined : 0,\n      ...rest,\n      // If it's not a <button> than listeners are required even with disabledFocusable\n      // Since you cannot assure the default behavior of the element\n      // E.g: <a> will redirect on click\n      onClick: handleClick,\n      onKeyUp: handleKeyUp,\n      onKeyDown: handleKeyDown,\n      'aria-disabled': disabled || disabledFocusable || normalizedARIADisabled\n    };\n    if (type === 'a' && isDisabled) {\n      resultProps.href = undefined;\n    }\n    return resultProps;\n  }\n}","map":{"version":3,"names":["Enter","Space","useEventCallback","React","useARIAButtonProps","type","props","disabled","disabledFocusable","ariaDisabled","onClick","onKeyDown","onKeyUp","rest","normalizedARIADisabled","isDisabled","handleClick","ev","preventDefault","stopPropagation","handleKeyDown","isDefaultPrevented","key","currentTarget","click","handleKeyUp","undefined","resultProps","role","tabIndex","href"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js"],"sourcesContent":["import { Enter, Space } from '@fluentui/keyboard-keys';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport * as React from 'react';\n/**\n * @internal\n *\n * Button keyboard handling, role, disabled and tabIndex implementation that ensures ARIA spec\n * for multiple scenarios of non native button elements. Ensuring 1st rule of ARIA for cases\n * where no attribute addition is required.\n *\n * @param type - the proper scenario to be interpreted by the hook.\n *  1. `button` - Minimal interference from the hook, as semantic button already supports most of the states\n *  2. `a` or `div` - Proper keyboard/mouse handling plus other support to ensure ARIA behavior\n * @param props - the props to be passed down the line to the desired element.\n * This hook will encapsulate proper properties, such as `onClick`, `onKeyDown`, `onKeyUp`, etc,.\n *\n * @example\n * ```tsx\n * const buttonProps = useARIAButtonProps('a', {\n *   href: './some-route'\n *   onClick: () => console.log('this should run both on click and Space and Enter')\n * })\n *\n * // ...\n *\n * return (\n *  <a {...buttonProps}>This anchor will behave as a proper button</a>\n * )\n * ```\n */ export function useARIAButtonProps(type, props) {\n    const { disabled , disabledFocusable =false , ['aria-disabled']: ariaDisabled , onClick , onKeyDown , onKeyUp , ...rest } = props !== null && props !== void 0 ? props : {};\n    const normalizedARIADisabled = typeof ariaDisabled === 'string' ? ariaDisabled === 'true' : ariaDisabled;\n    const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;\n    const handleClick = useEventCallback((ev)=>{\n        if (isDisabled) {\n            ev.preventDefault();\n            ev.stopPropagation();\n        } else {\n            onClick === null || onClick === void 0 ? void 0 : onClick(ev);\n        }\n    });\n    const handleKeyDown = useEventCallback((ev)=>{\n        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);\n        if (ev.isDefaultPrevented()) {\n            return;\n        }\n        const key = ev.key;\n        if (isDisabled && (key === Enter || key === Space)) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            return;\n        }\n        if (key === Space) {\n            ev.preventDefault();\n            return;\n        } else if (key === Enter) {\n            ev.preventDefault();\n            ev.currentTarget.click();\n        }\n    });\n    const handleKeyUp = useEventCallback((ev)=>{\n        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);\n        if (ev.isDefaultPrevented()) {\n            return;\n        }\n        const key = ev.key;\n        if (isDisabled && (key === Enter || key === Space)) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            return;\n        }\n        if (key === Space) {\n            ev.preventDefault();\n            ev.currentTarget.click();\n        }\n    });\n    // If a <button> tag is to be rendered we just need to set disabled and aria-disabled correctly\n    if (type === 'button' || type === undefined) {\n        return {\n            ...rest,\n            disabled: disabled && !disabledFocusable,\n            'aria-disabled': disabledFocusable ? true : normalizedARIADisabled,\n            // onclick should still use internal handler to ensure prevention if disabled\n            // if disabledFocusable then there's no requirement for handlers as those events should not be propagated\n            onClick: disabledFocusable ? undefined : handleClick,\n            onKeyUp: disabledFocusable ? undefined : onKeyUp,\n            onKeyDown: disabledFocusable ? undefined : onKeyDown\n        };\n    } else {\n        const resultProps = {\n            role: 'button',\n            tabIndex: disabled && !disabledFocusable ? undefined : 0,\n            ...rest,\n            // If it's not a <button> than listeners are required even with disabledFocusable\n            // Since you cannot assure the default behavior of the element\n            // E.g: <a> will redirect on click\n            onClick: handleClick,\n            onKeyUp: handleKeyUp,\n            onKeyDown: handleKeyDown,\n            'aria-disabled': disabled || disabledFocusable || normalizedARIADisabled\n        };\n        if (type === 'a' && isDisabled) {\n            resultProps.href = undefined;\n        }\n        return resultProps;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}