{"ast":null,"code":"import hashString from '@emotion/hash';\nimport { convertProperty, convert } from 'rtl-css-js/core';\nimport { UNSUPPORTED_CSS_PROPERTIES, HASH_PREFIX } from '../constants.esm.js';\nimport { compileAtomicCSSRule } from './compileAtomicCSSRule.esm.js';\nimport { compileKeyframeRule, compileKeyframesCSS } from './compileKeyframeCSS.esm.js';\nimport { generateCombinedQuery } from './utils/generateCombinedMediaQuery.esm.js';\nimport { isMediaQuerySelector } from './utils/isMediaQuerySelector.esm.js';\nimport { isLayerSelector } from './utils/isLayerSelector.esm.js';\nimport { isNestedSelector } from './utils/isNestedSelector.esm.js';\nimport { isSupportQuerySelector } from './utils/isSupportQuerySelector.esm.js';\nimport { isContainerQuerySelector } from './utils/isContainerQuerySelector.esm.js';\nimport { normalizeNestedProperty } from './utils/normalizeNestedProperty.esm.js';\nimport { isObject } from './utils/isObject.esm.js';\nimport { getStyleBucketName } from './getStyleBucketName.esm.js';\nimport { hashClassName } from './utils/hashClassName.esm.js';\nimport { hashPropertyKey } from './utils/hashPropertyKey.esm.js';\nimport { warnAboutUnresolvedRule } from './warnings/warnAboutUnresolvedRule.esm.js';\nimport { warnAboutUnsupportedProperties } from './warnings/warnAboutUnsupportedProperties.esm.js';\nfunction pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {\n  classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;\n}\nfunction createBucketEntry(cssRule, metadata) {\n  if (metadata) {\n    return [cssRule, metadata];\n  }\n  return cssRule;\n}\nfunction pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media) {\n  var _a;\n  let metadata;\n  if (styleBucketName === 'm' && media) {\n    metadata = {\n      m: media\n    };\n  }\n  (_a = cssRulesByBucket[styleBucketName]) !== null && _a !== void 0 ? _a : cssRulesByBucket[styleBucketName] = [];\n  if (ltrCSS) {\n    cssRulesByBucket[styleBucketName].push(createBucketEntry(ltrCSS, metadata));\n  }\n  if (rtlCSS) {\n    cssRulesByBucket[styleBucketName].push(createBucketEntry(rtlCSS, metadata));\n  }\n}\n/**\r\n * Transforms input styles to classes maps & CSS rules.\r\n *\r\n * @internal\r\n */\nfunction resolveStyleRules(styles) {\n  let selectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let media = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let layer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  let support = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  let container = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';\n  let cssClassesMap = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  let cssRulesByBucket = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  let rtlValue = arguments.length > 8 ? arguments[8] : undefined;\n  // eslint-disable-next-line guard-for-in\n  for (const property in styles) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (UNSUPPORTED_CSS_PROPERTIES.hasOwnProperty(property)) {\n      warnAboutUnsupportedProperties(property, styles[property]);\n      continue;\n    }\n    const value = styles[property];\n    // eslint-disable-next-line eqeqeq\n    if (value == null) {\n      continue;\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n      // uniq key based on a hash of property & selector, used for merging later\n      const key = hashPropertyKey(selectors, container, media, support, property);\n      const className = hashClassName({\n        container,\n        media,\n        layer,\n        value: value.toString(),\n        support,\n        selectors,\n        property\n      });\n      const rtlDefinition = rtlValue && {\n        key: property,\n        value: rtlValue\n      } || convertProperty(property, value);\n      const flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;\n      const rtlClassName = flippedInRtl ? hashClassName({\n        container,\n        value: rtlDefinition.value.toString(),\n        property: rtlDefinition.key,\n        selectors,\n        media,\n        layer,\n        support\n      }) : undefined;\n      const rtlCompileOptions = flippedInRtl ? {\n        rtlClassName,\n        rtlProperty: rtlDefinition.key,\n        rtlValue: rtlDefinition.value\n      } : undefined;\n      const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);\n      const [ltrCSS, rtlCSS] = compileAtomicCSSRule({\n        className,\n        media,\n        layer,\n        selectors,\n        property,\n        support,\n        container,\n        value,\n        ...rtlCompileOptions\n      });\n      pushToClassesMap(cssClassesMap, key, className, rtlClassName);\n      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);\n    } else if (property === 'animationName') {\n      const animationNameValue = Array.isArray(value) ? value : [value];\n      const animationNames = [];\n      const rtlAnimationNames = [];\n      for (const keyframeObject of animationNameValue) {\n        const keyframeCSS = compileKeyframeRule(keyframeObject);\n        const rtlKeyframeCSS = compileKeyframeRule(convert(keyframeObject));\n        const animationName = HASH_PREFIX + hashString(keyframeCSS);\n        let rtlAnimationName;\n        const keyframeRules = compileKeyframesCSS(animationName, keyframeCSS);\n        let rtlKeyframeRules = [];\n        if (keyframeCSS === rtlKeyframeCSS) {\n          // If CSS for LTR & RTL are same we will re-use animationName from LTR to avoid duplication of rules in output\n          rtlAnimationName = animationName;\n        } else {\n          rtlAnimationName = HASH_PREFIX + hashString(rtlKeyframeCSS);\n          rtlKeyframeRules = compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);\n        }\n        for (let i = 0; i < keyframeRules.length; i++) {\n          pushToCSSRules(cssRulesByBucket,\n          // keyframes styles should be inserted into own bucket\n          'k', keyframeRules[i], rtlKeyframeRules[i], media);\n        }\n        animationNames.push(animationName);\n        rtlAnimationNames.push(rtlAnimationName);\n      }\n      resolveStyleRules({\n        animationName: animationNames.join(', ')\n      }, selectors, media, layer, support, container, cssClassesMap, cssRulesByBucket, rtlAnimationNames.join(', '));\n    } else if (Array.isArray(value)) {\n      // not animationName property but array in the value => fallback values\n      if (value.length === 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`makeStyles(): An empty array was passed as input to \"${property}\", the property will be omitted in the styles.`);\n        }\n        continue;\n      }\n      const key = hashPropertyKey(selectors, container, media, support, property);\n      const className = hashClassName({\n        container,\n        media,\n        layer,\n        value: value.map(v => (v !== null && v !== void 0 ? v : '').toString()).join(';'),\n        support,\n        selectors,\n        property\n      });\n      const rtlDefinitions = value.map(v => convertProperty(property, v));\n      const rtlPropertyConsistent = !rtlDefinitions.some(v => v.key !== rtlDefinitions[0].key);\n      if (!rtlPropertyConsistent) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error('makeStyles(): mixing CSS fallback values which result in multiple CSS properties in RTL is not supported.');\n        }\n        continue;\n      }\n      const flippedInRtl = rtlDefinitions[0].key !== property || rtlDefinitions.some((v, i) => v.value !== value[i]);\n      const rtlClassName = flippedInRtl ? hashClassName({\n        container,\n        value: rtlDefinitions.map(v => {\n          var _a;\n          return ((_a = v === null || v === void 0 ? void 0 : v.value) !== null && _a !== void 0 ? _a : '').toString();\n        }).join(';'),\n        property: rtlDefinitions[0].key,\n        selectors,\n        layer,\n        media,\n        support\n      }) : undefined;\n      const rtlCompileOptions = flippedInRtl ? {\n        rtlClassName,\n        rtlProperty: rtlDefinitions[0].key,\n        rtlValue: rtlDefinitions.map(d => d.value)\n      } : undefined;\n      const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);\n      const [ltrCSS, rtlCSS] = compileAtomicCSSRule({\n        className,\n        media,\n        layer,\n        selectors,\n        property,\n        support,\n        container,\n        value: value,\n        ...rtlCompileOptions\n      });\n      pushToClassesMap(cssClassesMap, key, className, rtlClassName);\n      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);\n    } else if (isObject(value)) {\n      if (isNestedSelector(property)) {\n        resolveStyleRules(value, selectors.concat(normalizeNestedProperty(property)), media, layer, support, container, cssClassesMap, cssRulesByBucket);\n      } else if (isMediaQuerySelector(property)) {\n        const combinedMediaQuery = generateCombinedQuery(media, property.slice(6).trim());\n        resolveStyleRules(value, selectors, combinedMediaQuery, layer, support, container, cssClassesMap, cssRulesByBucket);\n      } else if (isLayerSelector(property)) {\n        const combinedLayerQuery = (layer ? `${layer}.` : '') + property.slice(6).trim();\n        resolveStyleRules(value, selectors, media, combinedLayerQuery, support, container, cssClassesMap, cssRulesByBucket);\n      } else if (isSupportQuerySelector(property)) {\n        const combinedSupportQuery = generateCombinedQuery(support, property.slice(9).trim());\n        resolveStyleRules(value, selectors, media, layer, combinedSupportQuery, container, cssClassesMap, cssRulesByBucket);\n      } else if (isContainerQuerySelector(property)) {\n        // TODO implement nested container queries if needed\n        // The only way to target multiple containers is to nest container queries\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/@container#nested_container_queries\n        const containerQuery = property.slice(10).trim();\n        resolveStyleRules(value, selectors, media, layer, support, containerQuery, cssClassesMap, cssRulesByBucket);\n      } else {\n        warnAboutUnresolvedRule(property, value);\n      }\n    }\n  }\n  return [cssClassesMap, cssRulesByBucket];\n}\nexport { resolveStyleRules };","map":{"version":3,"names":["pushToClassesMap","classesMap","propertyKey","ltrClassname","rtlClassname","createBucketEntry","cssRule","metadata","pushToCSSRules","cssRulesByBucket","styleBucketName","ltrCSS","rtlCSS","media","m","_a","push","resolveStyleRules","styles","selectors","arguments","length","undefined","layer","support","container","cssClassesMap","rtlValue","property","UNSUPPORTED_CSS_PROPERTIES","hasOwnProperty","warnAboutUnsupportedProperties","value","key","hashPropertyKey","className","hashClassName","toString","rtlDefinition","convertProperty","flippedInRtl","rtlClassName","rtlCompileOptions","rtlProperty","getStyleBucketName","compileAtomicCSSRule","animationNameValue","Array","isArray","animationNames","rtlAnimationNames","keyframeObject","keyframeCSS","compileKeyframeRule","rtlKeyframeCSS","convert","animationName","HASH_PREFIX","hashString","rtlAnimationName","keyframeRules","compileKeyframesCSS","rtlKeyframeRules","i","join","process","env","NODE_ENV","console","warn","map","v","rtlDefinitions","rtlPropertyConsistent","some","error","d","isObject","isNestedSelector","concat","normalizeNestedProperty","isMediaQuerySelector","combinedMediaQuery","generateCombinedQuery","slice","trim","isLayerSelector","combinedLayerQuery","isSupportQuerySelector","combinedSupportQuery","isContainerQuerySelector","containerQuery","warnAboutUnresolvedRule"],"sources":["/Users/suketupatel/Desktop/application/frontend/packages/core/src/runtime/resolveStyleRules.ts"],"sourcesContent":["import hashString from '@emotion/hash';\nimport type { GriffelAnimation, GriffelStyle } from '@griffel/style-types';\nimport { convert, convertProperty } from 'rtl-css-js/core';\n\nimport { HASH_PREFIX, UNSUPPORTED_CSS_PROPERTIES } from '../constants';\nimport { CSSClassesMap, CSSRulesByBucket, StyleBucketName, CSSBucketEntry } from '../types';\nimport { compileAtomicCSSRule, CompileAtomicCSSOptions } from './compileAtomicCSSRule';\nimport { compileKeyframeRule, compileKeyframesCSS } from './compileKeyframeCSS';\nimport { generateCombinedQuery } from './utils/generateCombinedMediaQuery';\nimport { isMediaQuerySelector } from './utils/isMediaQuerySelector';\nimport { isLayerSelector } from './utils/isLayerSelector';\nimport { isNestedSelector } from './utils/isNestedSelector';\nimport { isSupportQuerySelector } from './utils/isSupportQuerySelector';\nimport { isContainerQuerySelector } from './utils/isContainerQuerySelector';\nimport { normalizeNestedProperty } from './utils/normalizeNestedProperty';\nimport { isObject } from './utils/isObject';\nimport { getStyleBucketName } from './getStyleBucketName';\nimport { hashClassName } from './utils/hashClassName';\nimport { hashPropertyKey } from './utils/hashPropertyKey';\nimport { warnAboutUnresolvedRule } from './warnings/warnAboutUnresolvedRule';\nimport { warnAboutUnsupportedProperties } from './warnings/warnAboutUnsupportedProperties';\n\nfunction pushToClassesMap(\n  classesMap: CSSClassesMap,\n  propertyKey: string,\n  ltrClassname: string,\n  rtlClassname: string | undefined,\n) {\n  classesMap[propertyKey] = rtlClassname ? [ltrClassname!, rtlClassname] : ltrClassname;\n}\n\nfunction createBucketEntry(cssRule: string, metadata: Record<string, unknown> | undefined): CSSBucketEntry {\n  if (metadata) {\n    return [cssRule, metadata];\n  }\n\n  return cssRule;\n}\n\nfunction pushToCSSRules(\n  cssRulesByBucket: CSSRulesByBucket,\n  styleBucketName: StyleBucketName,\n  ltrCSS: string | undefined,\n  rtlCSS: string | undefined,\n  media: string | undefined,\n) {\n  let metadata: Record<string, unknown> | undefined;\n  if (styleBucketName === 'm' && media) {\n    metadata = { m: media };\n  }\n\n  cssRulesByBucket[styleBucketName] ??= [];\n\n  if (ltrCSS) {\n    cssRulesByBucket[styleBucketName]!.push(createBucketEntry(ltrCSS, metadata));\n  }\n\n  if (rtlCSS) {\n    cssRulesByBucket[styleBucketName]!.push(createBucketEntry(rtlCSS, metadata));\n  }\n}\n\n/**\n * Transforms input styles to classes maps & CSS rules.\n *\n * @internal\n */\nexport function resolveStyleRules(\n  styles: GriffelStyle,\n  selectors: string[] = [],\n  media = '',\n  layer = '',\n  support = '',\n  container = '',\n  cssClassesMap: CSSClassesMap = {},\n  cssRulesByBucket: CSSRulesByBucket = {},\n  rtlValue?: string,\n): [CSSClassesMap, CSSRulesByBucket] {\n  // eslint-disable-next-line guard-for-in\n  for (const property in styles) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (UNSUPPORTED_CSS_PROPERTIES.hasOwnProperty(property)) {\n      warnAboutUnsupportedProperties(property, styles[property as keyof GriffelStyle]);\n      continue;\n    }\n\n    const value = styles[property as keyof GriffelStyle];\n\n    // eslint-disable-next-line eqeqeq\n    if (value == null) {\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number') {\n      // uniq key based on a hash of property & selector, used for merging later\n      const key = hashPropertyKey(selectors, container, media, support, property);\n      const className = hashClassName({\n        container,\n        media,\n        layer,\n        value: value.toString(),\n        support,\n        selectors,\n        property,\n      });\n\n      const rtlDefinition = (rtlValue && { key: property, value: rtlValue }) || convertProperty(property, value);\n      const flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;\n\n      const rtlClassName = flippedInRtl\n        ? hashClassName({\n            container,\n            value: rtlDefinition.value.toString(),\n            property: rtlDefinition.key,\n            selectors,\n            media,\n            layer,\n            support,\n          })\n        : undefined;\n      const rtlCompileOptions: Partial<CompileAtomicCSSOptions> | undefined = flippedInRtl\n        ? {\n            rtlClassName,\n            rtlProperty: rtlDefinition.key,\n            rtlValue: rtlDefinition.value,\n          }\n        : undefined;\n\n      const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);\n      const [ltrCSS, rtlCSS] = compileAtomicCSSRule({\n        className,\n        media,\n        layer,\n        selectors,\n        property,\n        support,\n        container,\n        value,\n        ...rtlCompileOptions,\n      });\n\n      pushToClassesMap(cssClassesMap, key, className, rtlClassName);\n      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);\n    } else if (property === 'animationName') {\n      const animationNameValue = Array.isArray(value) ? (value as GriffelAnimation[]) : [value as GriffelAnimation];\n\n      const animationNames: string[] = [];\n      const rtlAnimationNames: string[] = [];\n\n      for (const keyframeObject of animationNameValue) {\n        const keyframeCSS = compileKeyframeRule(keyframeObject);\n        const rtlKeyframeCSS = compileKeyframeRule(convert(keyframeObject));\n\n        const animationName = HASH_PREFIX + hashString(keyframeCSS);\n        let rtlAnimationName: string;\n\n        const keyframeRules = compileKeyframesCSS(animationName, keyframeCSS);\n        let rtlKeyframeRules: string[] = [];\n\n        if (keyframeCSS === rtlKeyframeCSS) {\n          // If CSS for LTR & RTL are same we will re-use animationName from LTR to avoid duplication of rules in output\n          rtlAnimationName = animationName;\n        } else {\n          rtlAnimationName = HASH_PREFIX + hashString(rtlKeyframeCSS);\n          rtlKeyframeRules = compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);\n        }\n\n        for (let i = 0; i < keyframeRules.length; i++) {\n          pushToCSSRules(\n            cssRulesByBucket,\n            // keyframes styles should be inserted into own bucket\n            'k',\n            keyframeRules[i],\n            rtlKeyframeRules[i],\n            media,\n          );\n        }\n\n        animationNames.push(animationName);\n        rtlAnimationNames.push(rtlAnimationName);\n      }\n\n      resolveStyleRules(\n        { animationName: animationNames.join(', ') },\n        selectors,\n        media,\n        layer,\n        support,\n        container,\n        cssClassesMap,\n        cssRulesByBucket,\n        rtlAnimationNames.join(', '),\n      );\n    } else if (Array.isArray(value)) {\n      // not animationName property but array in the value => fallback values\n      if (value.length === 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `makeStyles(): An empty array was passed as input to \"${property}\", the property will be omitted in the styles.`,\n          );\n        }\n        continue;\n      }\n\n      const key = hashPropertyKey(selectors, container, media, support, property);\n      const className = hashClassName({\n        container,\n        media,\n        layer,\n        value: value.map(v => (v ?? '').toString()).join(';'),\n        support,\n        selectors,\n        property,\n      });\n\n      const rtlDefinitions = value.map(v => convertProperty(property, v!));\n\n      const rtlPropertyConsistent = !rtlDefinitions.some(v => v.key !== rtlDefinitions[0].key);\n\n      if (!rtlPropertyConsistent) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(\n            'makeStyles(): mixing CSS fallback values which result in multiple CSS properties in RTL is not supported.',\n          );\n        }\n        continue;\n      }\n\n      const flippedInRtl = rtlDefinitions[0].key !== property || rtlDefinitions.some((v, i) => v.value !== value[i]);\n\n      const rtlClassName = flippedInRtl\n        ? hashClassName({\n            container,\n            value: rtlDefinitions.map(v => (v?.value ?? '').toString()).join(';'),\n            property: rtlDefinitions[0].key,\n            selectors,\n            layer,\n            media,\n            support,\n          })\n        : undefined;\n\n      const rtlCompileOptions: Partial<CompileAtomicCSSOptions> | undefined = flippedInRtl\n        ? {\n            rtlClassName,\n            rtlProperty: rtlDefinitions[0].key,\n            rtlValue: rtlDefinitions.map(d => d.value) as Array<string | number>,\n          }\n        : undefined;\n\n      const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);\n      const [ltrCSS, rtlCSS] = compileAtomicCSSRule({\n        className,\n        media,\n        layer,\n        selectors,\n        property,\n        support,\n        container,\n        value: value as Array<string | number>,\n        ...rtlCompileOptions,\n      });\n\n      pushToClassesMap(cssClassesMap, key, className, rtlClassName);\n      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);\n    } else if (isObject(value)) {\n      if (isNestedSelector(property)) {\n        resolveStyleRules(\n          value as GriffelStyle,\n          selectors.concat(normalizeNestedProperty(property)),\n          media,\n          layer,\n          support,\n          container,\n          cssClassesMap,\n          cssRulesByBucket,\n        );\n      } else if (isMediaQuerySelector(property)) {\n        const combinedMediaQuery = generateCombinedQuery(media, property.slice(6).trim());\n\n        resolveStyleRules(\n          value as GriffelStyle,\n          selectors,\n          combinedMediaQuery,\n          layer,\n          support,\n          container,\n          cssClassesMap,\n          cssRulesByBucket,\n        );\n      } else if (isLayerSelector(property)) {\n        const combinedLayerQuery = (layer ? `${layer}.` : '') + property.slice(6).trim();\n\n        resolveStyleRules(\n          value as GriffelStyle,\n          selectors,\n          media,\n          combinedLayerQuery,\n          support,\n          container,\n          cssClassesMap,\n          cssRulesByBucket,\n        );\n      } else if (isSupportQuerySelector(property)) {\n        const combinedSupportQuery = generateCombinedQuery(support, property.slice(9).trim());\n\n        resolveStyleRules(\n          value as GriffelStyle,\n          selectors,\n          media,\n          layer,\n          combinedSupportQuery,\n          container,\n          cssClassesMap,\n          cssRulesByBucket,\n        );\n      } else if (isContainerQuerySelector(property)) {\n        // TODO implement nested container queries if needed\n        // The only way to target multiple containers is to nest container queries\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/@container#nested_container_queries\n        const containerQuery = property.slice(10).trim();\n\n        resolveStyleRules(\n          value as GriffelStyle,\n          selectors,\n          media,\n          layer,\n          support,\n          containerQuery,\n          cssClassesMap,\n          cssRulesByBucket,\n        );\n      } else {\n        warnAboutUnresolvedRule(property, value);\n      }\n    }\n  }\n\n  return [cssClassesMap, cssRulesByBucket];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}