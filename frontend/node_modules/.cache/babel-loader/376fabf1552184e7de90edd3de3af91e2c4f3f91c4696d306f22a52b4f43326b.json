{"ast":null,"code":"import * as React from 'react';\nimport { createPriorityQueue } from '@fluentui/react-utilities';\nfunction assignDefined(a, b) {\n  // This cast is required, as Object.entries will return string as key which is not indexable\n  for (const [key, prop] of Object.entries(b)) {\n    // eslint-disable-next-line eqeqeq\n    if (prop != undefined) {\n      a[key] = prop;\n    }\n  }\n}\nconst defaulToastOptions = {\n  onStatusChange: undefined,\n  priority: 0,\n  pauseOnHover: false,\n  pauseOnWindowBlur: false,\n  position: 'bottom-end',\n  timeout: 3000\n};\n// Multiple toasts can be dispatched in a single tick, use counter to prevent collisions\nlet counter = 0;\n/**\n * Toast are managed outside of the react lifecycle because they can be\n * dispatched imperatively. Therefore the state of toast visibility can't\n * really be managed properly by a declarative lifecycle.\n */\nexport function createToaster(options) {\n  const {\n    limit = Number.POSITIVE_INFINITY\n  } = options;\n  const visibleToasts = new Set();\n  const toasts = new Map();\n  const queue = createPriorityQueue((ta, tb) => {\n    const a = toasts.get(ta);\n    const b = toasts.get(tb);\n    if (!a || !b) {\n      return 0;\n    }\n    if (a.priority === b.priority) {\n      return a.order - b.order;\n    }\n    return a.priority - b.priority;\n  });\n  const isToastVisible = toastId => {\n    return visibleToasts.has(toastId);\n  };\n  /**\n  * Updates an existing toast with any available option\n  */\n  const updateToast = toastOptions => {\n    const {\n      toastId\n    } = toastOptions;\n    const toastToUpdate = toasts.get(toastId);\n    if (!toastToUpdate) {\n      return;\n    }\n    Object.assign(toastToUpdate, toastOptions);\n    toastToUpdate.updateId++;\n  };\n  /**\n  * Dismisses a toast with a specific id\n  */\n  const dismissToast = toastId => {\n    visibleToasts.delete(toastId);\n  };\n  /**\n  * Dismisses all toasts and clears the queue\n  */\n  const dismissAllToasts = () => {\n    visibleToasts.clear();\n    queue.clear();\n  };\n  /**\n  * @param toastOptions user configured options\n  * @param onUpdate Some toast methods can result in UI changes (i.e. close) use this to dispatch callbacks\n  */\n  const buildToast = (toastOptions, onUpdate) => {\n    var _toast_onStatusChange;\n    const {\n      toastId,\n      content,\n      toasterId\n    } = toastOptions;\n    if (toasts.has(toastId)) {\n      return;\n    }\n    const close = () => {\n      var _toast_onStatusChange;\n      const toast = toasts.get(toastId);\n      if (!toast) {\n        return;\n      }\n      visibleToasts.delete(toastId);\n      onUpdate();\n      (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n        status: 'dismissed',\n        ...toast\n      });\n    };\n    const remove = () => {\n      const toast = toasts.get(toastId);\n      if (!toast) {\n        return;\n      }\n      toasts.delete(toastId);\n      if (visibleToasts.size < limit && queue.peek()) {\n        const nextToast = toasts.get(queue.dequeue());\n        if (!nextToast) {\n          return;\n        }\n        visibleToasts.add(nextToast.toastId);\n      }\n      onUpdate();\n    };\n    const toast = {\n      ...defaulToastOptions,\n      close,\n      remove,\n      toastId,\n      content,\n      updateId: 0,\n      toasterId,\n      order: counter++,\n      data: {},\n      imperativeRef: React.createRef()\n    };\n    assignDefined(toast, options);\n    assignDefined(toast, toastOptions);\n    toasts.set(toastId, toast);\n    (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n      status: 'queued',\n      ...toast\n    });\n    if (visibleToasts.size >= limit) {\n      queue.enqueue(toastId);\n    } else {\n      visibleToasts.add(toastId);\n    }\n  };\n  return {\n    buildToast,\n    dismissAllToasts,\n    dismissToast,\n    isToastVisible,\n    updateToast,\n    visibleToasts,\n    toasts\n  };\n}","map":{"version":3,"names":["React","createPriorityQueue","assignDefined","a","b","key","prop","Object","entries","undefined","defaulToastOptions","onStatusChange","priority","pauseOnHover","pauseOnWindowBlur","position","timeout","counter","createToaster","options","limit","Number","POSITIVE_INFINITY","visibleToasts","Set","toasts","Map","queue","ta","tb","get","order","isToastVisible","toastId","has","updateToast","toastOptions","toastToUpdate","assign","updateId","dismissToast","delete","dismissAllToasts","clear","buildToast","onUpdate","_toast_onStatusChange","content","toasterId","close","toast","call","status","remove","size","peek","nextToast","dequeue","add","data","imperativeRef","createRef","set","enqueue"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-toast/lib/state/vanilla/createToaster.js"],"sourcesContent":["import * as React from 'react';\nimport { createPriorityQueue } from '@fluentui/react-utilities';\nfunction assignDefined(a, b) {\n    // This cast is required, as Object.entries will return string as key which is not indexable\n    for (const [key, prop] of Object.entries(b)){\n        // eslint-disable-next-line eqeqeq\n        if (prop != undefined) {\n            a[key] = prop;\n        }\n    }\n}\nconst defaulToastOptions = {\n    onStatusChange: undefined,\n    priority: 0,\n    pauseOnHover: false,\n    pauseOnWindowBlur: false,\n    position: 'bottom-end',\n    timeout: 3000\n};\n// Multiple toasts can be dispatched in a single tick, use counter to prevent collisions\nlet counter = 0;\n/**\n * Toast are managed outside of the react lifecycle because they can be\n * dispatched imperatively. Therefore the state of toast visibility can't\n * really be managed properly by a declarative lifecycle.\n */ export function createToaster(options) {\n    const { limit =Number.POSITIVE_INFINITY  } = options;\n    const visibleToasts = new Set();\n    const toasts = new Map();\n    const queue = createPriorityQueue((ta, tb)=>{\n        const a = toasts.get(ta);\n        const b = toasts.get(tb);\n        if (!a || !b) {\n            return 0;\n        }\n        if (a.priority === b.priority) {\n            return a.order - b.order;\n        }\n        return a.priority - b.priority;\n    });\n    const isToastVisible = (toastId)=>{\n        return visibleToasts.has(toastId);\n    };\n    /**\n   * Updates an existing toast with any available option\n   */ const updateToast = (toastOptions)=>{\n        const { toastId  } = toastOptions;\n        const toastToUpdate = toasts.get(toastId);\n        if (!toastToUpdate) {\n            return;\n        }\n        Object.assign(toastToUpdate, toastOptions);\n        toastToUpdate.updateId++;\n    };\n    /**\n   * Dismisses a toast with a specific id\n   */ const dismissToast = (toastId)=>{\n        visibleToasts.delete(toastId);\n    };\n    /**\n   * Dismisses all toasts and clears the queue\n   */ const dismissAllToasts = ()=>{\n        visibleToasts.clear();\n        queue.clear();\n    };\n    /**\n   * @param toastOptions user configured options\n   * @param onUpdate Some toast methods can result in UI changes (i.e. close) use this to dispatch callbacks\n   */ const buildToast = (toastOptions, onUpdate)=>{\n        var _toast_onStatusChange;\n        const { toastId , content , toasterId  } = toastOptions;\n        if (toasts.has(toastId)) {\n            return;\n        }\n        const close = ()=>{\n            var _toast_onStatusChange;\n            const toast = toasts.get(toastId);\n            if (!toast) {\n                return;\n            }\n            visibleToasts.delete(toastId);\n            onUpdate();\n            (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n                status: 'dismissed',\n                ...toast\n            });\n        };\n        const remove = ()=>{\n            const toast = toasts.get(toastId);\n            if (!toast) {\n                return;\n            }\n            toasts.delete(toastId);\n            if (visibleToasts.size < limit && queue.peek()) {\n                const nextToast = toasts.get(queue.dequeue());\n                if (!nextToast) {\n                    return;\n                }\n                visibleToasts.add(nextToast.toastId);\n            }\n            onUpdate();\n        };\n        const toast = {\n            ...defaulToastOptions,\n            close,\n            remove,\n            toastId,\n            content,\n            updateId: 0,\n            toasterId,\n            order: counter++,\n            data: {},\n            imperativeRef: React.createRef()\n        };\n        assignDefined(toast, options);\n        assignDefined(toast, toastOptions);\n        toasts.set(toastId, toast);\n        (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {\n            status: 'queued',\n            ...toast\n        });\n        if (visibleToasts.size >= limit) {\n            queue.enqueue(toastId);\n        } else {\n            visibleToasts.add(toastId);\n        }\n    };\n    return {\n        buildToast,\n        dismissAllToasts,\n        dismissToast,\n        isToastVisible,\n        updateToast,\n        visibleToasts,\n        toasts\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}