{"ast":null,"code":"import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport { useTooltipVisibility_unstable as useTooltipVisibility, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { applyTriggerPropsToChildren, resolveShorthand, useControllableState, useId, useIsomorphicLayoutEffect, useIsSSR, useMergedRefs, useTimeout, getTriggerChild, mergeCallbacks, useEventCallback } from '@fluentui/react-utilities';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */\nexport const useTooltip_unstable = props => {\n  var _child_props, _child_props1, _child_props2, _child_props3;\n  const context = useTooltipVisibility();\n  const isServerSideRender = useIsSSR();\n  const {\n    targetDocument\n  } = useFluent();\n  const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n  const {\n    appearance = 'normal',\n    children,\n    content,\n    withArrow = false,\n    positioning = 'above',\n    onVisibleChange,\n    relationship,\n    showDelay = 250,\n    hideDelay = 250,\n    mountNode\n  } = props;\n  const [visible, setVisibleInternal] = useControllableState({\n    state: props.visible,\n    initialState: false\n  });\n  const setVisible = React.useCallback((newVisible, ev) => {\n    clearDelayTimeout();\n    setVisibleInternal(oldVisible => {\n      if (newVisible !== oldVisible) {\n        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, {\n          visible: newVisible\n        });\n      }\n      return newVisible;\n    });\n  }, [clearDelayTimeout, setVisibleInternal, onVisibleChange]);\n  const state = {\n    withArrow,\n    positioning,\n    showDelay,\n    hideDelay,\n    relationship,\n    visible,\n    shouldRenderTooltip: visible,\n    appearance,\n    mountNode,\n    // Slots\n    components: {\n      content: 'div'\n    },\n    content: resolveShorthand(content, {\n      defaultProps: {\n        role: 'tooltip'\n      },\n      required: true\n    })\n  };\n  state.content.id = useId('tooltip-', state.content.id);\n  const positioningOptions = {\n    enabled: state.visible,\n    arrowPadding: 2 * tooltipBorderRadius,\n    position: 'above',\n    align: 'center',\n    offset: 4,\n    ...resolvePositioningShorthand(state.positioning)\n  };\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n  }\n  const {\n    targetRef,\n    containerRef,\n    arrowRef\n  } = usePositioning(positioningOptions);\n  state.content.ref = useMergedRefs(state.content.ref, containerRef);\n  state.arrowRef = arrowRef;\n  // When this tooltip is visible, hide any other tooltips, and register it\n  // as the visibleTooltip with the TooltipContext.\n  // Also add a listener on document to hide the tooltip if Escape is pressed\n  useIsomorphicLayoutEffect(() => {\n    if (visible) {\n      var _context_visibleTooltip;\n      const thisTooltip = {\n        hide: () => setVisible(false)\n      };\n      (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();\n      context.visibleTooltip = thisTooltip;\n      const onDocumentKeyDown = ev => {\n        if (ev.key === Escape) {\n          thisTooltip.hide();\n          // stop propagation to avoid conflicting with other elements that listen for `Escape`\n          // e,g: Dialog, Popover, Menu\n          ev.stopPropagation();\n        }\n      };\n      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown, {\n        // As this event is added at targeted document,\n        // we need to capture the event to be sure keydown handling from tooltip happens first\n        capture: true\n      });\n      return () => {\n        if (context.visibleTooltip === thisTooltip) {\n          context.visibleTooltip = undefined;\n        }\n        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown, {\n          capture: true\n        });\n      };\n    }\n  }, [context, targetDocument, visible, setVisible]);\n  // The focused element gets a blur event when the document loses focus\n  // (e.g. switching tabs in the browser), but we don't want to show the\n  // tooltip again when the document gets focus back. Handle this case by\n  // checking if the blurred element is still the document's activeElement.\n  // See https://github.com/microsoft/fluentui/issues/13541\n  const ignoreNextFocusEventRef = React.useRef(false);\n  // Listener for onPointerEnter and onFocus on the trigger element\n  const onEnterTrigger = React.useCallback(ev => {\n    if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n      ignoreNextFocusEventRef.current = false;\n      return;\n    }\n    // Show immediately if another tooltip is already visible\n    const delay = context.visibleTooltip ? 0 : state.showDelay;\n    setDelayTimeout(() => {\n      setVisible(true, ev);\n    }, delay);\n    ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n  }, [setDelayTimeout, setVisible, state.showDelay, context]);\n  // Listener for onPointerLeave and onBlur on the trigger element\n  const onLeaveTrigger = React.useCallback(ev => {\n    let delay = state.hideDelay;\n    if (ev.type === 'blur') {\n      // Hide immediately when losing focus\n      delay = 0;\n      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;\n    }\n    setDelayTimeout(() => {\n      setVisible(false, ev);\n    }, delay);\n    ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n  }, [setDelayTimeout, setVisible, state.hideDelay, targetDocument]);\n  // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n  const child = getTriggerChild(children);\n  const triggerAriaProps = {};\n  if (relationship === 'label') {\n    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n    if (typeof state.content.children === 'string') {\n      triggerAriaProps['aria-label'] = state.content.children;\n    } else {\n      triggerAriaProps['aria-labelledby'] = state.content.id;\n      // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n      state.shouldRenderTooltip = true;\n    }\n  } else if (relationship === 'description') {\n    triggerAriaProps['aria-describedby'] = state.content.id;\n    // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n    state.shouldRenderTooltip = true;\n  }\n  // Don't render the Tooltip in SSR to avoid hydration errors\n  if (isServerSideRender) {\n    state.shouldRenderTooltip = false;\n  }\n  const childTargetRef = useMergedRefs(child === null || child === void 0 ? void 0 : child.ref, targetRef);\n  // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n  state.children = applyTriggerPropsToChildren(children, {\n    ...triggerAriaProps,\n    ...(child === null || child === void 0 ? void 0 : child.props),\n    // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n    ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref,\n    onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.onPointerEnter, onEnterTrigger)),\n    onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.onPointerLeave, onLeaveTrigger)),\n    onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onFocus, onEnterTrigger)),\n    onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onBlur, onLeaveTrigger))\n  });\n  return state;\n};","map":{"version":3,"names":["React","mergeArrowOffset","resolvePositioningShorthand","usePositioning","useTooltipVisibility_unstable","useTooltipVisibility","useFluent_unstable","useFluent","applyTriggerPropsToChildren","resolveShorthand","useControllableState","useId","useIsomorphicLayoutEffect","useIsSSR","useMergedRefs","useTimeout","getTriggerChild","mergeCallbacks","useEventCallback","arrowHeight","tooltipBorderRadius","Escape","useTooltip_unstable","props","_child_props","_child_props1","_child_props2","_child_props3","context","isServerSideRender","targetDocument","setDelayTimeout","clearDelayTimeout","appearance","children","content","withArrow","positioning","onVisibleChange","relationship","showDelay","hideDelay","mountNode","visible","setVisibleInternal","state","initialState","setVisible","useCallback","newVisible","ev","oldVisible","shouldRenderTooltip","components","defaultProps","role","required","id","positioningOptions","enabled","arrowPadding","position","align","offset","targetRef","containerRef","arrowRef","ref","_context_visibleTooltip","thisTooltip","hide","visibleTooltip","onDocumentKeyDown","key","stopPropagation","addEventListener","capture","undefined","removeEventListener","ignoreNextFocusEventRef","useRef","onEnterTrigger","type","current","delay","persist","onLeaveTrigger","activeElement","target","onPointerEnter","onPointerLeave","onFocus","onBlur","child","triggerAriaProps","childTargetRef"],"sources":["/Users/suketupatel/Desktop/application/frontend/node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js"],"sourcesContent":["import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport { useTooltipVisibility_unstable as useTooltipVisibility, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { applyTriggerPropsToChildren, resolveShorthand, useControllableState, useId, useIsomorphicLayoutEffect, useIsSSR, useMergedRefs, useTimeout, getTriggerChild, mergeCallbacks, useEventCallback } from '@fluentui/react-utilities';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */ export const useTooltip_unstable = (props)=>{\n    var _child_props, _child_props1, _child_props2, _child_props3;\n    const context = useTooltipVisibility();\n    const isServerSideRender = useIsSSR();\n    const { targetDocument  } = useFluent();\n    const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n    const { appearance ='normal' , children , content , withArrow =false , positioning ='above' , onVisibleChange , relationship , showDelay =250 , hideDelay =250 , mountNode  } = props;\n    const [visible, setVisibleInternal] = useControllableState({\n        state: props.visible,\n        initialState: false\n    });\n    const setVisible = React.useCallback((newVisible, ev)=>{\n        clearDelayTimeout();\n        setVisibleInternal((oldVisible)=>{\n            if (newVisible !== oldVisible) {\n                onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, {\n                    visible: newVisible\n                });\n            }\n            return newVisible;\n        });\n    }, [\n        clearDelayTimeout,\n        setVisibleInternal,\n        onVisibleChange\n    ]);\n    const state = {\n        withArrow,\n        positioning,\n        showDelay,\n        hideDelay,\n        relationship,\n        visible,\n        shouldRenderTooltip: visible,\n        appearance,\n        mountNode,\n        // Slots\n        components: {\n            content: 'div'\n        },\n        content: resolveShorthand(content, {\n            defaultProps: {\n                role: 'tooltip'\n            },\n            required: true\n        })\n    };\n    state.content.id = useId('tooltip-', state.content.id);\n    const positioningOptions = {\n        enabled: state.visible,\n        arrowPadding: 2 * tooltipBorderRadius,\n        position: 'above',\n        align: 'center',\n        offset: 4,\n        ...resolvePositioningShorthand(state.positioning)\n    };\n    if (state.withArrow) {\n        positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n    }\n    const { targetRef , containerRef , arrowRef  } = usePositioning(positioningOptions);\n    state.content.ref = useMergedRefs(state.content.ref, containerRef);\n    state.arrowRef = arrowRef;\n    // When this tooltip is visible, hide any other tooltips, and register it\n    // as the visibleTooltip with the TooltipContext.\n    // Also add a listener on document to hide the tooltip if Escape is pressed\n    useIsomorphicLayoutEffect(()=>{\n        if (visible) {\n            var _context_visibleTooltip;\n            const thisTooltip = {\n                hide: ()=>setVisible(false)\n            };\n            (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();\n            context.visibleTooltip = thisTooltip;\n            const onDocumentKeyDown = (ev)=>{\n                if (ev.key === Escape) {\n                    thisTooltip.hide();\n                    // stop propagation to avoid conflicting with other elements that listen for `Escape`\n                    // e,g: Dialog, Popover, Menu\n                    ev.stopPropagation();\n                }\n            };\n            targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown, {\n                // As this event is added at targeted document,\n                // we need to capture the event to be sure keydown handling from tooltip happens first\n                capture: true\n            });\n            return ()=>{\n                if (context.visibleTooltip === thisTooltip) {\n                    context.visibleTooltip = undefined;\n                }\n                targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown, {\n                    capture: true\n                });\n            };\n        }\n    }, [\n        context,\n        targetDocument,\n        visible,\n        setVisible\n    ]);\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    const ignoreNextFocusEventRef = React.useRef(false);\n    // Listener for onPointerEnter and onFocus on the trigger element\n    const onEnterTrigger = React.useCallback((ev)=>{\n        if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n            ignoreNextFocusEventRef.current = false;\n            return;\n        }\n        // Show immediately if another tooltip is already visible\n        const delay = context.visibleTooltip ? 0 : state.showDelay;\n        setDelayTimeout(()=>{\n            setVisible(true, ev);\n        }, delay);\n        ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    }, [\n        setDelayTimeout,\n        setVisible,\n        state.showDelay,\n        context\n    ]);\n    // Listener for onPointerLeave and onBlur on the trigger element\n    const onLeaveTrigger = React.useCallback((ev)=>{\n        let delay = state.hideDelay;\n        if (ev.type === 'blur') {\n            // Hide immediately when losing focus\n            delay = 0;\n            ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;\n        }\n        setDelayTimeout(()=>{\n            setVisible(false, ev);\n        }, delay);\n        ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    }, [\n        setDelayTimeout,\n        setVisible,\n        state.hideDelay,\n        targetDocument\n    ]);\n    // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n    // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n    state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n    state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n    state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n    state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n    const child = getTriggerChild(children);\n    const triggerAriaProps = {};\n    if (relationship === 'label') {\n        // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n        if (typeof state.content.children === 'string') {\n            triggerAriaProps['aria-label'] = state.content.children;\n        } else {\n            triggerAriaProps['aria-labelledby'] = state.content.id;\n            // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n            state.shouldRenderTooltip = true;\n        }\n    } else if (relationship === 'description') {\n        triggerAriaProps['aria-describedby'] = state.content.id;\n        // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n        state.shouldRenderTooltip = true;\n    }\n    // Don't render the Tooltip in SSR to avoid hydration errors\n    if (isServerSideRender) {\n        state.shouldRenderTooltip = false;\n    }\n    const childTargetRef = useMergedRefs(child === null || child === void 0 ? void 0 : child.ref, targetRef);\n    // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n    state.children = applyTriggerPropsToChildren(children, {\n        ...triggerAriaProps,\n        ...child === null || child === void 0 ? void 0 : child.props,\n        // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n        ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref,\n        onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.onPointerEnter, onEnterTrigger)),\n        onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.onPointerLeave, onLeaveTrigger)),\n        onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onFocus, onEnterTrigger)),\n        onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onBlur, onLeaveTrigger))\n    });\n    return state;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}