{"version":3,"sources":["useFieldControlProps.ts"],"sourcesContent":["import type { FieldContextValue, FieldControlProps } from '../Field';\nimport { useFieldContext_unstable } from './FieldContext';\n\n/**\n * Options for `useFieldControlProps_unstable`.\n */\nexport type FieldControlPropsOptions = {\n  /**\n   * Skips setting `aria-labelledby` on the control if the `label.htmlFor` refers to the control.\n   *\n   * This should be used with controls that can be the target of a label's `for` prop:\n   * `<button>`, `<input>`, `<progress>`, `<select>`, `<textarea>`.\n   */\n  supportsLabelFor?: boolean;\n\n  /**\n   * Sets `required` instead of `aria-required` when the Field is marked required.\n   *\n   * This should be used with controls that support the `required` prop:\n   * `<input>` (except `range` or `color`), `<select>`, `<textarea>`.\n   */\n  supportsRequired?: boolean;\n\n  /**\n   * Sets the size prop on the control to match the Field's size: `'small' | 'medium' | 'large'`.\n   *\n   * This should be used with controls that have a custom size prop that matches the Field's size prop.\n   */\n  supportsSize?: boolean;\n};\n\n/**\n * Gets the control props from the field context, if this inside a `<Field>`.\n *\n * When called with no arguments, returns the FieldControlProps that should be applied to the control.\n *\n * @returns A FieldControlProps object if inside a `<Field>`, otherwise undefined.\n */\nexport function useFieldControlProps_unstable(): FieldControlProps | undefined;\n\n/**\n * Copies and merges the FieldControlProps with the given props, if this inside a `<Field>`.\n *\n * @param props - The existing props for the control. These will be merged with the control props from the field context.\n * @param options - Option to include the size prop.\n * @returns Merged props if inside a `<Field>`, otherwise the original props, or undefined if no props given.\n */\nexport function useFieldControlProps_unstable<Props extends FieldControlProps>(\n  props: Props,\n  options?: FieldControlPropsOptions,\n): Props;\nexport function useFieldControlProps_unstable<Props extends FieldControlProps>(\n  props?: Props,\n  options?: FieldControlPropsOptions,\n): Props | undefined {\n  return getFieldControlProps(useFieldContext_unstable(), props, options);\n}\n\n/**\n * @internal\n * Implementation of useFieldControlProps_unstable.\n * Split out so it can be used directly in renderField_unstable.\n */\nexport function getFieldControlProps<Props extends FieldControlProps>(\n  context: FieldContextValue | undefined,\n  props?: Props,\n  options?: FieldControlPropsOptions,\n): Props | undefined {\n  if (!context) {\n    return props;\n  }\n\n  // Create a copy of props so we don't modify the original\n  props = { ...props } as Props;\n\n  const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;\n\n  if (generatedControlId) {\n    props.id ??= generatedControlId;\n  }\n\n  // Set aria-labelledby if the control doesn't support label.htmlFor, or if the label's htmlFor doesn't refer\n  // to this control (i.e. the user set this control's id prop without also setting the Field's label.htmlFor).\n  if (labelId && (!options?.supportsLabelFor || labelFor !== props.id)) {\n    props['aria-labelledby'] ??= labelId;\n  }\n\n  // The control is described by the validation message, or hint, or both.\n  // We also preserve and append any aria-describedby from props.\n  // For reference: https://github.com/microsoft/fluentui/pull/25580#discussion_r1017259933\n  if (validationMessageId || hintId) {\n    // NOTE: Not using ??= since we're merging and overriding the user-provided value.\n    props['aria-describedby'] = [validationMessageId, hintId, props?.['aria-describedby']].filter(Boolean).join(' ');\n  }\n\n  if (validationState === 'error') {\n    props['aria-invalid'] ??= true;\n  }\n\n  if (required) {\n    if (options?.supportsRequired) {\n      (props as { required?: boolean }).required ??= true;\n    } else {\n      props['aria-required'] ??= true;\n    }\n  }\n\n  // Include the size prop if this control supports it\n  if (options?.supportsSize) {\n    (props as { size?: FieldContextValue['size'] }).size ??= context.size;\n  }\n\n  return props;\n}\n"],"names":["props","useFieldContext_unstable","useFieldControlProps_unstable","options","getFieldControlProps","context","generatedControlId","hintId","labelFor","labelId","required","validationMessageId","validationState","id","supportsLabelFor","filter","Boolean","join","supportsRequired","supportsSize","size"],"mappings":"IA8EIA,QAMAA,SAAM,iBAYNA,SAAM,cAKHA,SAEDA,SAAM,eAMPA;AA5GL,SAASC,wBAAwB,QAAQ,iBAAiB;AAkD1D,OAAO,SAASC,8BACdF,KAAa,EACbG,OAAkC,EACf;IACnB,OAAOC,qBAAqBH,4BAA4BD,OAAOG;AACjE,CAAC;AAED;;;;CAIC,GACD,OAAO,SAASC,qBACdC,OAAsC,EACtCL,KAAa,EACbG,OAAkC,EACf;IACnB,IAAI,CAACE,SAAS;QACZ,OAAOL;IACT,CAAC;IAED,yDAAyD;IACzDA,QAAQ;QAAE,GAAGA,KAAK;IAAC;IAEnB,MAAM,EAAEM,mBAAkB,EAAEC,OAAM,EAAEC,SAAQ,EAAEC,QAAO,EAAEC,SAAQ,EAAEC,oBAAmB,EAAEC,gBAAe,EAAE,GAAGP;IAE1G,IAAIC,oBAAoB;;QACtBN,QAAAA,SAAAA,OAAMa,uCAANb,OAAMa,KAAOP,kBAAkB;IACjC,CAAC;IAED,4GAA4G;IAC5G,6GAA6G;IAC7G,IAAIG,WAAY,CAAA,CAACN,CAAAA,oBAAAA,qBAAAA,KAAAA,IAAAA,QAASW,gBAAgB,AAAD,KAAKN,aAAaR,MAAMa,EAAE,AAAD,GAAI;;QACpEb,MAAAA,UAAAA,MAAK,CAAC,kBAAA,kBAAkB,iCAAxBA,OAAK,CAAC,gBAAkB,GAAKS,OAAO;IACtC,CAAC;IAED,wEAAwE;IACxE,+DAA+D;IAC/D,yFAAyF;IACzF,IAAIE,uBAAuBJ,QAAQ;QACjC,kFAAkF;QAClFP,KAAK,CAAC,mBAAmB,GAAG;YAACW;YAAqBJ;YAAQP,kBAAAA,mBAAAA,KAAAA,IAAAA,KAAO,CAAC,mBAAmB;SAAC,CAACe,MAAM,CAACC,SAASC,IAAI,CAAC;IAC9G,CAAC;IAED,IAAIL,oBAAoB,SAAS;;QAC/BZ,OAAAA,UAAAA,MAAK,CAAC,eAAA,eAAe,mCAArBA,OAAK,CAAC,aAAe,GAAK,IAAI;IAChC,CAAC;IAED,IAAIU,UAAU;QACZ,IAAIP,oBAAAA,qBAAAA,KAAAA,IAAAA,QAASe,gBAAgB,EAAE;;YAC7B,cAAClB,UAAAA,OAAiCU,yDAAjCV,QAAiCU,WAAa,IAAI;QACrD,OAAO;;YACLV,OAAAA,UAAAA,MAAK,CAAC,gBAAA,gBAAgB,mCAAtBA,OAAK,CAAC,cAAgB,GAAK,IAAI;QACjC,CAAC;IACH,CAAC;IAED,oDAAoD;IACpD,IAAIG,oBAAAA,qBAAAA,KAAAA,IAAAA,QAASgB,YAAY,EAAE;;QACzB,UAACnB,UAAAA,OAA+CoB,6CAA/CpB,QAA+CoB,OAASf,QAAQe,IAAI;IACvE,CAAC;IAED,OAAOpB;AACT,CAAC"}