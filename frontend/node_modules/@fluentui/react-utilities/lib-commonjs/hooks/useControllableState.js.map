{"version":3,"sources":["useControllableState.js"],"sourcesContent":["import * as React from 'react';\nfunction isFactoryDispatch(newState) {\n    return typeof newState === 'function';\n}\n/**\n * @internal\n *\n * A [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate)-like hook\n * to manage a value that could be either `controlled` or `uncontrolled`,\n * such as a checked state or text input string.\n *\n * @see https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components for more details on `controlled`/`uncontrolled`\n *\n * @returns an array of the current value and an updater (dispatcher) function.\n * The updater function is referentially stable (won't change during the component's lifecycle).\n * It can take either a new value, or a function which is passed the previous value and returns the new value.\n *\n * ❗️❗️ Calls to the dispatcher will only modify the state if the state is `uncontrolled`.\n * Meaning that if a state is `controlled`, calls to the dispatcher do not modify the state.\n *\n */ export const useControllableState = (options)=>{\n    const [internalState, setInternalState] = React.useState(()=>{\n        if (options.defaultState === undefined) {\n            return options.initialState;\n        }\n        return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;\n    });\n    // Heads up!\n    // This part is specific for controlled mode and mocks behavior of React dispatcher function.\n    const stateValueRef = React.useRef(options.state);\n    React.useEffect(()=>{\n        stateValueRef.current = options.state;\n    }, [\n        options.state\n    ]);\n    const setControlledState = React.useCallback((newState)=>{\n        if (isFactoryDispatch(newState)) {\n            newState(stateValueRef.current);\n        }\n    }, []);\n    return useIsControlled(options.state) ? [\n        options.state,\n        setControlledState\n    ] : [\n        internalState,\n        setInternalState\n    ];\n};\nfunction isInitializer(value) {\n    return typeof value === 'function';\n}\n/**\n * Helper hook to handle previous comparison of controlled/uncontrolled\n * Prints an error when isControlled value switches between subsequent renders\n * @returns - whether the value is controlled\n */ const useIsControlled = (controlledValue)=>{\n    const [isControlled] = React.useState(()=>controlledValue !== undefined);\n    if (process.env.NODE_ENV !== 'production') {\n        // We don't want these warnings in production even though it is against native behaviour\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useEffect(()=>{\n            if (isControlled !== (controlledValue !== undefined)) {\n                const error = new Error();\n                const controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';\n                const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined';\n                // eslint-disable-next-line no-console\n                console.error([\n                    // Default react error\n                    'A component is changing ' + controlWarning + '. This is likely caused by the value',\n                    'changing from ' + undefinedWarning + ' value, which should not happen.',\n                    'Decide between using a controlled or uncontrolled input element for the lifetime of the component.',\n                    'More info: https://reactjs.org/link/controlled-components',\n                    error.stack\n                ].join(' '));\n            }\n        }, [\n            isControlled,\n            controlledValue\n        ]);\n    }\n    return isControlled;\n};\n"],"names":["useControllableState","isFactoryDispatch","newState","options","internalState","setInternalState","React","useState","defaultState","undefined","initialState","isInitializer","stateValueRef","useRef","state","useEffect","current","setControlledState","useCallback","useIsControlled","value","controlledValue","isControlled","process","env","NODE_ENV","error","Error","controlWarning","undefinedWarning","console","stack","join"],"mappings":";;;;+BAoBiBA;;aAAAA;;;6DApBM;AACvB,SAASC,kBAAkBC,QAAQ,EAAE;IACjC,OAAO,OAAOA,aAAa;AAC/B;AAiBW,MAAMF,uBAAuB,CAACG,UAAU;IAC/C,MAAM,CAACC,eAAeC,iBAAiB,GAAGC,OAAMC,QAAQ,CAAC,IAAI;QACzD,IAAIJ,QAAQK,YAAY,KAAKC,WAAW;YACpC,OAAON,QAAQO,YAAY;QAC/B,CAAC;QACD,OAAOC,cAAcR,QAAQK,YAAY,IAAIL,QAAQK,YAAY,KAAKL,QAAQK,YAAY;IAC9F;IACA,YAAY;IACZ,6FAA6F;IAC7F,MAAMI,gBAAgBN,OAAMO,MAAM,CAACV,QAAQW,KAAK;IAChDR,OAAMS,SAAS,CAAC,IAAI;QAChBH,cAAcI,OAAO,GAAGb,QAAQW,KAAK;IACzC,GAAG;QACCX,QAAQW,KAAK;KAChB;IACD,MAAMG,qBAAqBX,OAAMY,WAAW,CAAC,CAAChB,WAAW;QACrD,IAAID,kBAAkBC,WAAW;YAC7BA,SAASU,cAAcI,OAAO;QAClC,CAAC;IACL,GAAG,EAAE;IACL,OAAOG,gBAAgBhB,QAAQW,KAAK,IAAI;QACpCX,QAAQW,KAAK;QACbG;KACH,GAAG;QACAb;QACAC;KACH;AACL;AACA,SAASM,cAAcS,KAAK,EAAE;IAC1B,OAAO,OAAOA,UAAU;AAC5B;AACA;;;;CAIC,GAAG,MAAMD,kBAAkB,CAACE,kBAAkB;IAC3C,MAAM,CAACC,aAAa,GAAGhB,OAAMC,QAAQ,CAAC,IAAIc,oBAAoBZ;IAC9D,IAAIc,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;QACvC,wFAAwF;QACxF,sDAAsD;QACtDnB,OAAMS,SAAS,CAAC,IAAI;YAChB,IAAIO,iBAAkBD,CAAAA,oBAAoBZ,SAAQ,GAAI;gBAClD,MAAMiB,QAAQ,IAAIC;gBAClB,MAAMC,iBAAiBN,eAAe,0CAA0C,wCAAwC;gBACxH,MAAMO,mBAAmBP,eAAe,4BAA4B,wBAAwB;gBAC5F,sCAAsC;gBACtCQ,QAAQJ,KAAK,CAAC;oBACV,sBAAsB;oBACtB,6BAA6BE,iBAAiB;oBAC9C,mBAAmBC,mBAAmB;oBACtC;oBACA;oBACAH,MAAMK,KAAK;iBACd,CAACC,IAAI,CAAC;YACX,CAAC;QACL,GAAG;YACCV;YACAD;SACH;IACL,CAAC;IACD,OAAOC;AACX"}