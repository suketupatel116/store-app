{"version":3,"sources":["overflowManager.js"],"sourcesContent":["var _groups, _groupId;\nimport { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */ export function createOverflowManager() {\n    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n    const sizeCache = new Map();\n    let container;\n    let overflowMenu;\n    // Set as true when resize observer is observing\n    let observing = false;\n    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n    // Initially true to force dispatch on first mount\n    let forceDispatch = true;\n    const options = {\n        padding: 10,\n        overflowAxis: 'horizontal',\n        overflowDirection: 'end',\n        minimumVisible: 0,\n        onUpdateItemVisibility: ()=>undefined,\n        onUpdateOverflow: ()=>undefined\n    };\n    const overflowItems = {};\n    const overflowDividers = {};\n    const resizeObserver = new ResizeObserver((entries)=>{\n        if (!entries[0] || !container) {\n            return;\n        }\n        update();\n    });\n    const getNextItem = (queueToDequeue, queueToEnqueue)=>{\n        const nextItem = queueToDequeue.dequeue();\n        queueToEnqueue.enqueue(nextItem);\n        return overflowItems[nextItem];\n    };\n    const createGroupManager = ()=>{\n        const groupVisibility = {};\n        const groups = {};\n        function updateGroupVisibility(groupId) {\n            const group = groups[groupId];\n            if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n                groupVisibility[groupId] = 'overflow';\n            } else if (group.visibleItemIds.size === 0) {\n                groupVisibility[groupId] = 'hidden';\n            } else {\n                groupVisibility[groupId] = 'visible';\n            }\n        }\n        function isGroupVisible(groupId) {\n            return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n        }\n        return {\n            groupVisibility: ()=>groupVisibility,\n            isSingleItemVisible (itemId, groupId) {\n                return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n            },\n            addItem (itemId, groupId) {\n                var _;\n                (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n                    visibleItemIds: new Set(),\n                    invisibleItemIds: new Set()\n                };\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            removeItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            },\n            showItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            hideItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.add(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            }\n        };\n    };\n    const groupManager = createGroupManager();\n    const invisibleItemQueue = createPriorityQueue((a, b)=>{\n        const itemA = overflowItems[a];\n        const itemB = overflowItems[b];\n        // Higher priority at the top of the queue\n        const priority = itemB.priority - itemA.priority;\n        if (priority !== 0) {\n            return priority;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n        // equal priority, use DOM order\n        // eslint-disable-next-line no-bitwise\n        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n    });\n    const visibleItemQueue = createPriorityQueue((a, b)=>{\n        const itemA = overflowItems[a];\n        const itemB = overflowItems[b];\n        // Lower priority at the top of the queue\n        const priority = itemA.priority - itemB.priority;\n        if (priority !== 0) {\n            return priority;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;\n        // equal priority, use DOM order\n        // eslint-disable-next-line no-bitwise\n        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n    });\n    const getOffsetSize = (el)=>{\n        if (sizeCache.has(el)) {\n            return sizeCache.get(el);\n        }\n        const offsetSize = options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;\n        sizeCache.set(el, offsetSize);\n        return offsetSize;\n    };\n    function computeSizeChange(entry) {\n        const dividerWidth = entry.groupId && groupManager.isSingleItemVisible(entry.id, entry.groupId) && overflowDividers[entry.groupId] ? getOffsetSize(overflowDividers[entry.groupId].element) : 0;\n        return getOffsetSize(entry.element) + dividerWidth;\n    }\n    const showItem = ()=>{\n        const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: true\n        });\n        if (item.groupId) {\n            groupManager.showItem(item.id, item.groupId);\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n            }\n        }\n        return computeSizeChange(item);\n    };\n    const hideItem = ()=>{\n        const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n        const width = computeSizeChange(item);\n        options.onUpdateItemVisibility({\n            item,\n            visible: false\n        });\n        if (item.groupId) {\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n            }\n            groupManager.hideItem(item.id, item.groupId);\n        }\n        return width;\n    };\n    const dispatchOverflowUpdate = ()=>{\n        const visibleItemIds = visibleItemQueue.all();\n        const invisibleItemIds = invisibleItemQueue.all();\n        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);\n        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);\n        options.onUpdateOverflow({\n            visibleItems,\n            invisibleItems,\n            groupVisibility: groupManager.groupVisibility()\n        });\n    };\n    const processOverflowItems = ()=>{\n        if (!container) {\n            return false;\n        }\n        sizeCache.clear();\n        const totalDividersWidth = Object.values(overflowDividers).map((dvdr)=>dvdr.groupId ? getOffsetSize(dvdr.element) : 0).reduce((prev, current)=>prev + current, 0);\n        function overflowMenuSize() {\n            return invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n        }\n        const availableSize = getOffsetSize(container) - totalDividersWidth - options.padding;\n        // Snapshot of the visible/invisible state to compare for updates\n        const visibleTop = visibleItemQueue.peek();\n        const invisibleTop = invisibleItemQueue.peek();\n        let currentSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);\n        // Run the show/hide step twice - the first step might not be correct if\n        // it was triggered by a new item being added - new items are always visible by default.\n        for(let i = 0; i < 2; i++){\n            // Add items until available width is filled - can result in overflow\n            while(currentSize + overflowMenuSize() < availableSize && invisibleItemQueue.size() > 0){\n                currentSize += showItem();\n            }\n            // Remove items until there's no more overflow\n            while(currentSize + overflowMenuSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){\n                currentSize -= hideItem();\n            }\n        }\n        // only update when the state of visible/invisible items has changed\n        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n    };\n    const forceUpdate = ()=>{\n        if (processOverflowItems() || forceDispatch) {\n            forceDispatch = false;\n            dispatchOverflowUpdate();\n        }\n    };\n    const update = debounce(forceUpdate);\n    const observe = (observedContainer, userOptions)=>{\n        Object.assign(options, userOptions);\n        observing = true;\n        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));\n        container = observedContainer;\n        resizeObserver.observe(container);\n    };\n    const disconnect = ()=>{\n        observing = false;\n        sizeCache.clear();\n        resizeObserver.disconnect();\n    };\n    const addItem = (item)=>{\n        if (overflowItems[item.id]) {\n            return;\n        }\n        overflowItems[item.id] = item;\n        // some options can affect priority which are only set on `observe`\n        if (observing) {\n            // Updates to elements might not change the queue tops\n            // i.e. new element is enqueued but the top of the queue stays the same\n            // force a dispatch on the next batched update\n            forceDispatch = true;\n            visibleItemQueue.enqueue(item.id);\n        }\n        if (item.groupId) {\n            groupManager.addItem(item.id, item.groupId);\n            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n        }\n        update();\n    };\n    const addOverflowMenu = (el)=>{\n        overflowMenu = el;\n    };\n    const addDivider = (divider)=>{\n        if (!divider.groupId || overflowDividers[divider.groupId]) {\n            return;\n        }\n        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n        overflowDividers[divider.groupId] = divider;\n    };\n    const removeOverflowMenu = ()=>{\n        overflowMenu = undefined;\n    };\n    const removeDivider = (groupId)=>{\n        if (!overflowDividers[groupId]) {\n            return;\n        }\n        const divider = overflowDividers[groupId];\n        if (divider.groupId) {\n            delete overflowDividers[groupId];\n            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n    };\n    const removeItem = (itemId)=>{\n        if (!overflowItems[itemId]) {\n            return;\n        }\n        const item = overflowItems[itemId];\n        visibleItemQueue.remove(itemId);\n        invisibleItemQueue.remove(itemId);\n        if (item.groupId) {\n            groupManager.removeItem(item.id, item.groupId);\n            item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n        sizeCache.delete(item.element);\n        delete overflowItems[itemId];\n        update();\n    };\n    return {\n        addItem,\n        disconnect,\n        forceUpdate,\n        observe,\n        removeItem,\n        update,\n        addOverflowMenu,\n        removeOverflowMenu,\n        addDivider,\n        removeDivider\n    };\n}\n"],"names":["createOverflowManager","_groups","_groupId","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","resizeObserver","ResizeObserver","entries","update","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","groups","updateGroupVisibility","groupId","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","_","Set","add","removeItem","delete","showItem","hideItem","groupManager","invisibleItemQueue","createPriorityQueue","a","b","itemA","itemB","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","visibleItemQueue","getOffsetSize","el","get","offsetSize","offsetWidth","offsetHeight","set","computeSizeChange","entry","dividerWidth","id","item","visible","_overflowDividers_item_groupId","removeAttribute","DATA_OVERFLOWING","width","setAttribute","dispatchOverflowUpdate","all","visibleItems","map","invisibleItems","processOverflowItems","clear","totalDividersWidth","Object","values","dvdr","reduce","prev","current","overflowMenuSize","availableSize","visibleTop","peek","invisibleTop","currentSize","i","forceUpdate","debounce","observe","observedContainer","userOptions","assign","forEach","disconnect","DATA_OVERFLOW_GROUP","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"mappings":"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"}