{"version":3,"sources":["overflowManager.ts"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue, PriorityQueue } from './priorityQueue';\nimport type {\n  OverflowGroupState,\n  OverflowItemEntry,\n  OverflowManager,\n  ObserveOptions,\n  OverflowDividerEntry,\n} from './types';\n\n/**\n * @internal\n * @returns overflow manager instance\n */\nexport function createOverflowManager(): OverflowManager {\n  // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n  // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n  const sizeCache = new Map<HTMLElement, number>();\n  let container: HTMLElement | undefined;\n  let overflowMenu: HTMLElement | undefined;\n  // Set as true when resize observer is observing\n  let observing = false;\n  // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n  // Initially true to force dispatch on first mount\n  let forceDispatch = true;\n  const options: Required<ObserveOptions> = {\n    padding: 10,\n    overflowAxis: 'horizontal',\n    overflowDirection: 'end',\n    minimumVisible: 0,\n    onUpdateItemVisibility: () => undefined,\n    onUpdateOverflow: () => undefined,\n  };\n\n  const overflowItems: Record<string, OverflowItemEntry> = {};\n  const overflowDividers: Record<string, OverflowDividerEntry> = {};\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries[0] || !container) {\n      return;\n    }\n\n    update();\n  });\n\n  const getNextItem = (queueToDequeue: PriorityQueue<string>, queueToEnqueue: PriorityQueue<string>) => {\n    const nextItem = queueToDequeue.dequeue();\n    queueToEnqueue.enqueue(nextItem);\n    return overflowItems[nextItem];\n  };\n\n  const createGroupManager = () => {\n    const groupVisibility: Record<string, OverflowGroupState> = {};\n    const groups: Record<string, { visibleItemIds: Set<string>; invisibleItemIds: Set<string> }> = {};\n    function updateGroupVisibility(groupId: string) {\n      const group = groups[groupId];\n      if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n        groupVisibility[groupId] = 'overflow';\n      } else if (group.visibleItemIds.size === 0) {\n        groupVisibility[groupId] = 'hidden';\n      } else {\n        groupVisibility[groupId] = 'visible';\n      }\n    }\n    function isGroupVisible(groupId: string) {\n      return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n    }\n    return {\n      groupVisibility: () => groupVisibility,\n      isSingleItemVisible(itemId: string, groupId: string) {\n        return (\n          isGroupVisible(groupId) &&\n          groups[groupId].visibleItemIds.has(itemId) &&\n          groups[groupId].visibleItemIds.size === 1\n        );\n      },\n      addItem(itemId: string, groupId: string) {\n        groups[groupId] ??= {\n          visibleItemIds: new Set<string>(),\n          invisibleItemIds: new Set<string>(),\n        };\n\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      removeItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      },\n      showItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      hideItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.add(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      },\n    };\n  };\n\n  const groupManager = createGroupManager();\n\n  const invisibleItemQueue = createPriorityQueue<string>((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Higher priority at the top of the queue\n    const priority = itemB.priority - itemA.priority;\n    if (priority !== 0) {\n      return priority;\n    }\n\n    const positionStatusBit =\n      options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n\n  const visibleItemQueue = createPriorityQueue<string>((a, b) => {\n    const itemA = overflowItems[a];\n    const itemB = overflowItems[b];\n    // Lower priority at the top of the queue\n    const priority = itemA.priority - itemB.priority;\n\n    if (priority !== 0) {\n      return priority;\n    }\n\n    const positionStatusBit =\n      options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;\n\n    // equal priority, use DOM order\n    // eslint-disable-next-line no-bitwise\n    return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;\n  });\n\n  const getOffsetSize = (el: HTMLElement) => {\n    if (sizeCache.has(el)) {\n      return sizeCache.get(el)!;\n    }\n\n    const offsetSize = options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;\n    sizeCache.set(el, offsetSize);\n    return offsetSize;\n  };\n\n  function computeSizeChange(entry: OverflowItemEntry) {\n    const dividerWidth =\n      entry.groupId && groupManager.isSingleItemVisible(entry.id, entry.groupId) && overflowDividers[entry.groupId]\n        ? getOffsetSize(overflowDividers[entry.groupId].element)\n        : 0;\n\n    return getOffsetSize(entry.element) + dividerWidth;\n  }\n\n  const showItem = () => {\n    const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n    options.onUpdateItemVisibility({ item, visible: true });\n\n    if (item.groupId) {\n      groupManager.showItem(item.id, item.groupId);\n\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.removeAttribute(DATA_OVERFLOWING);\n      }\n    }\n\n    return computeSizeChange(item);\n  };\n\n  const hideItem = () => {\n    const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n    const width = computeSizeChange(item);\n    options.onUpdateItemVisibility({ item, visible: false });\n\n    if (item.groupId) {\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.setAttribute(DATA_OVERFLOWING, '');\n      }\n\n      groupManager.hideItem(item.id, item.groupId);\n    }\n\n    return width;\n  };\n\n  const dispatchOverflowUpdate = () => {\n    const visibleItemIds = visibleItemQueue.all();\n    const invisibleItemIds = invisibleItemQueue.all();\n\n    const visibleItems = visibleItemIds.map(itemId => overflowItems[itemId]);\n    const invisibleItems = invisibleItemIds.map(itemId => overflowItems[itemId]);\n\n    options.onUpdateOverflow({ visibleItems, invisibleItems, groupVisibility: groupManager.groupVisibility() });\n  };\n\n  const processOverflowItems = (): boolean => {\n    if (!container) {\n      return false;\n    }\n    sizeCache.clear();\n\n    const totalDividersWidth = Object.values(overflowDividers)\n      .map(dvdr => (dvdr.groupId ? getOffsetSize(dvdr.element) : 0))\n      .reduce((prev, current) => prev + current, 0);\n\n    function overflowMenuSize() {\n      return invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n    }\n\n    const availableSize = getOffsetSize(container) - totalDividersWidth - options.padding;\n\n    // Snapshot of the visible/invisible state to compare for updates\n    const visibleTop = visibleItemQueue.peek();\n    const invisibleTop = invisibleItemQueue.peek();\n\n    let currentSize = visibleItemQueue\n      .all()\n      .map(id => overflowItems[id].element)\n      .map(getOffsetSize)\n      .reduce((prev, current) => prev + current, 0);\n\n    // Run the show/hide step twice - the first step might not be correct if\n    // it was triggered by a new item being added - new items are always visible by default.\n    for (let i = 0; i < 2; i++) {\n      // Add items until available width is filled - can result in overflow\n      while (currentSize + overflowMenuSize() < availableSize && invisibleItemQueue.size() > 0) {\n        currentSize += showItem();\n      }\n\n      // Remove items until there's no more overflow\n      while (currentSize + overflowMenuSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {\n        currentSize -= hideItem();\n      }\n    }\n\n    // only update when the state of visible/invisible items has changed\n    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n  };\n\n  const forceUpdate: OverflowManager['forceUpdate'] = () => {\n    if (processOverflowItems() || forceDispatch) {\n      forceDispatch = false;\n      dispatchOverflowUpdate();\n    }\n  };\n\n  const update: OverflowManager['update'] = debounce(forceUpdate);\n\n  const observe: OverflowManager['observe'] = (observedContainer, userOptions) => {\n    Object.assign(options, userOptions);\n    observing = true;\n    Object.values(overflowItems).forEach(item => visibleItemQueue.enqueue(item.id));\n\n    container = observedContainer;\n    resizeObserver.observe(container);\n  };\n\n  const disconnect: OverflowManager['disconnect'] = () => {\n    observing = false;\n    sizeCache.clear();\n    resizeObserver.disconnect();\n  };\n\n  const addItem: OverflowManager['addItem'] = item => {\n    if (overflowItems[item.id]) {\n      return;\n    }\n\n    overflowItems[item.id] = item;\n\n    // some options can affect priority which are only set on `observe`\n    if (observing) {\n      // Updates to elements might not change the queue tops\n      // i.e. new element is enqueued but the top of the queue stays the same\n      // force a dispatch on the next batched update\n      forceDispatch = true;\n      visibleItemQueue.enqueue(item.id);\n    }\n\n    if (item.groupId) {\n      groupManager.addItem(item.id, item.groupId);\n      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n    }\n\n    update();\n  };\n\n  const addOverflowMenu: OverflowManager['addOverflowMenu'] = el => {\n    overflowMenu = el;\n  };\n\n  const addDivider: OverflowManager['addDivider'] = divider => {\n    if (!divider.groupId || overflowDividers[divider.groupId]) {\n      return;\n    }\n\n    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n    overflowDividers[divider.groupId] = divider;\n  };\n\n  const removeOverflowMenu: OverflowManager['removeOverflowMenu'] = () => {\n    overflowMenu = undefined;\n  };\n\n  const removeDivider: OverflowManager['removeDivider'] = groupId => {\n    if (!overflowDividers[groupId]) {\n      return;\n    }\n    const divider = overflowDividers[groupId];\n    if (divider.groupId) {\n      delete overflowDividers[groupId];\n      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n  };\n\n  const removeItem: OverflowManager['removeItem'] = itemId => {\n    if (!overflowItems[itemId]) {\n      return;\n    }\n\n    const item = overflowItems[itemId];\n    visibleItemQueue.remove(itemId);\n    invisibleItemQueue.remove(itemId);\n\n    if (item.groupId) {\n      groupManager.removeItem(item.id, item.groupId);\n      item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n\n    sizeCache.delete(item.element);\n    delete overflowItems[itemId];\n    update();\n  };\n\n  return {\n    addItem,\n    disconnect,\n    forceUpdate,\n    observe,\n    removeItem,\n    update,\n    addOverflowMenu,\n    removeOverflowMenu,\n    addDivider,\n    removeDivider,\n  };\n}\n"],"names":["groups","groupId","DATA_OVERFLOWING","DATA_OVERFLOW_GROUP","debounce","createPriorityQueue","createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","resizeObserver","ResizeObserver","entries","update","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","updateGroupVisibility","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","Set","add","removeItem","delete","showItem","hideItem","groupManager","invisibleItemQueue","a","b","itemA","itemB","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","visibleItemQueue","getOffsetSize","el","get","offsetSize","offsetWidth","offsetHeight","set","computeSizeChange","entry","dividerWidth","id","item","visible","removeAttribute","width","setAttribute","dispatchOverflowUpdate","all","visibleItems","map","invisibleItems","processOverflowItems","clear","totalDividersWidth","Object","values","dvdr","reduce","prev","current","overflowMenuSize","availableSize","visibleTop","peek","invisibleTop","currentSize","i","forceUpdate","observe","observedContainer","userOptions","assign","forEach","disconnect","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"mappings":"IA6EQA,SAAOC;AA7Ef,SAASC,gBAAgB,EAAEC,mBAAmB,QAAQ,WAAW;AACjE,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,mBAAmB,QAAuB,kBAAkB;AASrE;;;CAGC,GACD,OAAO,SAASC,wBAAyC;IACvD,gFAAgF;IAChF,2FAA2F;IAC3F,MAAMC,YAAY,IAAIC;IACtB,IAAIC;IACJ,IAAIC;IACJ,gDAAgD;IAChD,IAAIC,YAAY,KAAK;IACrB,+FAA+F;IAC/F,kDAAkD;IAClD,IAAIC,gBAAgB,IAAI;IACxB,MAAMC,UAAoC;QACxCC,SAAS;QACTC,cAAc;QACdC,mBAAmB;QACnBC,gBAAgB;QAChBC,wBAAwB,IAAMC;QAC9BC,kBAAkB,IAAMD;IAC1B;IAEA,MAAME,gBAAmD,CAAC;IAC1D,MAAMC,mBAAyD,CAAC;IAChE,MAAMC,iBAAiB,IAAIC,eAAeC,CAAAA,UAAW;QACnD,IAAI,CAACA,OAAO,CAAC,EAAE,IAAI,CAAChB,WAAW;YAC7B;QACF,CAAC;QAEDiB;IACF;IAEA,MAAMC,cAAc,CAACC,gBAAuCC,iBAA0C;QACpG,MAAMC,WAAWF,eAAeG,OAAO;QACvCF,eAAeG,OAAO,CAACF;QACvB,OAAOT,aAAa,CAACS,SAAS;IAChC;IAEA,MAAMG,qBAAqB,IAAM;QAC/B,MAAMC,kBAAsD,CAAC;QAC7D,MAAMlC,SAAyF,CAAC;QAChG,SAASmC,sBAAsBlC,OAAe,EAAE;YAC9C,MAAMmC,QAAQpC,MAAM,CAACC,QAAQ;YAC7B,IAAImC,MAAMC,gBAAgB,CAACC,IAAI,IAAIF,MAAMG,cAAc,CAACD,IAAI,EAAE;gBAC5DJ,eAAe,CAACjC,QAAQ,GAAG;YAC7B,OAAO,IAAImC,MAAMG,cAAc,CAACD,IAAI,KAAK,GAAG;gBAC1CJ,eAAe,CAACjC,QAAQ,GAAG;YAC7B,OAAO;gBACLiC,eAAe,CAACjC,QAAQ,GAAG;YAC7B,CAAC;QACH;QACA,SAASuC,eAAevC,OAAe,EAAE;YACvC,OAAOiC,eAAe,CAACjC,QAAQ,KAAK,aAAaiC,eAAe,CAACjC,QAAQ,KAAK;QAChF;QACA,OAAO;YACLiC,iBAAiB,IAAMA;YACvBO,qBAAoBC,MAAc,EAAEzC,OAAe,EAAE;gBACnD,OACEuC,eAAevC,YACfD,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACI,GAAG,CAACD,WACnC1C,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACD,IAAI,KAAK;YAE5C;YACAM,SAAQF,MAAc,EAAEzC,OAAe,EAAE;;gBACvCD,MAAAA,UAAAA,OAAM,CAACC,WAAAA,QAAQ,iCAAfD,OAAM,CAACC,SAAQ,GAAK;oBAClBsC,gBAAgB,IAAIM;oBACpBR,kBAAkB,IAAIQ;gBACxB,CAAC;gBAED7C,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACO,GAAG,CAACJ;gBACnCP,sBAAsBlC;YACxB;YACA8C,YAAWL,MAAc,EAAEzC,OAAe,EAAE;gBAC1CD,MAAM,CAACC,QAAQ,CAACoC,gBAAgB,CAACW,MAAM,CAACN;gBACxC1C,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACS,MAAM,CAACN;gBACtCP,sBAAsBlC;YACxB;YACAgD,UAASP,MAAc,EAAEzC,OAAe,EAAE;gBACxCD,MAAM,CAACC,QAAQ,CAACoC,gBAAgB,CAACW,MAAM,CAACN;gBACxC1C,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACO,GAAG,CAACJ;gBACnCP,sBAAsBlC;YACxB;YACAiD,UAASR,MAAc,EAAEzC,OAAe,EAAE;gBACxCD,MAAM,CAACC,QAAQ,CAACoC,gBAAgB,CAACS,GAAG,CAACJ;gBACrC1C,MAAM,CAACC,QAAQ,CAACsC,cAAc,CAACS,MAAM,CAACN;gBACtCP,sBAAsBlC;YACxB;QACF;IACF;IAEA,MAAMkD,eAAelB;IAErB,MAAMmB,qBAAqB/C,oBAA4B,CAACgD,GAAGC,IAAM;QAC/D,MAAMC,QAAQlC,aAAa,CAACgC,EAAE;QAC9B,MAAMG,QAAQnC,aAAa,CAACiC,EAAE;QAC9B,0CAA0C;QAC1C,MAAMG,WAAWD,MAAMC,QAAQ,GAAGF,MAAME,QAAQ;QAChD,IAAIA,aAAa,GAAG;YAClB,OAAOA;QACT,CAAC;QAED,MAAMC,oBACJ7C,QAAQG,iBAAiB,KAAK,QAAQ2C,KAAKC,2BAA2B,GAAGD,KAAKE,2BAA2B;QAE3G,gCAAgC;QAChC,sCAAsC;QACtC,OAAON,MAAMO,OAAO,CAACC,uBAAuB,CAACP,MAAMM,OAAO,IAAIJ,oBAAoB,CAAC,IAAI,CAAC;IAC1F;IAEA,MAAMM,mBAAmB3D,oBAA4B,CAACgD,GAAGC,IAAM;QAC7D,MAAMC,QAAQlC,aAAa,CAACgC,EAAE;QAC9B,MAAMG,QAAQnC,aAAa,CAACiC,EAAE;QAC9B,yCAAyC;QACzC,MAAMG,WAAWF,MAAME,QAAQ,GAAGD,MAAMC,QAAQ;QAEhD,IAAIA,aAAa,GAAG;YAClB,OAAOA;QACT,CAAC;QAED,MAAMC,oBACJ7C,QAAQG,iBAAiB,KAAK,QAAQ2C,KAAKE,2BAA2B,GAAGF,KAAKC,2BAA2B;QAE3G,gCAAgC;QAChC,sCAAsC;QACtC,OAAOL,MAAMO,OAAO,CAACC,uBAAuB,CAACP,MAAMM,OAAO,IAAIJ,oBAAoB,CAAC,IAAI,CAAC;IAC1F;IAEA,MAAMO,gBAAgB,CAACC,KAAoB;QACzC,IAAI3D,UAAUoC,GAAG,CAACuB,KAAK;YACrB,OAAO3D,UAAU4D,GAAG,CAACD;QACvB,CAAC;QAED,MAAME,aAAavD,QAAQE,YAAY,KAAK,eAAemD,GAAGG,WAAW,GAAGH,GAAGI,YAAY;QAC3F/D,UAAUgE,GAAG,CAACL,IAAIE;QAClB,OAAOA;IACT;IAEA,SAASI,kBAAkBC,KAAwB,EAAE;QACnD,MAAMC,eACJD,MAAMxE,OAAO,IAAIkD,aAAaV,mBAAmB,CAACgC,MAAME,EAAE,EAAEF,MAAMxE,OAAO,KAAKqB,gBAAgB,CAACmD,MAAMxE,OAAO,CAAC,GACzGgE,cAAc3C,gBAAgB,CAACmD,MAAMxE,OAAO,CAAC,CAAC6D,OAAO,IACrD,CAAC;QAEP,OAAOG,cAAcQ,MAAMX,OAAO,IAAIY;IACxC;IAEA,MAAMzB,WAAW,IAAM;QACrB,MAAM2B,OAAOjD,YAAYyB,oBAAoBY;QAC7CnD,QAAQK,sBAAsB,CAAC;YAAE0D;YAAMC,SAAS,IAAI;QAAC;QAErD,IAAID,KAAK3E,OAAO,EAAE;YAChBkD,aAAaF,QAAQ,CAAC2B,KAAKD,EAAE,EAAEC,KAAK3E,OAAO;YAE3C,IAAIkD,aAAaV,mBAAmB,CAACmC,KAAKD,EAAE,EAAEC,KAAK3E,OAAO,GAAG;oBAC3DqB;gBAAAA,CAAAA,iCAAAA,gBAAgB,CAACsD,KAAK3E,OAAO,CAAC,cAA9BqB,4CAAAA,KAAAA,IAAAA,+BAAgCwC,QAAQgB,eAAe,CAAC5E,iBAAiB;YAC3E,CAAC;QACH,CAAC;QAED,OAAOsE,kBAAkBI;IAC3B;IAEA,MAAM1B,WAAW,IAAM;QACrB,MAAM0B,OAAOjD,YAAYqC,kBAAkBZ;QAC3C,MAAM2B,QAAQP,kBAAkBI;QAChC/D,QAAQK,sBAAsB,CAAC;YAAE0D;YAAMC,SAAS,KAAK;QAAC;QAEtD,IAAID,KAAK3E,OAAO,EAAE;YAChB,IAAIkD,aAAaV,mBAAmB,CAACmC,KAAKD,EAAE,EAAEC,KAAK3E,OAAO,GAAG;oBAC3DqB;gBAAAA,CAAAA,iCAAAA,gBAAgB,CAACsD,KAAK3E,OAAO,CAAC,cAA9BqB,4CAAAA,KAAAA,IAAAA,+BAAgCwC,QAAQkB,YAAY,CAAC9E,kBAAkB,GAAG;YAC5E,CAAC;YAEDiD,aAAaD,QAAQ,CAAC0B,KAAKD,EAAE,EAAEC,KAAK3E,OAAO;QAC7C,CAAC;QAED,OAAO8E;IACT;IAEA,MAAME,yBAAyB,IAAM;QACnC,MAAM1C,iBAAiByB,iBAAiBkB,GAAG;QAC3C,MAAM7C,mBAAmBe,mBAAmB8B,GAAG;QAE/C,MAAMC,eAAe5C,eAAe6C,GAAG,CAAC1C,CAAAA,SAAUrB,aAAa,CAACqB,OAAO;QACvE,MAAM2C,iBAAiBhD,iBAAiB+C,GAAG,CAAC1C,CAAAA,SAAUrB,aAAa,CAACqB,OAAO;QAE3E7B,QAAQO,gBAAgB,CAAC;YAAE+D;YAAcE;YAAgBnD,iBAAiBiB,aAAajB,eAAe;QAAG;IAC3G;IAEA,MAAMoD,uBAAuB,IAAe;QAC1C,IAAI,CAAC7E,WAAW;YACd,OAAO,KAAK;QACd,CAAC;QACDF,UAAUgF,KAAK;QAEf,MAAMC,qBAAqBC,OAAOC,MAAM,CAACpE,kBACtC8D,GAAG,CAACO,CAAAA,OAASA,KAAK1F,OAAO,GAAGgE,cAAc0B,KAAK7B,OAAO,IAAI,CAAC,EAC3D8B,MAAM,CAAC,CAACC,MAAMC,UAAYD,OAAOC,SAAS;QAE7C,SAASC,mBAAmB;YAC1B,OAAO3C,mBAAmBd,IAAI,KAAK,KAAK5B,eAAeuD,cAAcvD,gBAAgB,CAAC;QACxF;QAEA,MAAMsF,gBAAgB/B,cAAcxD,aAAa+E,qBAAqB3E,QAAQC,OAAO;QAErF,iEAAiE;QACjE,MAAMmF,aAAajC,iBAAiBkC,IAAI;QACxC,MAAMC,eAAe/C,mBAAmB8C,IAAI;QAE5C,IAAIE,cAAcpC,iBACfkB,GAAG,GACHE,GAAG,CAACT,CAAAA,KAAMtD,aAAa,CAACsD,GAAG,CAACb,OAAO,EACnCsB,GAAG,CAACnB,eACJ2B,MAAM,CAAC,CAACC,MAAMC,UAAYD,OAAOC,SAAS;QAE7C,wEAAwE;QACxE,wFAAwF;QACxF,IAAK,IAAIO,IAAI,GAAGA,IAAI,GAAGA,IAAK;YAC1B,qEAAqE;YACrE,MAAOD,cAAcL,qBAAqBC,iBAAiB5C,mBAAmBd,IAAI,KAAK,EAAG;gBACxF8D,eAAenD;YACjB;YAEA,8CAA8C;YAC9C,MAAOmD,cAAcL,qBAAqBC,iBAAiBhC,iBAAiB1B,IAAI,KAAKzB,QAAQI,cAAc,CAAE;gBAC3GmF,eAAelD;YACjB;QACF;QAEA,oEAAoE;QACpE,OAAOc,iBAAiBkC,IAAI,OAAOD,cAAc7C,mBAAmB8C,IAAI,OAAOC;IACjF;IAEA,MAAMG,cAA8C,IAAM;QACxD,IAAIhB,0BAA0B1E,eAAe;YAC3CA,gBAAgB,KAAK;YACrBqE;QACF,CAAC;IACH;IAEA,MAAMvD,SAAoCtB,SAASkG;IAEnD,MAAMC,UAAsC,CAACC,mBAAmBC,cAAgB;QAC9EhB,OAAOiB,MAAM,CAAC7F,SAAS4F;QACvB9F,YAAY,IAAI;QAChB8E,OAAOC,MAAM,CAACrE,eAAesF,OAAO,CAAC/B,CAAAA,OAAQZ,iBAAiBhC,OAAO,CAAC4C,KAAKD,EAAE;QAE7ElE,YAAY+F;QACZjF,eAAegF,OAAO,CAAC9F;IACzB;IAEA,MAAMmG,aAA4C,IAAM;QACtDjG,YAAY,KAAK;QACjBJ,UAAUgF,KAAK;QACfhE,eAAeqF,UAAU;IAC3B;IAEA,MAAMhE,UAAsCgC,CAAAA,OAAQ;QAClD,IAAIvD,aAAa,CAACuD,KAAKD,EAAE,CAAC,EAAE;YAC1B;QACF,CAAC;QAEDtD,aAAa,CAACuD,KAAKD,EAAE,CAAC,GAAGC;QAEzB,mEAAmE;QACnE,IAAIjE,WAAW;YACb,sDAAsD;YACtD,uEAAuE;YACvE,8CAA8C;YAC9CC,gBAAgB,IAAI;YACpBoD,iBAAiBhC,OAAO,CAAC4C,KAAKD,EAAE;QAClC,CAAC;QAED,IAAIC,KAAK3E,OAAO,EAAE;YAChBkD,aAAaP,OAAO,CAACgC,KAAKD,EAAE,EAAEC,KAAK3E,OAAO;YAC1C2E,KAAKd,OAAO,CAACkB,YAAY,CAAC7E,qBAAqByE,KAAK3E,OAAO;QAC7D,CAAC;QAEDyB;IACF;IAEA,MAAMmF,kBAAsD3C,CAAAA,KAAM;QAChExD,eAAewD;IACjB;IAEA,MAAM4C,aAA4CC,CAAAA,UAAW;QAC3D,IAAI,CAACA,QAAQ9G,OAAO,IAAIqB,gBAAgB,CAACyF,QAAQ9G,OAAO,CAAC,EAAE;YACzD;QACF,CAAC;QAED8G,QAAQjD,OAAO,CAACkB,YAAY,CAAC7E,qBAAqB4G,QAAQ9G,OAAO;QACjEqB,gBAAgB,CAACyF,QAAQ9G,OAAO,CAAC,GAAG8G;IACtC;IAEA,MAAMC,qBAA4D,IAAM;QACtEtG,eAAeS;IACjB;IAEA,MAAM8F,gBAAkDhH,CAAAA,UAAW;QACjE,IAAI,CAACqB,gBAAgB,CAACrB,QAAQ,EAAE;YAC9B;QACF,CAAC;QACD,MAAM8G,UAAUzF,gBAAgB,CAACrB,QAAQ;QACzC,IAAI8G,QAAQ9G,OAAO,EAAE;YACnB,OAAOqB,gBAAgB,CAACrB,QAAQ;YAChC8G,QAAQjD,OAAO,CAACgB,eAAe,CAAC3E;QAClC,CAAC;IACH;IAEA,MAAM4C,aAA4CL,CAAAA,SAAU;QAC1D,IAAI,CAACrB,aAAa,CAACqB,OAAO,EAAE;YAC1B;QACF,CAAC;QAED,MAAMkC,OAAOvD,aAAa,CAACqB,OAAO;QAClCsB,iBAAiBkD,MAAM,CAACxE;QACxBU,mBAAmB8D,MAAM,CAACxE;QAE1B,IAAIkC,KAAK3E,OAAO,EAAE;YAChBkD,aAAaJ,UAAU,CAAC6B,KAAKD,EAAE,EAAEC,KAAK3E,OAAO;YAC7C2E,KAAKd,OAAO,CAACgB,eAAe,CAAC3E;QAC/B,CAAC;QAEDI,UAAUyC,MAAM,CAAC4B,KAAKd,OAAO;QAC7B,OAAOzC,aAAa,CAACqB,OAAO;QAC5BhB;IACF;IAEA,OAAO;QACLkB;QACAgE;QACAN;QACAC;QACAxD;QACArB;QACAmF;QACAG;QACAF;QACAG;IACF;AACF,CAAC"}