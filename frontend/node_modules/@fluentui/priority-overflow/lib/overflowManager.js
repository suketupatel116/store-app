var _groups, _groupId;
import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';
import { debounce } from './debounce';
import { createPriorityQueue } from './priorityQueue';
/**
 * @internal
 * @returns overflow manager instance
 */ export function createOverflowManager() {
    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update
    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes
    const sizeCache = new Map();
    let container;
    let overflowMenu;
    // Set as true when resize observer is observing
    let observing = false;
    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change
    // Initially true to force dispatch on first mount
    let forceDispatch = true;
    const options = {
        padding: 10,
        overflowAxis: 'horizontal',
        overflowDirection: 'end',
        minimumVisible: 0,
        onUpdateItemVisibility: ()=>undefined,
        onUpdateOverflow: ()=>undefined
    };
    const overflowItems = {};
    const overflowDividers = {};
    const resizeObserver = new ResizeObserver((entries)=>{
        if (!entries[0] || !container) {
            return;
        }
        update();
    });
    const getNextItem = (queueToDequeue, queueToEnqueue)=>{
        const nextItem = queueToDequeue.dequeue();
        queueToEnqueue.enqueue(nextItem);
        return overflowItems[nextItem];
    };
    const createGroupManager = ()=>{
        const groupVisibility = {};
        const groups = {};
        function updateGroupVisibility(groupId) {
            const group = groups[groupId];
            if (group.invisibleItemIds.size && group.visibleItemIds.size) {
                groupVisibility[groupId] = 'overflow';
            } else if (group.visibleItemIds.size === 0) {
                groupVisibility[groupId] = 'hidden';
            } else {
                groupVisibility[groupId] = 'visible';
            }
        }
        function isGroupVisible(groupId) {
            return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';
        }
        return {
            groupVisibility: ()=>groupVisibility,
            isSingleItemVisible (itemId, groupId) {
                return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;
            },
            addItem (itemId, groupId) {
                var _;
                (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {
                    visibleItemIds: new Set(),
                    invisibleItemIds: new Set()
                };
                groups[groupId].visibleItemIds.add(itemId);
                updateGroupVisibility(groupId);
            },
            removeItem (itemId, groupId) {
                groups[groupId].invisibleItemIds.delete(itemId);
                groups[groupId].visibleItemIds.delete(itemId);
                updateGroupVisibility(groupId);
            },
            showItem (itemId, groupId) {
                groups[groupId].invisibleItemIds.delete(itemId);
                groups[groupId].visibleItemIds.add(itemId);
                updateGroupVisibility(groupId);
            },
            hideItem (itemId, groupId) {
                groups[groupId].invisibleItemIds.add(itemId);
                groups[groupId].visibleItemIds.delete(itemId);
                updateGroupVisibility(groupId);
            }
        };
    };
    const groupManager = createGroupManager();
    const invisibleItemQueue = createPriorityQueue((a, b)=>{
        const itemA = overflowItems[a];
        const itemB = overflowItems[b];
        // Higher priority at the top of the queue
        const priority = itemB.priority - itemA.priority;
        if (priority !== 0) {
            return priority;
        }
        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;
        // equal priority, use DOM order
        // eslint-disable-next-line no-bitwise
        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;
    });
    const visibleItemQueue = createPriorityQueue((a, b)=>{
        const itemA = overflowItems[a];
        const itemB = overflowItems[b];
        // Lower priority at the top of the queue
        const priority = itemA.priority - itemB.priority;
        if (priority !== 0) {
            return priority;
        }
        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_PRECEDING : Node.DOCUMENT_POSITION_FOLLOWING;
        // equal priority, use DOM order
        // eslint-disable-next-line no-bitwise
        return itemA.element.compareDocumentPosition(itemB.element) & positionStatusBit ? -1 : 1;
    });
    const getOffsetSize = (el)=>{
        if (sizeCache.has(el)) {
            return sizeCache.get(el);
        }
        const offsetSize = options.overflowAxis === 'horizontal' ? el.offsetWidth : el.offsetHeight;
        sizeCache.set(el, offsetSize);
        return offsetSize;
    };
    function computeSizeChange(entry) {
        const dividerWidth = entry.groupId && groupManager.isSingleItemVisible(entry.id, entry.groupId) && overflowDividers[entry.groupId] ? getOffsetSize(overflowDividers[entry.groupId].element) : 0;
        return getOffsetSize(entry.element) + dividerWidth;
    }
    const showItem = ()=>{
        const item = getNextItem(invisibleItemQueue, visibleItemQueue);
        options.onUpdateItemVisibility({
            item,
            visible: true
        });
        if (item.groupId) {
            groupManager.showItem(item.id, item.groupId);
            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
                var _overflowDividers_item_groupId;
                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);
            }
        }
        return computeSizeChange(item);
    };
    const hideItem = ()=>{
        const item = getNextItem(visibleItemQueue, invisibleItemQueue);
        const width = computeSizeChange(item);
        options.onUpdateItemVisibility({
            item,
            visible: false
        });
        if (item.groupId) {
            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
                var _overflowDividers_item_groupId;
                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');
            }
            groupManager.hideItem(item.id, item.groupId);
        }
        return width;
    };
    const dispatchOverflowUpdate = ()=>{
        const visibleItemIds = visibleItemQueue.all();
        const invisibleItemIds = invisibleItemQueue.all();
        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);
        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);
        options.onUpdateOverflow({
            visibleItems,
            invisibleItems,
            groupVisibility: groupManager.groupVisibility()
        });
    };
    const processOverflowItems = ()=>{
        if (!container) {
            return false;
        }
        sizeCache.clear();
        const totalDividersWidth = Object.values(overflowDividers).map((dvdr)=>dvdr.groupId ? getOffsetSize(dvdr.element) : 0).reduce((prev, current)=>prev + current, 0);
        function overflowMenuSize() {
            return invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;
        }
        const availableSize = getOffsetSize(container) - totalDividersWidth - options.padding;
        // Snapshot of the visible/invisible state to compare for updates
        const visibleTop = visibleItemQueue.peek();
        const invisibleTop = invisibleItemQueue.peek();
        let currentSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);
        // Run the show/hide step twice - the first step might not be correct if
        // it was triggered by a new item being added - new items are always visible by default.
        for(let i = 0; i < 2; i++){
            // Add items until available width is filled - can result in overflow
            while(currentSize + overflowMenuSize() < availableSize && invisibleItemQueue.size() > 0){
                currentSize += showItem();
            }
            // Remove items until there's no more overflow
            while(currentSize + overflowMenuSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){
                currentSize -= hideItem();
            }
        }
        // only update when the state of visible/invisible items has changed
        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;
    };
    const forceUpdate = ()=>{
        if (processOverflowItems() || forceDispatch) {
            forceDispatch = false;
            dispatchOverflowUpdate();
        }
    };
    const update = debounce(forceUpdate);
    const observe = (observedContainer, userOptions)=>{
        Object.assign(options, userOptions);
        observing = true;
        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));
        container = observedContainer;
        resizeObserver.observe(container);
    };
    const disconnect = ()=>{
        observing = false;
        sizeCache.clear();
        resizeObserver.disconnect();
    };
    const addItem = (item)=>{
        if (overflowItems[item.id]) {
            return;
        }
        overflowItems[item.id] = item;
        // some options can affect priority which are only set on `observe`
        if (observing) {
            // Updates to elements might not change the queue tops
            // i.e. new element is enqueued but the top of the queue stays the same
            // force a dispatch on the next batched update
            forceDispatch = true;
            visibleItemQueue.enqueue(item.id);
        }
        if (item.groupId) {
            groupManager.addItem(item.id, item.groupId);
            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);
        }
        update();
    };
    const addOverflowMenu = (el)=>{
        overflowMenu = el;
    };
    const addDivider = (divider)=>{
        if (!divider.groupId || overflowDividers[divider.groupId]) {
            return;
        }
        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);
        overflowDividers[divider.groupId] = divider;
    };
    const removeOverflowMenu = ()=>{
        overflowMenu = undefined;
    };
    const removeDivider = (groupId)=>{
        if (!overflowDividers[groupId]) {
            return;
        }
        const divider = overflowDividers[groupId];
        if (divider.groupId) {
            delete overflowDividers[groupId];
            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);
        }
    };
    const removeItem = (itemId)=>{
        if (!overflowItems[itemId]) {
            return;
        }
        const item = overflowItems[itemId];
        visibleItemQueue.remove(itemId);
        invisibleItemQueue.remove(itemId);
        if (item.groupId) {
            groupManager.removeItem(item.id, item.groupId);
            item.element.removeAttribute(DATA_OVERFLOW_GROUP);
        }
        sizeCache.delete(item.element);
        delete overflowItems[itemId];
        update();
    };
    return {
        addItem,
        disconnect,
        forceUpdate,
        observe,
        removeItem,
        update,
        addOverflowMenu,
        removeOverflowMenu,
        addDivider,
        removeDivider
    };
}
