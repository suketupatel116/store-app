{"version":3,"sources":["useVirtualizer.js"],"sourcesContent":["import { useEffect, useRef, useCallback, useReducer, useImperativeHandle, useState } from 'react';\nimport { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { renderVirtualizerChildPlaceholder } from './renderVirtualizer';\nexport function useVirtualizer_unstable(props) {\n    const { itemSize , numItems , virtualizerLength , children: renderChild , getItemSize , bufferItems =Math.round(virtualizerLength / 4.0) , bufferSize =Math.floor(bufferItems / 2.0) * itemSize , scrollViewRef , axis ='vertical' , reversed =false , virtualizerContext , onRenderedFlaggedIndex , imperativeVirtualizerRef  } = props;\n    /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/ const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n    // We use this ref as a constant source to access the virtualizer's state imperatively\n    const actualIndexRef = useRef(_virtualizerContext.contextIndex);\n    if (actualIndexRef.current !== _virtualizerContext.contextIndex) {\n        actualIndexRef.current = _virtualizerContext.contextIndex;\n    }\n    const flaggedIndex = useRef(null);\n    const actualIndex = _virtualizerContext.contextIndex;\n    const setActualIndex = _virtualizerContext.setContextIndex;\n    // Store ref to before padding element\n    const beforeElementRef = useRef(null);\n    // Store ref to before padding element\n    const afterElementRef = useRef(null);\n    // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n    const childSizes = useRef(new Array(getItemSize ? numItems : 0));\n    /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */ const childProgressiveSizes = useRef(new Array(getItemSize ? numItems : 0));\n    // The internal tracking REF for child array (updates often).\n    const childArray = useRef(new Array(virtualizerLength));\n    // We want to be methodical about updating the render with child reference array\n    const forceUpdate = useReducer(()=>({}), {})[1];\n    const horizontal = axis === 'horizontal';\n    const populateSizeArrays = ()=>{\n        if (!getItemSize) {\n            // Static sizes, never mind!\n            return;\n        }\n        if (numItems !== childSizes.current.length) {\n            childSizes.current = new Array(numItems);\n        }\n        if (numItems !== childProgressiveSizes.current.length) {\n            childProgressiveSizes.current = new Array(numItems);\n        }\n        for(let index = 0; index < numItems; index++){\n            childSizes.current[index] = getItemSize(index);\n            if (index === 0) {\n                childProgressiveSizes.current[index] = childSizes.current[index];\n            } else {\n                childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n            }\n        }\n    };\n    const [isScrolling, setIsScrolling] = useState(false);\n    const scrollTimer = useRef();\n    const scrollCounter = useRef(0);\n    const initializeScrollingTimer = ()=>{\n        /*\n     * This can be considered the 'velocity' required to start 'isScrolling'\n     * INIT_SCROLL_FLAG_REQ: Number of renders required to activate isScrolling\n     * INIT_SCROLL_FLAG_DELAY: Amount of time (ms) before current number of renders is reset\n     *  - Maybe we should let users customize these in the future.\n     */ const INIT_SCROLL_FLAG_REQ = 10;\n        const INIT_SCROLL_FLAG_DELAY = 100;\n        scrollCounter.current++;\n        if (scrollCounter.current >= INIT_SCROLL_FLAG_REQ) {\n            setIsScrolling(true);\n        }\n        if (scrollTimer.current) {\n            clearTimeout(scrollTimer.current);\n        }\n        scrollTimer.current = setTimeout(()=>{\n            setIsScrolling(false);\n            scrollCounter.current = 0;\n        }, INIT_SCROLL_FLAG_DELAY);\n    };\n    useEffect(()=>{\n        initializeScrollingTimer();\n    }, [\n        actualIndex\n    ]);\n    const batchUpdateNewIndex = (index)=>{\n        // Local updates\n        updateChildRows(index);\n        updateCurrentItemSizes(index);\n        // Set before 'setActualIndex' call\n        // If it changes before render, or injected via context, re-render will update ref.\n        actualIndexRef.current = index;\n        // State setters\n        setActualIndex(index);\n    };\n    // Observe intersections of virtualized components\n    const { setObserverList  } = useIntersectionObserver((entries, observer)=>{\n        /* Sanity check - do we even need virtualization? */ if (virtualizerLength > numItems) {\n            if (actualIndex !== 0) {\n                batchUpdateNewIndex(0);\n            }\n            // No-op\n            return;\n        }\n        /* IO initiates this function when needed (bookend entering view) */ let measurementPos = 0;\n        let bufferCount = bufferItems;\n        // Grab latest entry that is intersecting\n        const latestEntry = entries.length === 1 ? entries[0] : entries.sort((entry1, entry2)=>entry2.time - entry1.time).find((entry)=>{\n            return entry.intersectionRatio > 0;\n        });\n        if (!latestEntry) {\n            // If we don't find an intersecting area, ignore for now.\n            return;\n        }\n        if (latestEntry.target === afterElementRef.current) {\n            // We need to inverse the buffer count\n            bufferCount = virtualizerLength - bufferItems;\n            measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n            if (!horizontal) {\n                if (reversed) {\n                    // Scrolling 'up' and hit the after element below\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' and hit the after element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (reversed) {\n                    // Scrolling 'left' and hit the after element\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'right' and hit the after element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        } else if (latestEntry.target === beforeElementRef.current) {\n            measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n            if (!horizontal) {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' in reverse order and hit the before element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'left' and hit before element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        }\n        if (reversed) {\n            // We're reversed, up is down, left is right, invert the scroll measure.\n            measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n        }\n        // For now lets use hardcoded size to assess current element to paginate on\n        const startIndex = getIndexFromScrollPosition(measurementPos);\n        const bufferedIndex = Math.max(startIndex - bufferCount, 0);\n        // Safety limits\n        const maxIndex = Math.max(numItems - virtualizerLength, 0);\n        const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n        if (actualIndex !== newStartIndex) {\n            // We flush sync this and perform an immediate state update\n            flushSync(()=>{\n                batchUpdateNewIndex(newStartIndex);\n            });\n        }\n    }, {\n        root: scrollViewRef ? scrollViewRef === null || scrollViewRef === void 0 ? void 0 : scrollViewRef.current : null,\n        rootMargin: '0px',\n        threshold: 0\n    });\n    const findIndexRecursive = (scrollPos, lowIndex, highIndex)=>{\n        if (lowIndex > highIndex) {\n            // We shouldn't get here - but no-op the index if we do.\n            return actualIndex;\n        }\n        const midpoint = Math.floor((lowIndex + highIndex) / 2);\n        const iBefore = Math.max(midpoint - 1, 0);\n        const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n        const indexValue = childProgressiveSizes.current[midpoint];\n        const afterIndexValue = childProgressiveSizes.current[iAfter];\n        const beforeIndexValue = childProgressiveSizes.current[iBefore];\n        if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n            /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */ return midpoint;\n        }\n        if (indexValue > scrollPos) {\n            return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n        } else {\n            return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n        }\n    };\n    const getIndexFromSizeArray = (scrollPos)=>{\n        /* Quick searches our progressive height array */ if (scrollPos === 0 || childProgressiveSizes.current.length === 0 || scrollPos <= childProgressiveSizes.current[0]) {\n            // Check start\n            return 0;\n        }\n        if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n            // Check end\n            return childProgressiveSizes.current.length - 1;\n        }\n        return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n    };\n    const getIndexFromScrollPosition = (scrollPos)=>{\n        if (!getItemSize) {\n            return Math.round(scrollPos / itemSize);\n        }\n        return getIndexFromSizeArray(scrollPos);\n    };\n    const calculateTotalSize = useCallback(()=>{\n        if (!getItemSize) {\n            return itemSize * numItems;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1];\n    }, [\n        getItemSize,\n        itemSize,\n        numItems\n    ]);\n    const calculateBefore = useCallback(()=>{\n        const currentIndex = Math.min(actualIndex, numItems - 1);\n        if (!getItemSize) {\n            // The missing items from before virtualization starts height\n            return currentIndex * itemSize;\n        }\n        if (currentIndex <= 0) {\n            return 0;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[currentIndex - 1];\n    }, [\n        actualIndex,\n        getItemSize,\n        itemSize,\n        numItems\n    ]);\n    const calculateAfter = useCallback(()=>{\n        if (numItems === 0 || actualIndex + virtualizerLength >= numItems) {\n            return 0;\n        }\n        const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems);\n        if (!getItemSize) {\n            // The missing items from after virtualization ends height\n            const remainingItems = numItems - lastItemIndex;\n            return remainingItems * itemSize;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex - 1];\n    }, [\n        actualIndex,\n        getItemSize,\n        itemSize,\n        numItems,\n        virtualizerLength\n    ]);\n    const updateChildRows = useCallback((newIndex)=>{\n        if (numItems === 0) {\n            /* Nothing to virtualize */ return;\n        }\n        /*\n        We reset the array every time to ensure children are re-rendered\n        This function should only be called when update is nessecary\n       */ childArray.current = new Array(virtualizerLength);\n        const _actualIndex = Math.max(newIndex, 0);\n        const end = Math.min(_actualIndex + virtualizerLength, numItems);\n        for(let i = _actualIndex; i < end; i++){\n            childArray.current[i - _actualIndex] = renderVirtualizerChildPlaceholder(renderChild(i, isScrolling), i);\n        }\n    }, [\n        isScrolling,\n        numItems,\n        renderChild,\n        virtualizerLength\n    ]);\n    const setBeforeRef = useCallback((element)=>{\n        if (!element || beforeElementRef.current === element) {\n            return;\n        }\n        beforeElementRef.current = element;\n        const newList = [];\n        newList.push(beforeElementRef.current);\n        if (afterElementRef.current) {\n            newList.push(afterElementRef.current);\n        }\n        // Ensure we update array if before element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const setAfterRef = useCallback((element)=>{\n        if (!element || afterElementRef.current === element) {\n            return;\n        }\n        afterElementRef.current = element;\n        const newList = [];\n        if (beforeElementRef.current) {\n            newList.push(beforeElementRef.current);\n        }\n        newList.push(afterElementRef.current);\n        // Ensure we update array if after element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const updateCurrentItemSizes = (newIndex)=>{\n        if (!getItemSize) {\n            // Static sizes, not required.\n            return;\n        }\n        // We should always call our size function on index change (only for the items that will be rendered)\n        // This ensures we request the latest data for incoming items in case sizing has changed.\n        const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n        const startIndex = Math.max(newIndex, 0);\n        let didUpdate = false;\n        for(let i = startIndex; i < endIndex; i++){\n            const newSize = getItemSize(i);\n            if (newSize !== childSizes.current[i]) {\n                childSizes.current[i] = newSize;\n                didUpdate = true;\n            }\n        }\n        if (didUpdate) {\n            // Update our progressive size array\n            for(let i = startIndex; i < numItems; i++){\n                const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n                childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n            }\n        }\n    };\n    // Initialize the size array before first render.\n    const hasInitialized = useRef(false);\n    const initializeSizeArray = ()=>{\n        if (hasInitialized.current === false) {\n            hasInitialized.current = true;\n            populateSizeArrays();\n        }\n    };\n    useImperativeHandle(imperativeVirtualizerRef, ()=>{\n        return {\n            progressiveSizes: childProgressiveSizes,\n            nodeSizes: childSizes,\n            setFlaggedIndex: (index)=>flaggedIndex.current = index,\n            currentIndex: actualIndexRef\n        };\n    }, [\n        childProgressiveSizes,\n        childSizes\n    ]);\n    // Initialization on mount - update array index to 0 (ready state).\n    // Only fire on mount (no deps).\n    useEffect(()=>{\n        if (actualIndex < 0) {\n            batchUpdateNewIndex(0);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // If the user passes in an updated renderChild function - update current children\n    useEffect(()=>{\n        if (actualIndex >= 0) {\n            updateChildRows(actualIndex);\n            forceUpdate();\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        renderChild,\n        updateChildRows\n    ]);\n    useEffect(()=>{\n        // Ensure we repopulate if getItemSize callback changes\n        populateSizeArrays();\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        getItemSize\n    ]);\n    // Effect to check flag index on updates\n    useEffect(()=>{\n        if (!onRenderedFlaggedIndex || flaggedIndex.current === null) {\n            return;\n        }\n        if (actualIndex <= flaggedIndex.current && actualIndex + virtualizerLength >= flaggedIndex.current) {\n            onRenderedFlaggedIndex(flaggedIndex.current);\n            flaggedIndex.current = null;\n        }\n    }, [\n        actualIndex,\n        onRenderedFlaggedIndex,\n        virtualizerLength\n    ]);\n    // Ensure we have run through and updated the whole size list array at least once.\n    initializeSizeArray();\n    if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n        // Child length mismatch, repopulate size arrays.\n        populateSizeArrays();\n    }\n    // Ensure we recalc if virtualizer length changes\n    const maxCompare = Math.min(virtualizerLength, numItems);\n    if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n        updateChildRows(actualIndex);\n    }\n    const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n    return {\n        components: {\n            before: 'div',\n            after: 'div',\n            beforeContainer: 'div',\n            afterContainer: 'div'\n        },\n        virtualizedChildren: childArray.current,\n        before: resolveShorthand(props.before, {\n            required: true,\n            defaultProps: {\n                ref: setBeforeRef,\n                role: 'none'\n            }\n        }),\n        after: resolveShorthand(props.after, {\n            required: true,\n            defaultProps: {\n                ref: setAfterRef,\n                role: 'none'\n            }\n        }),\n        beforeContainer: resolveShorthand(props.beforeContainer, {\n            required: true,\n            defaultProps: {\n                role: 'none'\n            }\n        }),\n        afterContainer: resolveShorthand(props.afterContainer, {\n            required: true,\n            defaultProps: {\n                role: 'none'\n            }\n        }),\n        beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n        afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n        totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n        virtualizerStartIndex: actualIndex,\n        axis,\n        bufferSize,\n        reversed\n    };\n}\n"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","virtualizerContext","onRenderedFlaggedIndex","imperativeVirtualizerRef","_virtualizerContext","useVirtualizerContextState_unstable","actualIndexRef","useRef","contextIndex","current","flaggedIndex","actualIndex","setActualIndex","setContextIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","length","index","isScrolling","setIsScrolling","useState","scrollTimer","scrollCounter","initializeScrollingTimer","INIT_SCROLL_FLAG_REQ","INIT_SCROLL_FLAG_DELAY","clearTimeout","setTimeout","useEffect","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","useCallback","currentIndex","lastItemIndex","remainingItems","newIndex","_actualIndex","end","i","renderVirtualizerChildPlaceholder","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useImperativeHandle","progressiveSizes","nodeSizes","setFlaggedIndex","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","resolveShorthand","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"mappings":"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"}