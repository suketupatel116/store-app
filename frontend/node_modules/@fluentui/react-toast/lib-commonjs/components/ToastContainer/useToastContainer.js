"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useToastContainer_unstable", {
    enumerable: true,
    get: ()=>useToastContainer_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _timer = require("../Timer/Timer");
const _reactTabster = require("@fluentui/react-tabster");
const intentPolitenessMap = {
    success: 'assertive',
    warning: 'assertive',
    error: 'assertive',
    info: 'polite'
};
const useToastContainer_unstable = (props, ref)=>{
    const { visible , children , close: closeProp , remove , updateId , announce , data , timeout: timerTimeout , politeness: desiredPoliteness , intent ='info' , pauseOnHover , pauseOnWindowBlur , imperativeRef , tryRestoreFocus , ...rest } = props;
    const titleId = (0, _reactUtilities.useId)('toast-title');
    const bodyId = (0, _reactUtilities.useId)('toast-body');
    const toastRef = _react.useRef(null);
    const { targetDocument  } = (0, _reactSharedContexts.useFluent_unstable)();
    const [running, setRunning] = _react.useState(false);
    const imperativePauseRef = _react.useRef(false);
    const focusedToastBeforeClose = _react.useRef(false);
    const close = (0, _reactUtilities.useEventCallback)(()=>{
        var _toastRef_current;
        const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
        if (activeElement && ((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains(activeElement))) {
            focusedToastBeforeClose.current = true;
        }
        closeProp();
    });
    const onStatusChange = (0, _reactUtilities.useEventCallback)((status)=>{
        var _props_onStatusChange;
        return (_props_onStatusChange = props.onStatusChange) === null || _props_onStatusChange === void 0 ? void 0 : _props_onStatusChange.call(props, null, {
            status,
            ...props
        });
    });
    const pause = (0, _reactUtilities.useEventCallback)(()=>setRunning(false));
    const play = (0, _reactUtilities.useEventCallback)(()=>{
        var _toastRef_current;
        if (imperativePauseRef.current) {
            return;
        }
        var _targetDocument_activeElement;
        const containsActive = !!((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains((_targetDocument_activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) !== null && _targetDocument_activeElement !== void 0 ? _targetDocument_activeElement : null));
        if (timerTimeout < 0) {
            setRunning(true);
            return;
        }
        if (!containsActive) {
            setRunning(true);
        }
    });
    const { findFirstFocusable  } = (0, _reactTabster.useFocusFinders)();
    _react.useImperativeHandle(imperativeRef, ()=>({
            focus: ()=>{
                if (!toastRef.current) {
                    return;
                }
                const firstFocusable = findFirstFocusable(toastRef.current);
                if (firstFocusable) {
                    firstFocusable.focus();
                } else {
                    toastRef.current.focus();
                }
            },
            play: ()=>{
                imperativePauseRef.current = false;
                play();
            },
            pause: ()=>{
                imperativePauseRef.current = true;
                pause();
            }
        }));
    _react.useEffect(()=>{
        return ()=>onStatusChange('unmounted');
    }, [
        onStatusChange
    ]);
    _react.useEffect(()=>{
        if (!targetDocument) {
            return;
        }
        if (pauseOnWindowBlur) {
            var _targetDocument_defaultView, _targetDocument_defaultView1;
            (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.addEventListener('focus', play);
            (_targetDocument_defaultView1 = targetDocument.defaultView) === null || _targetDocument_defaultView1 === void 0 ? void 0 : _targetDocument_defaultView1.addEventListener('blur', pause);
            return ()=>{
                var _targetDocument_defaultView, _targetDocument_defaultView1;
                (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.removeEventListener('focus', play);
                (_targetDocument_defaultView1 = targetDocument.defaultView) === null || _targetDocument_defaultView1 === void 0 ? void 0 : _targetDocument_defaultView1.removeEventListener('blur', pause);
            };
        }
    }, [
        targetDocument,
        pause,
        play,
        pauseOnWindowBlur
    ]);
    // It's impossible to animate to height: auto in CSS, the actual pixel value must be known
    // Get the height of the toast before animation styles have been applied and set a CSS
    // variable with its height. The CSS variable will be used by the styles
    const onTransitionEntering = ()=>{
        if (!toastRef.current) {
            return;
        }
        const element = toastRef.current;
        element.style.setProperty('--fui-toast-height', `${element.scrollHeight}px`);
    };
    // Users never actually use ToastContainer as a JSX but imperatively through useToastContainerController
    const userRootSlot = data.root;
    // Using a ref callback here because addEventListener supports `once`
    const toastAnimationRef = _react.useCallback((el)=>{
        if (el && toastRef.current) {
            toastRef.current.addEventListener('animationend', ()=>{
                // start toast once it's fully animated in
                play();
                onStatusChange('visible');
            }, {
                once: true
            });
        }
    }, [
        play,
        onStatusChange
    ]);
    const onMouseEnter = (0, _reactUtilities.useEventCallback)((e)=>{
        var _userRootSlot_onMouseEnter;
        pause();
        userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
    });
    const onMouseLeave = (0, _reactUtilities.useEventCallback)((e)=>{
        var _userRootSlot_onMouseEnter;
        play();
        userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
    });
    const onKeyDown = (0, _reactUtilities.useEventCallback)((e)=>{
        var _userRootSlot_onKeyDown;
        if (e.key === 'Escape') {
            e.preventDefault();
            close();
        }
        userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onKeyDown = userRootSlot.onKeyDown) === null || _userRootSlot_onKeyDown === void 0 ? void 0 : _userRootSlot_onKeyDown.call(userRootSlot, e);
    });
    _react.useEffect(()=>{
        var _toastRef_current;
        if (!visible) {
            return;
        }
        const politeness = desiredPoliteness !== null && desiredPoliteness !== void 0 ? desiredPoliteness : intentPolitenessMap[intent];
        var _toastRef_current_textContent;
        announce((_toastRef_current_textContent = (_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.textContent) !== null && _toastRef_current_textContent !== void 0 ? _toastRef_current_textContent : '', {
            politeness
        });
    }, [
        announce,
        desiredPoliteness,
        toastRef,
        visible,
        updateId,
        intent
    ]);
    _react.useEffect(()=>{
        return ()=>{
            if (focusedToastBeforeClose.current) {
                focusedToastBeforeClose.current = false;
                tryRestoreFocus();
            }
        };
    }, [
        tryRestoreFocus
    ]);
    return {
        components: {
            timer: _timer.Timer,
            root: 'div'
        },
        timer: (0, _reactUtilities.resolveShorthand)({
            key: updateId,
            onTimeout: close,
            running,
            timeout: timerTimeout !== null && timerTimeout !== void 0 ? timerTimeout : -1
        }, {
            required: true
        }),
        root: (0, _reactUtilities.getNativeElementProps)('div', {
            ref: (0, _reactUtilities.useMergedRefs)(ref, toastRef, toastAnimationRef),
            children,
            tabIndex: -1,
            role: 'group',
            'aria-labelledby': titleId,
            'aria-describedby': bodyId,
            ...rest,
            ...userRootSlot,
            onMouseEnter,
            onMouseLeave,
            onKeyDown
        }),
        timerTimeout,
        transitionTimeout: 500,
        running,
        visible,
        remove,
        close,
        onTransitionEntering,
        updateId,
        nodeRef: toastRef,
        intent,
        titleId,
        bodyId
    };
};
