"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useToaster_unstable", {
    enumerable: true,
    get: ()=>useToaster_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactSharedContexts = require("@fluentui/react-shared-contexts");
const _state = require("../../state");
const _toastContainer = require("../ToastContainer");
const useToaster_unstable = (props)=>{
    const { offset , announce: announceProp , ...rest } = props;
    const announceRef = _react.useRef(()=>null);
    const { toastsToRender , isToastVisible , pauseAllToasts , playAllToasts , tryRestoreFocus  } = (0, _state.useToaster)(rest);
    const announce = _react.useCallback((message, options)=>announceRef.current(message, options), []);
    const { dir  } = (0, _reactSharedContexts.useFluent_unstable)();
    const rootProps = (0, _reactUtilities.getNativeElementProps)('div', rest);
    // Adds native HTML focusin/focusout listeners
    // https://github.com/facebook/react/issues/25194
    const focusListenerRef = _react.useCallback((el)=>{
        if (el) {
            el.addEventListener('focusin', (e)=>{
                if ((0, _reactUtilities.isHTMLElement)(e.currentTarget) && !e.currentTarget.contains((0, _reactUtilities.isHTMLElement)(e.relatedTarget) ? e.relatedTarget : null)) {
                    pauseAllToasts();
                }
            });
            el.addEventListener('focusout', (e)=>{
                if ((0, _reactUtilities.isHTMLElement)(e.currentTarget) && !e.currentTarget.contains((0, _reactUtilities.isHTMLElement)(e.relatedTarget) ? e.relatedTarget : null)) {
                    playAllToasts();
                    tryRestoreFocus();
                }
            });
        }
    }, [
        playAllToasts,
        pauseAllToasts,
        tryRestoreFocus
    ]);
    const createPositionSlot = (toastPosition)=>{
        var _toastsToRender_get;
        return (0, _reactUtilities.resolveShorthand)(toastsToRender.has(toastPosition) ? rootProps : null, {
            defaultProps: {
                ref: focusListenerRef,
                children: (_toastsToRender_get = toastsToRender.get(toastPosition)) === null || _toastsToRender_get === void 0 ? void 0 : _toastsToRender_get.map((toast)=>/*#__PURE__*/ _react.createElement(_toastContainer.ToastContainer, {
                        ...toast,
                        tryRestoreFocus: tryRestoreFocus,
                        intent: toast.intent,
                        announce: announce,
                        key: toast.toastId,
                        visible: isToastVisible(toast.toastId)
                    }, toast.content)),
                'data-toaster-position': toastPosition
            }
        });
    };
    return {
        dir,
        components: {
            root: 'div',
            bottomStart: 'div',
            bottomEnd: 'div',
            topStart: 'div',
            topEnd: 'div'
        },
        root: (0, _reactUtilities.resolveShorthand)(rootProps, {
            required: true
        }),
        bottomStart: createPositionSlot(_state.TOAST_POSITIONS.bottomStart),
        bottomEnd: createPositionSlot(_state.TOAST_POSITIONS.bottomEnd),
        topStart: createPositionSlot(_state.TOAST_POSITIONS.topStart),
        topEnd: createPositionSlot(_state.TOAST_POSITIONS.topEnd),
        announceRef,
        offset,
        announce: announceProp !== null && announceProp !== void 0 ? announceProp : announce,
        renderAriaLive: !announceProp
    };
};
