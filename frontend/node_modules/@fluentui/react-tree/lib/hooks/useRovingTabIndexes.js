import { useMergedRefs } from '@fluentui/react-utilities';
import * as React from 'react';
import { useHTMLElementWalkerRef } from './useHTMLElementWalker';
/**
 * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex
 */ export function useRovingTabIndex(filter) {
    const currentElementRef = React.useRef();
    const [walkerRef, rootRef] = useHTMLElementWalkerRef(filter);
    const rootRefCallback = (element)=>{
        if (!element) {
            return;
        }
        reset();
    };
    function reset() {
        if (!walkerRef.current) {
            return;
        }
        const walker = walkerRef.current;
        walker.currentElement = walker.root;
        let tabbableChild = walker.firstChild((element)=>element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
        walker.currentElement = walker.root;
        tabbableChild !== null && tabbableChild !== void 0 ? tabbableChild : tabbableChild = walker.firstChild();
        if (!tabbableChild) {
            if (process.env.NODE_ENV === 'development') {
                // eslint-disable-next-line no-console
                console.warn('useRovingTabIndexes: internal error, no tabbable element was found');
            }
            return;
        }
        tabbableChild.tabIndex = 0;
        currentElementRef.current = tabbableChild;
        let nextElement = null;
        while((nextElement = walker.nextElement()) && nextElement !== tabbableChild){
            nextElement.tabIndex = -1;
        }
    }
    function rove(nextElement) {
        if (!currentElementRef.current) {
            return;
        }
        currentElementRef.current.tabIndex = -1;
        nextElement.tabIndex = 0;
        nextElement.focus();
        currentElementRef.current = nextElement;
    }
    return [
        {
            rove,
            reset
        },
        useMergedRefs(rootRef, rootRefCallback)
    ];
}
