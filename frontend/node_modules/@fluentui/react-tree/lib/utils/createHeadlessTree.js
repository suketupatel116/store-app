/**
 * creates a list of virtual tree items
 * and provides a map to access each item by id
 */ export function createHeadlessTree(virtualTreeItemProps) {
    const root = createHeadlessTreeRootItem();
    const itemsPerValue = new Map([
        [
            root.value,
            root
        ]
    ]);
    const items = [];
    for(let index = 0; index < virtualTreeItemProps.length; index++){
        const { parentValue =virtualTreeRootId , ...treeItemProps } = virtualTreeItemProps[index];
        const nextItemProps = virtualTreeItemProps[index + 1];
        const currentParent = itemsPerValue.get(parentValue);
        if (!currentParent) {
            if (process.env.NODE_ENV === 'development') {
                // eslint-disable-next-line no-console
                console.error(`useHeadlessTree: item ${virtualTreeItemProps[index].value} is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized`);
            }
            break;
        }
        var _treeItemProps_itemType;
        const itemType = (_treeItemProps_itemType = treeItemProps.itemType) !== null && _treeItemProps_itemType !== void 0 ? _treeItemProps_itemType : treeItemProps.value === undefined || (nextItemProps === null || nextItemProps === void 0 ? void 0 : nextItemProps.parentValue) !== treeItemProps.value ? 'leaf' : 'branch';
        var _currentParent_level;
        const currentLevel = ((_currentParent_level = currentParent.level) !== null && _currentParent_level !== void 0 ? _currentParent_level : 0) + 1;
        const virtualTreeItem = {
            value: treeItemProps.value,
            getTreeItemProps: ()=>({
                    ...treeItemProps,
                    'aria-level': currentLevel,
                    'aria-posinset': currentChildrenSize,
                    'aria-setsize': currentParent.childrenValues.length,
                    itemType
                }),
            level: currentLevel,
            parentValue,
            childrenValues: [],
            index: -1
        };
        const currentChildrenSize = currentParent.childrenValues.push(virtualTreeItem.value);
        itemsPerValue.set(virtualTreeItem.value, virtualTreeItem);
        items.push(virtualTreeItem);
    }
    var _itemsPerValue_get_parentValue, _itemsPerValue_get;
    const virtualTreeItems = {
        root,
        size: items.length,
        getByIndex: (index)=>items[index],
        getParent: (key)=>{
            var _itemsPerValue_get1;
            return (_itemsPerValue_get = itemsPerValue.get((_itemsPerValue_get_parentValue = (_itemsPerValue_get1 = itemsPerValue.get(key)) === null || _itemsPerValue_get1 === void 0 ? void 0 : _itemsPerValue_get1.parentValue) !== null && _itemsPerValue_get_parentValue !== void 0 ? _itemsPerValue_get_parentValue : root.value)) !== null && _itemsPerValue_get !== void 0 ? _itemsPerValue_get : root;
        },
        get: (key)=>itemsPerValue.get(key),
        subtree: (key)=>HeadlessTreeSubtreeGenerator(key, virtualTreeItems),
        children: (key)=>HeadlessTreeChildrenGenerator(key, virtualTreeItems),
        ancestors: (key)=>HeadlessTreeAncestorsGenerator(key, virtualTreeItems),
        visibleItems: (openItems)=>HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems)
    };
    return virtualTreeItems;
}
export const virtualTreeRootId = '__fuiHeadlessTreeRoot';
function createHeadlessTreeRootItem() {
    return {
        parentValue: undefined,
        value: virtualTreeRootId,
        getTreeItemProps: ()=>{
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useHeadlessTree: internal error, trying to access treeitem props from invalid root element');
            }
            return {
                id: virtualTreeRootId,
                value: virtualTreeRootId,
                'aria-setsize': -1,
                'aria-level': -1,
                'aria-posinset': -1,
                itemType: 'branch'
            };
        },
        childrenValues: [],
        get index () {
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useHeadlessTree: internal error, trying to access treeitem props from invalid root element');
            }
            return -1;
        },
        level: 0
    };
}
/**
 * Generator that returns all subtree of a given virtual tree item
 * @param key the key of the item to get the subtree from
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function* HeadlessTreeSubtreeGenerator(key, virtualTreeItems) {
    const item = virtualTreeItems.get(key);
    if (!item || item.childrenValues.length === 0) {
        return [];
    }
    let counter = item.childrenValues.length;
    let index = item.index;
    while(counter > 0){
        const children = virtualTreeItems.getByIndex(++index);
        yield children;
        counter += children.childrenValues.length - 1;
    }
}
/**
 * Generator that returns all children of a given virtual tree item
 * @param key the key of the item to get the children from
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function* HeadlessTreeChildrenGenerator(key, virtualTreeItems) {
    const item = virtualTreeItems.get(key);
    if (!item || item.childrenValues.length === 0) {
        return;
    }
    for (const childValue of item.childrenValues){
        yield virtualTreeItems.get(childValue);
    }
}
/**
 * Generator that returns all ancestors of a given virtual tree item
 * @param key the key of the item to get the children from
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function* HeadlessTreeAncestorsGenerator(key, virtualTreeItems) {
    let parent = virtualTreeItems.getParent(key);
    while(parent !== virtualTreeItems.root){
        yield parent;
        parent = virtualTreeItems.getParent(parent.value);
    }
}
/**
 * Generator that returns all visible items of a given virtual tree
 * @param openItems the open items of the tree
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function* HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems) {
    for(let index = 0, visibleIndex = 0; index < virtualTreeItems.size; index++){
        const item = virtualTreeItems.getByIndex(index);
        if (isItemVisible(item, openItems, virtualTreeItems)) {
            item.index = visibleIndex++;
            yield item;
        } else {
            // Jump the amount of children the current item has, since those items will also be hidden
            index += item.childrenValues.length;
        }
    }
}
function isItemVisible(item, openItems, virtualTreeItems) {
    if (item.level === 1) {
        return true;
    }
    while(item.parentValue && item.parentValue !== virtualTreeItems.root.value){
        if (!openItems.has(item.parentValue)) {
            return false;
        }
        const parent = virtualTreeItems.get(item.parentValue);
        if (!parent) {
            return false;
        }
        item = parent;
    }
    return true;
}
