{"version":3,"sources":["createHeadlessTree.ts"],"sourcesContent":["import { TreeItemProps, TreeItemType, TreeItemValue } from '../TreeItem';\nimport { ImmutableSet } from './ImmutableSet';\n\nexport type HeadlessTreeItemProps = Omit<TreeItemProps, 'itemType' | 'value'> & {\n  value: TreeItemValue;\n  itemType?: TreeItemType;\n  parentValue?: TreeItemValue;\n};\n\n/**\n * The item that is returned by `createHeadlessTree`, it represents a wrapper around the properties provided to\n * `createHeadlessTree` but with extra information that might be useful on virtual tree scenarios\n */\nexport type HeadlessTreeItem<Props extends HeadlessTreeItemProps> = {\n  index: number;\n  level: number;\n  childrenValues: TreeItemValue[];\n  value: TreeItemValue;\n  parentValue: TreeItemValue | undefined;\n  getTreeItemProps(): Required<Pick<Props, 'value' | 'aria-setsize' | 'aria-level' | 'aria-posinset' | 'itemType'>> &\n    Omit<Props, 'parentValue'>;\n};\n\n/**\n * @internal\n */\nexport type HeadlessTree<Props extends HeadlessTreeItemProps> = {\n  size: number;\n  root: HeadlessTreeItem<HeadlessTreeItemProps>;\n  get(key: TreeItemValue): HeadlessTreeItem<Props> | undefined;\n  getParent(key: TreeItemValue): HeadlessTreeItem<Props>;\n  getByIndex(index: number): HeadlessTreeItem<Props>;\n  subtree(key: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n  children(key: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n  visibleItems(openItems: ImmutableSet<TreeItemValue>): IterableIterator<HeadlessTreeItem<Props>>;\n  ancestors(key: TreeItemValue): IterableIterator<HeadlessTreeItem<Props>>;\n};\n\n/**\n * creates a list of virtual tree items\n * and provides a map to access each item by id\n */\nexport function createHeadlessTree<Props extends HeadlessTreeItemProps>(\n  virtualTreeItemProps: Props[],\n): HeadlessTree<Props> {\n  const root = createHeadlessTreeRootItem();\n  const itemsPerValue = new Map<TreeItemValue, HeadlessTreeItem<HeadlessTreeItemProps>>([[root.value, root]]);\n  const items: HeadlessTreeItem<HeadlessTreeItemProps>[] = [];\n\n  for (let index = 0; index < virtualTreeItemProps.length; index++) {\n    const { parentValue = virtualTreeRootId, ...treeItemProps } = virtualTreeItemProps[index];\n\n    const nextItemProps: Props | undefined = virtualTreeItemProps[index + 1];\n    const currentParent = itemsPerValue.get(parentValue);\n    if (!currentParent) {\n      if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.error(\n          `useHeadlessTree: item ${virtualTreeItemProps[index].value} is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized`,\n        );\n      }\n      break;\n    }\n    const itemType =\n      treeItemProps.itemType ??\n      (treeItemProps.value === undefined || nextItemProps?.parentValue !== treeItemProps.value ? 'leaf' : 'branch');\n    const currentLevel = (currentParent.level ?? 0) + 1;\n\n    const virtualTreeItem: HeadlessTreeItem<HeadlessTreeItemProps> = {\n      value: treeItemProps.value,\n      getTreeItemProps: () => ({\n        ...treeItemProps,\n        'aria-level': currentLevel,\n        'aria-posinset': currentChildrenSize,\n        'aria-setsize': currentParent.childrenValues.length,\n        itemType,\n      }),\n      level: currentLevel,\n      parentValue,\n      childrenValues: [],\n      index: -1,\n    };\n    const currentChildrenSize = currentParent.childrenValues.push(virtualTreeItem.value);\n    itemsPerValue.set(virtualTreeItem.value, virtualTreeItem);\n    items.push(virtualTreeItem);\n  }\n\n  const virtualTreeItems: HeadlessTree<HeadlessTreeItemProps> = {\n    root,\n    size: items.length,\n    getByIndex: index => items[index],\n    getParent: key => itemsPerValue.get(itemsPerValue.get(key)?.parentValue ?? root.value) ?? root,\n    get: key => itemsPerValue.get(key),\n    subtree: key => HeadlessTreeSubtreeGenerator(key, virtualTreeItems),\n    children: key => HeadlessTreeChildrenGenerator(key, virtualTreeItems),\n    ancestors: key => HeadlessTreeAncestorsGenerator(key, virtualTreeItems),\n    visibleItems: openItems => HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems),\n  };\n\n  return virtualTreeItems as HeadlessTree<Props>;\n}\n\nexport const virtualTreeRootId = '__fuiHeadlessTreeRoot';\n\nfunction createHeadlessTreeRootItem(): HeadlessTreeItem<HeadlessTreeItemProps> {\n  return {\n    parentValue: undefined,\n    value: virtualTreeRootId,\n    getTreeItemProps: () => {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error('useHeadlessTree: internal error, trying to access treeitem props from invalid root element');\n      }\n      return {\n        id: virtualTreeRootId,\n        value: virtualTreeRootId,\n        'aria-setsize': -1,\n        'aria-level': -1,\n        'aria-posinset': -1,\n        itemType: 'branch',\n      };\n    },\n    childrenValues: [],\n    get index() {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.error('useHeadlessTree: internal error, trying to access treeitem props from invalid root element');\n      }\n      return -1;\n    },\n    level: 0,\n  };\n}\n\n/**\n * Generator that returns all subtree of a given virtual tree item\n * @param key the key of the item to get the subtree from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeSubtreeGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n) {\n  const item = virtualTreeItems.get(key);\n  if (!item || item.childrenValues.length === 0) {\n    return [];\n  }\n  let counter = item.childrenValues.length;\n  let index = item.index;\n  while (counter > 0) {\n    const children = virtualTreeItems.getByIndex(++index);\n    yield children;\n    counter += children.childrenValues.length - 1;\n  }\n}\n\n/**\n * Generator that returns all children of a given virtual tree item\n * @param key the key of the item to get the children from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeChildrenGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n) {\n  const item = virtualTreeItems.get(key);\n  if (!item || item.childrenValues.length === 0) {\n    return;\n  }\n  for (const childValue of item.childrenValues) {\n    yield virtualTreeItems.get(childValue)!;\n  }\n}\n\n/**\n * Generator that returns all ancestors of a given virtual tree item\n * @param key the key of the item to get the children from\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeAncestorsGenerator<Props extends HeadlessTreeItemProps>(\n  key: TreeItemValue,\n  virtualTreeItems: HeadlessTree<Props>,\n) {\n  let parent = virtualTreeItems.getParent(key);\n  while (parent !== virtualTreeItems.root) {\n    yield parent;\n    parent = virtualTreeItems.getParent(parent.value);\n  }\n}\n\n/**\n * Generator that returns all visible items of a given virtual tree\n * @param openItems the open items of the tree\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction* HeadlessTreeVisibleItemsGenerator<Props extends HeadlessTreeItemProps>(\n  openItems: ImmutableSet<TreeItemValue>,\n  virtualTreeItems: HeadlessTree<Props>,\n) {\n  for (let index = 0, visibleIndex = 0; index < virtualTreeItems.size; index++) {\n    const item = virtualTreeItems.getByIndex(index) as HeadlessTreeItem<Props>;\n    if (isItemVisible(item, openItems, virtualTreeItems)) {\n      item.index = visibleIndex++;\n      yield item;\n    } else {\n      // Jump the amount of children the current item has, since those items will also be hidden\n      index += item.childrenValues.length;\n    }\n  }\n}\n\nfunction isItemVisible(\n  item: HeadlessTreeItem<HeadlessTreeItemProps>,\n  openItems: ImmutableSet<TreeItemValue>,\n  virtualTreeItems: HeadlessTree<HeadlessTreeItemProps>,\n) {\n  if (item.level === 1) {\n    return true;\n  }\n  while (item.parentValue && item.parentValue !== virtualTreeItems.root.value) {\n    if (!openItems.has(item.parentValue)) {\n      return false;\n    }\n    const parent = virtualTreeItems.get(item.parentValue);\n    if (!parent) {\n      return false;\n    }\n    item = parent;\n  }\n  return true;\n}\n"],"names":["createHeadlessTree","virtualTreeItemProps","root","createHeadlessTreeRootItem","itemsPerValue","Map","value","items","index","length","parentValue","virtualTreeRootId","treeItemProps","nextItemProps","currentParent","get","process","env","NODE_ENV","console","error","itemType","undefined","currentLevel","level","virtualTreeItem","getTreeItemProps","currentChildrenSize","childrenValues","push","set","virtualTreeItems","size","getByIndex","getParent","key","subtree","HeadlessTreeSubtreeGenerator","children","HeadlessTreeChildrenGenerator","ancestors","HeadlessTreeAncestorsGenerator","visibleItems","openItems","HeadlessTreeVisibleItemsGenerator","id","item","counter","childValue","parent","visibleIndex","isItemVisible","has"],"mappings":"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"}