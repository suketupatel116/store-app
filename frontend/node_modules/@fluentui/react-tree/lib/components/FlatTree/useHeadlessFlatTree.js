import { useEventCallback, useMergedRefs } from '@fluentui/react-utilities';
import * as React from 'react';
import { createHeadlessTree } from '../../utils/createHeadlessTree';
import { treeDataTypes } from '../../utils/tokens';
import { useFlatTreeNavigation } from './useFlatTreeNavigation';
import { createNextOpenItems, useControllableOpenItems } from '../../hooks/useControllableOpenItems';
import { dataTreeItemValueAttrName } from '../../utils/getTreeItemValueFromElement';
import { createNextFlatCheckedItems, useFlatControllableCheckedItems } from './useFlatControllableCheckedItems';
/**
 * this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 * On simple scenarios it is advised to simply use a nested structure instead.
 *
 * @param flatTreeItemProps - a list of tree items
 * @param options - in case control over the internal openItems is required
 */ export function useHeadlessFlatTree_unstable(flatTreeItemProps, options = {}) {
    const flatTreeItems = React.useMemo(()=>createHeadlessTree(flatTreeItemProps), [
        flatTreeItemProps
    ]);
    const [openItems, setOpenItems] = useControllableOpenItems(options);
    const [checkedItems, setCheckedItems] = useFlatControllableCheckedItems(options);
    const [navigate, navigationRef] = useFlatTreeNavigation(flatTreeItems);
    const treeRef = React.useRef(null);
    const handleOpenChange = useEventCallback((event, data)=>{
        var _options_onOpenChange;
        (_options_onOpenChange = options.onOpenChange) === null || _options_onOpenChange === void 0 ? void 0 : _options_onOpenChange.call(options, event, data);
        setOpenItems(createNextOpenItems(data, openItems));
    });
    const handleCheckedChange = useEventCallback((event, data)=>{
        var _options_onCheckedChange;
        (_options_onCheckedChange = options.onCheckedChange) === null || _options_onCheckedChange === void 0 ? void 0 : _options_onCheckedChange.call(options, event, data);
        setCheckedItems(createNextFlatCheckedItems(data, checkedItems, flatTreeItems));
    });
    const handleNavigation = useEventCallback((event, data)=>{
        var _options_onNavigation_unstable;
        (_options_onNavigation_unstable = options.onNavigation_unstable) === null || _options_onNavigation_unstable === void 0 ? void 0 : _options_onNavigation_unstable.call(options, event, data);
        navigate(data);
    });
    const getNextNavigableItem = useEventCallback((visibleItems, data)=>{
        const item = flatTreeItems.get(data.value);
        if (item) {
            switch(data.type){
                case treeDataTypes.TypeAhead:
                    return item;
                case treeDataTypes.ArrowLeft:
                    return flatTreeItems.get(item.parentValue);
                case treeDataTypes.ArrowRight:
                    return visibleItems[item.index + 1];
                case treeDataTypes.End:
                    return visibleItems[visibleItems.length - 1];
                case treeDataTypes.Home:
                    return visibleItems[0];
                case treeDataTypes.ArrowDown:
                    return visibleItems[item.index + 1];
                case treeDataTypes.ArrowUp:
                    return visibleItems[item.index - 1];
            }
        }
    });
    const getElementFromItem = React.useCallback((item)=>{
        var _treeRef_current;
        return (_treeRef_current = treeRef.current) === null || _treeRef_current === void 0 ? void 0 : _treeRef_current.querySelector(`[${dataTreeItemValueAttrName}="${item.value}"]`);
    }, []);
    const ref = useMergedRefs(treeRef, navigationRef);
    const getTreeProps = React.useCallback(()=>({
            ref,
            openItems,
            selectionMode: options.selectionMode,
            checkedItems,
            onOpenChange: handleOpenChange,
            onCheckedChange: handleCheckedChange,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            onNavigation_unstable: handleNavigation
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        openItems,
        checkedItems
    ]);
    const items = React.useCallback(()=>flatTreeItems.visibleItems(openItems), [
        openItems,
        flatTreeItems
    ]);
    return React.useMemo(()=>({
            navigate,
            getTreeProps,
            getNextNavigableItem,
            getElementFromItem,
            items
        }), [
        navigate,
        getTreeProps,
        getNextNavigableItem,
        getElementFromItem,
        items
    ]);
}
