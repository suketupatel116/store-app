import * as React from 'react';
import { getNativeElementProps, useId, useMergedRefs } from '@fluentui/react-utilities';
import { useEventCallback } from '@fluentui/react-utilities';
import { elementContains } from '@fluentui/react-portal';
import { useTreeContext_unstable } from '../../contexts/index';
import { dataTreeItemValueAttrName } from '../../utils/getTreeItemValueFromElement';
import { Space } from '@fluentui/keyboard-keys';
import { treeDataTypes } from '../../utils/tokens';
/**
 * Create the state required to render TreeItem.
 *
 * The returned state can be modified with hooks such as useTreeItemStyles_unstable,
 * before being passed to renderTreeItem_unstable.
 *
 * @param props - props from this instance of TreeItem
 * @param ref - reference to root HTMLElement of TreeItem
 */ export function useTreeItem_unstable(props, ref) {
    var _props_value;
    const contextLevel = useTreeContext_unstable((ctx)=>ctx.level);
    // note, if the value is not externally provided,
    // then selection and expansion will not work properly
    const value = useId('fuiTreeItemValue-', (_props_value = props.value) === null || _props_value === void 0 ? void 0 : _props_value.toString());
    const { onClick , onKeyDown , as ='div' , itemType ='leaf' , 'aria-level': level = contextLevel , ...rest } = props;
    const requestTreeResponse = useTreeContext_unstable((ctx)=>ctx.requestTreeResponse);
    const [isActionsVisible, setActionsVisible] = React.useState(false);
    const [isAsideVisible, setAsideVisible] = React.useState(true);
    const handleActionsRef = (actionsElement)=>{
        setAsideVisible(actionsElement === null);
    };
    const actionsRef = React.useRef(null);
    const expandIconRef = React.useRef(null);
    const layoutRef = React.useRef(null);
    const subtreeRef = React.useRef(null);
    const selectionRef = React.useRef(null);
    const open = useTreeContext_unstable((ctx)=>ctx.openItems.has(value));
    var _ctx_checkedItems_get;
    const checked = useTreeContext_unstable((ctx)=>(_ctx_checkedItems_get = ctx.checkedItems.get(value)) !== null && _ctx_checkedItems_get !== void 0 ? _ctx_checkedItems_get : false);
    const selectionMode = useTreeContext_unstable((ctx)=>ctx.selectionMode);
    const handleClick = useEventCallback((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        const isEventFromActions = actionsRef.current && elementContains(actionsRef.current, event.target);
        if (isEventFromActions) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && elementContains(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        const isEventFromSelection = selectionRef.current && elementContains(selectionRef.current, event.target);
        if (isEventFromSelection) {
            return;
        }
        const isFromExpandIcon = expandIconRef.current && elementContains(expandIconRef.current, event.target);
        requestTreeResponse({
            event,
            value,
            itemType,
            target: event.currentTarget,
            type: isFromExpandIcon ? treeDataTypes.ExpandIconClick : treeDataTypes.Click
        });
    });
    const handleKeyDown = useEventCallback((event)=>{
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
        // Ignore keyboard events that do not originate from the current tree item.
        if (event.isDefaultPrevented() || event.currentTarget !== event.target) {
            return;
        }
        switch(event.key){
            case Space:
                if (selectionMode !== 'none') {
                    var _selectionRef_current;
                    (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.click();
                    event.preventDefault();
                }
                return;
            case treeDataTypes.End:
            case treeDataTypes.Home:
            case treeDataTypes.Enter:
            case treeDataTypes.ArrowUp:
            case treeDataTypes.ArrowDown:
            case treeDataTypes.ArrowLeft:
            case treeDataTypes.ArrowRight:
                return requestTreeResponse({
                    event,
                    target: event.currentTarget,
                    value,
                    itemType,
                    type: event.key
                });
        }
        const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
        if (isTypeAheadCharacter) {
            requestTreeResponse({
                event,
                target: event.currentTarget,
                value,
                itemType,
                type: treeDataTypes.TypeAhead
            });
        }
    });
    const handleActionsVisible = useEventCallback((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));
        if (!isTargetFromSubtree) {
            setActionsVisible(true);
        }
    });
    const handleActionsInvisible = useEventCallback((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));
        const isRelatedTargetFromActions = Boolean(actionsRef.current && elementContains(actionsRef.current, event.relatedTarget));
        if (isRelatedTargetFromActions) {
            return setActionsVisible(true);
        }
        if (!isTargetFromSubtree) {
            return setActionsVisible(false);
        }
    });
    const handleChange = useEventCallback((event)=>{
        if (event.isDefaultPrevented()) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && elementContains(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        requestTreeResponse({
            event,
            value,
            itemType,
            type: 'Change',
            target: event.currentTarget
        });
    });
    const isBranch = itemType === 'branch';
    return {
        value,
        open,
        subtreeRef,
        layoutRef,
        selectionRef,
        expandIconRef,
        actionsRef: useMergedRefs(handleActionsRef, actionsRef),
        itemType,
        level,
        components: {
            root: 'div'
        },
        isAsideVisible,
        isActionsVisible,
        root: getNativeElementProps(as, {
            tabIndex: -1,
            ...rest,
            ref,
            role: 'treeitem',
            'aria-level': level,
            [dataTreeItemValueAttrName]: value,
            'aria-checked': selectionMode === 'multiselect' ? checked : undefined,
            'aria-selected': selectionMode === 'single' ? checked : undefined,
            'aria-expanded': isBranch ? open : undefined,
            onClick: handleClick,
            onKeyDown: handleKeyDown,
            onMouseOver: handleActionsVisible,
            onFocus: handleActionsVisible,
            onMouseOut: handleActionsInvisible,
            onBlur: handleActionsInvisible,
            onChange: handleChange
        })
    };
}
