"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTree_unstable", {
    enumerable: true,
    get: ()=>useTree_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _useControllableOpenItems = require("../../hooks/useControllableOpenItems");
const _useTreeNavigation = require("./useTreeNavigation");
const _useControllableCheckedItems = require("./useControllableCheckedItems");
const _treeContext = require("../../contexts/treeContext");
const _useRootTree = require("../../hooks/useRootTree");
const _useSubtree = require("../../hooks/useSubtree");
const useTree_unstable = (props, ref)=>{
    const [openItems, setOpenItems] = (0, _useControllableOpenItems.useControllableOpenItems)(props);
    const [checkedItems] = (0, _useControllableCheckedItems.useControllableCheckedItems)(props);
    const [navigate, navigationRef] = (0, _useTreeNavigation.useTreeNavigation)();
    const handleOpenChange = (0, _reactUtilities.useEventCallback)((event, data)=>{
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, data);
        setOpenItems((0, _useControllableOpenItems.createNextOpenItems)(data, openItems));
    });
    const handleCheckedChange = (0, _reactUtilities.useEventCallback)((event, data)=>{
        var _props_onCheckedChange;
        (_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 ? void 0 : _props_onCheckedChange.call(props, event, data);
    // TODO: implement next checked items for  tree
    });
    const handleNavigation = (0, _reactUtilities.useEventCallback)((event, data)=>{
        var _props_onNavigation_unstable;
        (_props_onNavigation_unstable = props.onNavigation_unstable) === null || _props_onNavigation_unstable === void 0 ? void 0 : _props_onNavigation_unstable.call(props, event, data);
        navigate(data);
    });
    const baseProps = {
        ...props,
        openItems,
        checkedItems,
        onOpenChange: handleOpenChange,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        onNavigation_unstable: handleNavigation,
        onCheckedChange: handleCheckedChange
    };
    const baseRef = (0, _reactUtilities.useMergedRefs)(ref, navigationRef);
    const isSubtree = (0, _treeContext.useTreeContext_unstable)((ctx)=>ctx.level > 0);
    // as isSubTree is static, this doesn't break rule of hooks
    // and if this becomes an issue later on, this can be easily converted
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return isSubtree ? (0, _useSubtree.useSubtree)(baseProps, baseRef) : (0, _useRootTree.useRootTree)(baseProps, baseRef);
};
