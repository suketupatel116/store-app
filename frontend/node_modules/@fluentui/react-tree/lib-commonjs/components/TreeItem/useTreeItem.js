"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTreeItem_unstable", {
    enumerable: true,
    get: ()=>useTreeItem_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactPortal = require("@fluentui/react-portal");
const _index = require("../../contexts/index");
const _getTreeItemValueFromElement = require("../../utils/getTreeItemValueFromElement");
const _keyboardKeys = require("@fluentui/keyboard-keys");
const _tokens = require("../../utils/tokens");
function useTreeItem_unstable(props, ref) {
    var _props_value;
    const contextLevel = (0, _index.useTreeContext_unstable)((ctx)=>ctx.level);
    // note, if the value is not externally provided,
    // then selection and expansion will not work properly
    const value = (0, _reactUtilities.useId)('fuiTreeItemValue-', (_props_value = props.value) === null || _props_value === void 0 ? void 0 : _props_value.toString());
    const { onClick , onKeyDown , as ='div' , itemType ='leaf' , 'aria-level': level = contextLevel , ...rest } = props;
    const requestTreeResponse = (0, _index.useTreeContext_unstable)((ctx)=>ctx.requestTreeResponse);
    const [isActionsVisible, setActionsVisible] = _react.useState(false);
    const [isAsideVisible, setAsideVisible] = _react.useState(true);
    const handleActionsRef = (actionsElement)=>{
        setAsideVisible(actionsElement === null);
    };
    const actionsRef = _react.useRef(null);
    const expandIconRef = _react.useRef(null);
    const layoutRef = _react.useRef(null);
    const subtreeRef = _react.useRef(null);
    const selectionRef = _react.useRef(null);
    const open = (0, _index.useTreeContext_unstable)((ctx)=>ctx.openItems.has(value));
    var _ctx_checkedItems_get;
    const checked = (0, _index.useTreeContext_unstable)((ctx)=>(_ctx_checkedItems_get = ctx.checkedItems.get(value)) !== null && _ctx_checkedItems_get !== void 0 ? _ctx_checkedItems_get : false);
    const selectionMode = (0, _index.useTreeContext_unstable)((ctx)=>ctx.selectionMode);
    const handleClick = (0, _reactUtilities.useEventCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        const isEventFromActions = actionsRef.current && (0, _reactPortal.elementContains)(actionsRef.current, event.target);
        if (isEventFromActions) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        const isEventFromSelection = selectionRef.current && (0, _reactPortal.elementContains)(selectionRef.current, event.target);
        if (isEventFromSelection) {
            return;
        }
        const isFromExpandIcon = expandIconRef.current && (0, _reactPortal.elementContains)(expandIconRef.current, event.target);
        requestTreeResponse({
            event,
            value,
            itemType,
            target: event.currentTarget,
            type: isFromExpandIcon ? _tokens.treeDataTypes.ExpandIconClick : _tokens.treeDataTypes.Click
        });
    });
    const handleKeyDown = (0, _reactUtilities.useEventCallback)((event)=>{
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
        // Ignore keyboard events that do not originate from the current tree item.
        if (event.isDefaultPrevented() || event.currentTarget !== event.target) {
            return;
        }
        switch(event.key){
            case _keyboardKeys.Space:
                if (selectionMode !== 'none') {
                    var _selectionRef_current;
                    (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.click();
                    event.preventDefault();
                }
                return;
            case _tokens.treeDataTypes.End:
            case _tokens.treeDataTypes.Home:
            case _tokens.treeDataTypes.Enter:
            case _tokens.treeDataTypes.ArrowUp:
            case _tokens.treeDataTypes.ArrowDown:
            case _tokens.treeDataTypes.ArrowLeft:
            case _tokens.treeDataTypes.ArrowRight:
                return requestTreeResponse({
                    event,
                    target: event.currentTarget,
                    value,
                    itemType,
                    type: event.key
                });
        }
        const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
        if (isTypeAheadCharacter) {
            requestTreeResponse({
                event,
                target: event.currentTarget,
                value,
                itemType,
                type: _tokens.treeDataTypes.TypeAhead
            });
        }
    });
    const handleActionsVisible = (0, _reactUtilities.useEventCallback)((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target));
        if (!isTargetFromSubtree) {
            setActionsVisible(true);
        }
    });
    const handleActionsInvisible = (0, _reactUtilities.useEventCallback)((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target));
        const isRelatedTargetFromActions = Boolean(actionsRef.current && (0, _reactPortal.elementContains)(actionsRef.current, event.relatedTarget));
        if (isRelatedTargetFromActions) {
            return setActionsVisible(true);
        }
        if (!isTargetFromSubtree) {
            return setActionsVisible(false);
        }
    });
    const handleChange = (0, _reactUtilities.useEventCallback)((event)=>{
        if (event.isDefaultPrevented()) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        requestTreeResponse({
            event,
            value,
            itemType,
            type: 'Change',
            target: event.currentTarget
        });
    });
    const isBranch = itemType === 'branch';
    return {
        value,
        open,
        subtreeRef,
        layoutRef,
        selectionRef,
        expandIconRef,
        actionsRef: (0, _reactUtilities.useMergedRefs)(handleActionsRef, actionsRef),
        itemType,
        level,
        components: {
            root: 'div'
        },
        isAsideVisible,
        isActionsVisible,
        root: (0, _reactUtilities.getNativeElementProps)(as, {
            tabIndex: -1,
            ...rest,
            ref,
            role: 'treeitem',
            'aria-level': level,
            [_getTreeItemValueFromElement.dataTreeItemValueAttrName]: value,
            'aria-checked': selectionMode === 'multiselect' ? checked : undefined,
            'aria-selected': selectionMode === 'single' ? checked : undefined,
            'aria-expanded': isBranch ? open : undefined,
            onClick: handleClick,
            onKeyDown: handleKeyDown,
            onMouseOver: handleActionsVisible,
            onFocus: handleActionsVisible,
            onMouseOut: handleActionsInvisible,
            onBlur: handleActionsInvisible,
            onChange: handleChange
        })
    };
}
