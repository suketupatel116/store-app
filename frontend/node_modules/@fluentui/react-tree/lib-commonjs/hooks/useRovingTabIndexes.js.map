{"version":3,"sources":["useRovingTabIndexes.js"],"sourcesContent":["import { useMergedRefs } from '@fluentui/react-utilities';\nimport * as React from 'react';\nimport { useHTMLElementWalkerRef } from './useHTMLElementWalker';\n/**\n * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex\n */ export function useRovingTabIndex(filter) {\n    const currentElementRef = React.useRef();\n    const [walkerRef, rootRef] = useHTMLElementWalkerRef(filter);\n    const rootRefCallback = (element)=>{\n        if (!element) {\n            return;\n        }\n        reset();\n    };\n    function reset() {\n        if (!walkerRef.current) {\n            return;\n        }\n        const walker = walkerRef.current;\n        walker.currentElement = walker.root;\n        let tabbableChild = walker.firstChild((element)=>element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n        walker.currentElement = walker.root;\n        tabbableChild !== null && tabbableChild !== void 0 ? tabbableChild : tabbableChild = walker.firstChild();\n        if (!tabbableChild) {\n            if (process.env.NODE_ENV === 'development') {\n                // eslint-disable-next-line no-console\n                console.warn('useRovingTabIndexes: internal error, no tabbable element was found');\n            }\n            return;\n        }\n        tabbableChild.tabIndex = 0;\n        currentElementRef.current = tabbableChild;\n        let nextElement = null;\n        while((nextElement = walker.nextElement()) && nextElement !== tabbableChild){\n            nextElement.tabIndex = -1;\n        }\n    }\n    function rove(nextElement) {\n        if (!currentElementRef.current) {\n            return;\n        }\n        currentElementRef.current.tabIndex = -1;\n        nextElement.tabIndex = 0;\n        nextElement.focus();\n        currentElementRef.current = nextElement;\n    }\n    return [\n        {\n            rove,\n            reset\n        },\n        useMergedRefs(rootRef, rootRefCallback)\n    ];\n}\n"],"names":["useRovingTabIndex","filter","currentElementRef","React","useRef","walkerRef","rootRef","useHTMLElementWalkerRef","rootRefCallback","element","reset","current","walker","currentElement","root","tabbableChild","firstChild","tabIndex","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","process","env","NODE_ENV","console","warn","nextElement","rove","focus","useMergedRefs"],"mappings":";;;;+BAKoBA;;aAAAA;;;gCALU;6DACP;sCACiB;AAG7B,SAASA,kBAAkBC,MAAM,EAAE;IAC1C,MAAMC,oBAAoBC,OAAMC,MAAM;IACtC,MAAM,CAACC,WAAWC,QAAQ,GAAGC,IAAAA,6CAAuB,EAACN;IACrD,MAAMO,kBAAkB,CAACC,UAAU;QAC/B,IAAI,CAACA,SAAS;YACV;QACJ,CAAC;QACDC;IACJ;IACA,SAASA,QAAQ;QACb,IAAI,CAACL,UAAUM,OAAO,EAAE;YACpB;QACJ,CAAC;QACD,MAAMC,SAASP,UAAUM,OAAO;QAChCC,OAAOC,cAAc,GAAGD,OAAOE,IAAI;QACnC,IAAIC,gBAAgBH,OAAOI,UAAU,CAAC,CAACP,UAAUA,QAAQQ,QAAQ,KAAK,IAAIC,WAAWC,aAAa,GAAGD,WAAWE,WAAW;QAC3HR,OAAOC,cAAc,GAAGD,OAAOE,IAAI;QACnCC,kBAAkB,IAAI,IAAIA,kBAAkB,KAAK,IAAIA,gBAAgBA,gBAAgBH,OAAOI,UAAU,EAAE;QACxG,IAAI,CAACD,eAAe;YAChB,IAAIM,QAAQC,GAAG,CAACC,QAAQ,KAAK,eAAe;gBACxC,sCAAsC;gBACtCC,QAAQC,IAAI,CAAC;YACjB,CAAC;YACD;QACJ,CAAC;QACDV,cAAcE,QAAQ,GAAG;QACzBf,kBAAkBS,OAAO,GAAGI;QAC5B,IAAIW,cAAc,IAAI;QACtB,MAAM,AAACA,CAAAA,cAAcd,OAAOc,WAAW,EAAC,KAAMA,gBAAgBX,cAAc;YACxEW,YAAYT,QAAQ,GAAG,CAAC;QAC5B;IACJ;IACA,SAASU,KAAKD,WAAW,EAAE;QACvB,IAAI,CAACxB,kBAAkBS,OAAO,EAAE;YAC5B;QACJ,CAAC;QACDT,kBAAkBS,OAAO,CAACM,QAAQ,GAAG,CAAC;QACtCS,YAAYT,QAAQ,GAAG;QACvBS,YAAYE,KAAK;QACjB1B,kBAAkBS,OAAO,GAAGe;IAChC;IACA,OAAO;QACH;YACIC;YACAjB;QACJ;QACAmB,IAAAA,6BAAa,EAACvB,SAASE;KAC1B;AACL"}