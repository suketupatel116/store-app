{"version":3,"sources":["useTooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport {\n  useTooltipVisibility_unstable as useTooltipVisibility,\n  useFluent_unstable as useFluent,\n} from '@fluentui/react-shared-contexts';\nimport {\n  applyTriggerPropsToChildren,\n  resolveShorthand,\n  useControllableState,\n  useId,\n  useIsomorphicLayoutEffect,\n  useIsSSR,\n  useMergedRefs,\n  useTimeout,\n  getTriggerChild,\n  mergeCallbacks,\n  useEventCallback,\n} from '@fluentui/react-utilities';\nimport type { TooltipProps, TooltipState, TooltipChildProps } from './Tooltip.types';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */\nexport const useTooltip_unstable = (props: TooltipProps): TooltipState => {\n  const context = useTooltipVisibility();\n  const isServerSideRender = useIsSSR();\n  const { targetDocument } = useFluent();\n  const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n\n  const {\n    appearance = 'normal',\n    children,\n    content,\n    withArrow = false,\n    positioning = 'above',\n    onVisibleChange,\n    relationship,\n    showDelay = 250,\n    hideDelay = 250,\n    mountNode,\n  } = props;\n\n  const [visible, setVisibleInternal] = useControllableState({ state: props.visible, initialState: false });\n  const setVisible = React.useCallback(\n    (newVisible: boolean, ev?: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      clearDelayTimeout();\n      setVisibleInternal(oldVisible => {\n        if (newVisible !== oldVisible) {\n          onVisibleChange?.(ev, { visible: newVisible });\n        }\n        return newVisible;\n      });\n    },\n    [clearDelayTimeout, setVisibleInternal, onVisibleChange],\n  );\n\n  const state: TooltipState = {\n    withArrow,\n    positioning,\n    showDelay,\n    hideDelay,\n    relationship,\n    visible,\n    shouldRenderTooltip: visible,\n    appearance,\n    mountNode,\n    // Slots\n    components: {\n      content: 'div',\n    },\n    content: resolveShorthand(content, {\n      defaultProps: {\n        role: 'tooltip',\n      },\n      required: true,\n    }),\n  };\n\n  state.content.id = useId('tooltip-', state.content.id);\n\n  const positioningOptions = {\n    enabled: state.visible,\n    arrowPadding: 2 * tooltipBorderRadius,\n    position: 'above' as const,\n    align: 'center' as const,\n    offset: 4,\n    ...resolvePositioningShorthand(state.positioning),\n  };\n\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n  }\n\n  const {\n    targetRef,\n    containerRef,\n    arrowRef,\n  }: {\n    targetRef: React.MutableRefObject<unknown>;\n    containerRef: React.MutableRefObject<HTMLDivElement>;\n    arrowRef: React.MutableRefObject<HTMLDivElement>;\n  } = usePositioning(positioningOptions);\n\n  state.content.ref = useMergedRefs(state.content.ref, containerRef);\n  state.arrowRef = arrowRef;\n\n  // When this tooltip is visible, hide any other tooltips, and register it\n  // as the visibleTooltip with the TooltipContext.\n  // Also add a listener on document to hide the tooltip if Escape is pressed\n  useIsomorphicLayoutEffect(() => {\n    if (visible) {\n      const thisTooltip = { hide: () => setVisible(false) };\n\n      context.visibleTooltip?.hide();\n      context.visibleTooltip = thisTooltip;\n\n      const onDocumentKeyDown = (ev: KeyboardEvent) => {\n        if (ev.key === Escape) {\n          thisTooltip.hide();\n          // stop propagation to avoid conflicting with other elements that listen for `Escape`\n          // e,g: Dialog, Popover, Menu\n          ev.stopPropagation();\n        }\n      };\n\n      targetDocument?.addEventListener('keydown', onDocumentKeyDown, {\n        // As this event is added at targeted document,\n        // we need to capture the event to be sure keydown handling from tooltip happens first\n        capture: true,\n      });\n\n      return () => {\n        if (context.visibleTooltip === thisTooltip) {\n          context.visibleTooltip = undefined;\n        }\n\n        targetDocument?.removeEventListener('keydown', onDocumentKeyDown, { capture: true });\n      };\n    }\n  }, [context, targetDocument, visible, setVisible]);\n\n  // The focused element gets a blur event when the document loses focus\n  // (e.g. switching tabs in the browser), but we don't want to show the\n  // tooltip again when the document gets focus back. Handle this case by\n  // checking if the blurred element is still the document's activeElement.\n  // See https://github.com/microsoft/fluentui/issues/13541\n  const ignoreNextFocusEventRef = React.useRef(false);\n\n  // Listener for onPointerEnter and onFocus on the trigger element\n  const onEnterTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n        ignoreNextFocusEventRef.current = false;\n        return;\n      }\n\n      // Show immediately if another tooltip is already visible\n      const delay = context.visibleTooltip ? 0 : state.showDelay;\n\n      setDelayTimeout(() => {\n        setVisible(true, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.showDelay, context],\n  );\n\n  // Listener for onPointerLeave and onBlur on the trigger element\n  const onLeaveTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      let delay = state.hideDelay;\n\n      if (ev.type === 'blur') {\n        // Hide immediately when losing focus\n        delay = 0;\n\n        ignoreNextFocusEventRef.current = targetDocument?.activeElement === ev.target;\n      }\n\n      setDelayTimeout(() => {\n        setVisible(false, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.hideDelay, targetDocument],\n  );\n\n  // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n\n  const child = getTriggerChild(children);\n\n  const triggerAriaProps: Pick<TooltipChildProps, 'aria-label' | 'aria-labelledby' | 'aria-describedby'> = {};\n\n  if (relationship === 'label') {\n    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n    if (typeof state.content.children === 'string') {\n      triggerAriaProps['aria-label'] = state.content.children;\n    } else {\n      triggerAriaProps['aria-labelledby'] = state.content.id;\n      // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n      state.shouldRenderTooltip = true;\n    }\n  } else if (relationship === 'description') {\n    triggerAriaProps['aria-describedby'] = state.content.id;\n    // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n    state.shouldRenderTooltip = true;\n  }\n\n  // Don't render the Tooltip in SSR to avoid hydration errors\n  if (isServerSideRender) {\n    state.shouldRenderTooltip = false;\n  }\n\n  const childTargetRef = useMergedRefs(child?.ref, targetRef);\n\n  // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n  state.children = applyTriggerPropsToChildren(children, {\n    ...triggerAriaProps,\n    ...child?.props,\n    // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n    ref: positioningOptions.target === undefined ? childTargetRef : child?.ref,\n    onPointerEnter: useEventCallback(mergeCallbacks(child?.props?.onPointerEnter, onEnterTrigger)),\n    onPointerLeave: useEventCallback(mergeCallbacks(child?.props?.onPointerLeave, onLeaveTrigger)),\n    onFocus: useEventCallback(mergeCallbacks(child?.props?.onFocus, onEnterTrigger)),\n    onBlur: useEventCallback(mergeCallbacks(child?.props?.onBlur, onLeaveTrigger)),\n  });\n\n  return state;\n};\n"],"names":["React","mergeArrowOffset","resolvePositioningShorthand","usePositioning","useTooltipVisibility_unstable","useTooltipVisibility","useFluent_unstable","useFluent","applyTriggerPropsToChildren","resolveShorthand","useControllableState","useId","useIsomorphicLayoutEffect","useIsSSR","useMergedRefs","useTimeout","getTriggerChild","mergeCallbacks","useEventCallback","arrowHeight","tooltipBorderRadius","Escape","useTooltip_unstable","props","child","context","isServerSideRender","targetDocument","setDelayTimeout","clearDelayTimeout","appearance","children","content","withArrow","positioning","onVisibleChange","relationship","showDelay","hideDelay","mountNode","visible","setVisibleInternal","state","initialState","setVisible","useCallback","newVisible","ev","oldVisible","shouldRenderTooltip","components","defaultProps","role","required","id","positioningOptions","enabled","arrowPadding","position","align","offset","targetRef","containerRef","arrowRef","ref","thisTooltip","hide","visibleTooltip","onDocumentKeyDown","key","stopPropagation","addEventListener","capture","undefined","removeEventListener","ignoreNextFocusEventRef","useRef","onEnterTrigger","type","current","delay","persist","onLeaveTrigger","activeElement","target","onPointerEnter","onPointerLeave","onFocus","onBlur","triggerAriaProps","childTargetRef"],"mappings":"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"}