"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useDisposable: () => useDisposable,
  useIsStrictMode: () => useIsStrictMode
});
module.exports = __toCommonJS(src_exports);

// src/useIsStrictMode.ts
var React = __toESM(require("react"), 1);
var getCurrentOwner = () => React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var useIsStrictMode = () => {
  if (process.env.NODE_ENV === "production") {
    return false;
  }
  const isStrictMode = React.useRef(void 0);
  const reactMajorVersion = React.useMemo(() => {
    return Number(React.version.split(".")[0]);
  }, [React.version]);
  if (isNaN(reactMajorVersion) || reactMajorVersion < 18) {
    return false;
  }
  if (isStrictMode.current === void 0) {
    let currentOwner = getCurrentOwner();
    while (currentOwner.return) {
      currentOwner = currentOwner.return;
      if (currentOwner.type === REACT_STRICT_MODE_TYPE || currentOwner.elementType === REACT_STRICT_MODE_TYPE) {
        isStrictMode.current = true;
      }
    }
  }
  return !!isStrictMode.current;
};

// src/useDisposable.ts
var React4 = __toESM(require("react"), 1);

// src/useStrictEffect.ts
var React2 = __toESM(require("react"), 1);
var effectSet = /* @__PURE__ */ new WeakSet();
function useStrictEffect(effect, deps) {
  const currentOwner = getCurrentOwner();
  React2.useEffect(() => {
    if (!effectSet.has(currentOwner)) {
      effectSet.add(currentOwner);
      effect();
      return;
    }
    const dispose = effect();
    return dispose;
  }, deps);
}

// src/useStrictMemo.ts
var React3 = __toESM(require("react"), 1);
var memoSet = /* @__PURE__ */ new WeakSet();
function useStrictMemo(factory, deps) {
  return React3.useMemo(() => {
    const currentOwner = getCurrentOwner();
    if (!memoSet.has(currentOwner)) {
      memoSet.add(currentOwner);
      return null;
    }
    return factory();
  }, deps);
}

// src/useDisposable.ts
function useDisposable(factory, deps) {
  var _a;
  const isStrictMode = useIsStrictMode() && process.env.NODE_ENV !== "production";
  const useMemo4 = isStrictMode ? useStrictMemo : React4.useMemo;
  const useEffect3 = isStrictMode ? useStrictEffect : React4.useEffect;
  const [disposable, dispose] = (_a = useMemo4(() => factory(), deps)) != null ? _a : [
    null,
    () => null
  ];
  useEffect3(() => {
    return dispose;
  }, deps);
  return disposable;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useDisposable,
  useIsStrictMode
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy91c2VJc1N0cmljdE1vZGUudHMiLCAiLi4vc3JjL3VzZURpc3Bvc2FibGUudHMiLCAiLi4vc3JjL3VzZVN0cmljdEVmZmVjdC50cyIsICIuLi9zcmMvdXNlU3RyaWN0TWVtby50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZXhwb3J0IHsgdXNlSXNTdHJpY3RNb2RlIH0gZnJvbSBcIi4vdXNlSXNTdHJpY3RNb2RlXCI7XG5leHBvcnQgeyB1c2VEaXNwb3NhYmxlIH0gZnJvbSBcIi4vdXNlRGlzcG9zYWJsZVwiO1xuZXhwb3J0IHR5cGUgeyBEaXNwb3NhYmxlRmFjdG9yeSB9IGZyb20gXCIuL3R5cGVzXCI7XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8qKlxuICogQHJldHVybnMgQ3VycmVudCByZWFjdCBmaWJlciBiZWluZyByZW5kZXJlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudE93bmVyID0gKCkgPT5cbiAgLy8gQHRzLWlnbm9yZSAtIHVzaW5nIHJlYWN0IGludGVybmFsc1xuICBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lclxuICAgIC5jdXJyZW50O1xuXG5jb25zdCBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gLyojX19QVVJFX18qLyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG5cbi8qKlxuICogVHJhdmVyc2VzIHVwIHRoZSBSZWFjdCBmaWJlciB0cmVlIHRvIGZpbmQgdGhlIFN0cmljdE1vZGUgY29tcG9uZW50LlxuICogTm90ZTogVGhpcyBvbmx5IGRldGVjdHMgc3RyaWN0IG1vZGUgZnJvbSBSZWFjdCA+PSAxOFxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTlcbiAqIEByZXR1cm5zIElmIHN0cmljdCBtb2RlIGlzIGJlaW5nIHVzZWQgaW4gdGhlIFJlYWN0IHRyZWVcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUlzU3RyaWN0TW9kZSA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gVGhpcyBjaGVjayB2aW9sYXRlcyBSdWxlcyBvZiBIb29rcywgYnV0IFwicHJvY2Vzcy5lbnYuTk9ERV9FTlZcIiBkb2VzIG5vdCBjaGFuZ2UgaW4gYnVuZGxlXG4gIC8vIG9yIGR1cmluZyBhcHBsaWNhdGlvbiBsaWZlY3ljbGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGlzU3RyaWN0TW9kZSA9IFJlYWN0LnVzZVJlZjxib29sZWFuIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCByZWFjdE1ham9yVmVyc2lvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBOdW1iZXIoUmVhY3QudmVyc2lvbi5zcGxpdChcIi5cIilbMF0pO1xuICB9LCBbUmVhY3QudmVyc2lvbl0pO1xuXG4gIGlmIChpc05hTihyZWFjdE1ham9yVmVyc2lvbikgfHwgcmVhY3RNYWpvclZlcnNpb24gPCAxOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1N0cmljdE1vZGUuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGN1cnJlbnRPd25lciA9IGdldEN1cnJlbnRPd25lcigpO1xuICAgIHdoaWxlIChjdXJyZW50T3duZXIucmV0dXJuKSB7XG4gICAgICBjdXJyZW50T3duZXIgPSBjdXJyZW50T3duZXIucmV0dXJuO1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50T3duZXIudHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgICAgICBjdXJyZW50T3duZXIuZWxlbWVudFR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEVcbiAgICAgICkge1xuICAgICAgICBpc1N0cmljdE1vZGUuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICEhaXNTdHJpY3RNb2RlLmN1cnJlbnQ7XG59O1xuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBEaXNwb3NhYmxlRmFjdG9yeSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyB1c2VJc1N0cmljdE1vZGUgfSBmcm9tIFwiLi91c2VJc1N0cmljdE1vZGVcIjtcbmltcG9ydCB7IHVzZVN0cmljdEVmZmVjdCB9IGZyb20gXCIuL3VzZVN0cmljdEVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlU3RyaWN0TWVtbyB9IGZyb20gXCIuL3VzZVN0cmljdE1lbW9cIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBpbnN0YW5jZSBkdXJpbmcgKipyZW5kZXIgdGltZSoqIHRoYXQgd2lsbFxuICogYmUgY3JlYXRlZCBvbmNlIChiYXNlZCBvbiBkZXBlbmRlbmN5IGFycmF5KSBldmVuIGR1cmluZyBzdHJpY3QgbW9kZS5cbiAqIFRoZSBkaXNwb3NhYmxlIHdpbGwgYmUgZGlzcG9zZWQgYmFzZWQgb24gdGhlIGRlcGVuZGVuY3kgYXJyYXkgc2ltaWxhciB0b1xuICogdXNlRWZmZWN0LlxuICpcbiAqIFx1MjZBMFx1RkUwRiBUaGlzIGNhbiBvbmx5IGJlIGNhbGxlZCAqKm9uY2UqKiBwZXIgY29tcG9uZW50XG4gKiBAcGFyYW0gZmFjdG9yeSAtIGZhY3RvcnkgZm9yIGRpc3Bvc2FibGUgYW5kIGl0cyBkaXNwb3NlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZGVwcyAtIFNpbWlsYXIgdG8gYSBSZWFjdCBkZXBlbmRlbmN5IGFycmF5XG4gKiBAcmV0dXJucyAtIFRoZSBkaXNwb3NhYmxlIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEaXNwb3NhYmxlPFRJbnN0YW5jZT4oXG4gIGZhY3Rvcnk6IERpc3Bvc2FibGVGYWN0b3J5PFRJbnN0YW5jZT4sXG4gIGRlcHM6IGFueVtdXG4pIHtcbiAgLy8gSW4gcHJvZHVjdGlvbiwgc3RyaWN0IG1vZGUgZG9lcyBub3QgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nXG4gIGNvbnN0IGlzU3RyaWN0TW9kZSA9XG4gICAgdXNlSXNTdHJpY3RNb2RlKCkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiO1xuXG4gIGNvbnN0IHVzZU1lbW8gPSBpc1N0cmljdE1vZGUgPyB1c2VTdHJpY3RNZW1vIDogUmVhY3QudXNlTWVtbztcbiAgY29uc3QgdXNlRWZmZWN0ID0gaXNTdHJpY3RNb2RlID8gdXNlU3RyaWN0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4gIGNvbnN0IFtkaXNwb3NhYmxlLCBkaXNwb3NlXSA9IHVzZU1lbW8oKCkgPT4gZmFjdG9yeSgpLCBkZXBzKSA/PyBbXG4gICAgbnVsbCxcbiAgICAoKSA9PiBudWxsLFxuICBdO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBkaXNwb3NlO1xuICB9LCBkZXBzKTtcblxuICByZXR1cm4gZGlzcG9zYWJsZTtcbn1cbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldEN1cnJlbnRPd25lciB9IGZyb20gXCIuL3VzZUlzU3RyaWN0TW9kZVwiO1xuXG4vLyB3ZSBrbm93IHN0cmljdCBtb2RlIHdpbGwgcmVuZGVyIHVzZU1lbW8gZmFjb3J5IHR3aWNlXG4vLyBrZWVwIGEgd2VhayBzZXQgdG8gZGV0ZWN0IHdoZW4gdGhlIHNlY29uZCByZW5kZXIgaGFwcGVuc1xuY29uc3QgZWZmZWN0U2V0ID0gbmV3IFdlYWtTZXQoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0cmljdEVmZmVjdChcbiAgZWZmZWN0OiAoKSA9PiAoKSA9PiB2b2lkLFxuICBkZXBzOiBSZWFjdC5EZXBlbmRlbmN5TGlzdCB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IGN1cnJlbnRPd25lciA9IGdldEN1cnJlbnRPd25lcigpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZWZmZWN0U2V0LmhhcyhjdXJyZW50T3duZXIpKSB7XG4gICAgICBlZmZlY3RTZXQuYWRkKGN1cnJlbnRPd25lcik7XG4gICAgICBlZmZlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwb3NlID0gZWZmZWN0KCk7XG4gICAgcmV0dXJuIGRpc3Bvc2U7XG4gIH0sIGRlcHMpO1xufVxuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudE93bmVyIH0gZnJvbSBcIi4vdXNlSXNTdHJpY3RNb2RlXCI7XG5cbi8vIHdlIGtub3cgc3RyaWN0IG1vZGUgd2lsbCByZW5kZXIgdXNlTWVtbyBmYWNvcnkgdHdpY2Vcbi8vIGtlZXAgYSB3ZWFrIHNldCB0byBkZXRlY3Qgd2hlbiB0aGUgc2Vjb25kIHJlbmRlciBoYXBwZW5zXG5jb25zdCBtZW1vU2V0ID0gbmV3IFdlYWtTZXQoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0cmljdE1lbW88VE1lbW9pemVkPihcbiAgZmFjdG9yeTogKCkgPT4gYW55LFxuICBkZXBzOiBSZWFjdC5EZXBlbmRlbmN5TGlzdCB8IHVuZGVmaW5lZFxuKTogVE1lbW9pemVkIHwgbnVsbCB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50T3duZXIgPSBnZXRDdXJyZW50T3duZXIoKTtcbiAgICBpZiAoIW1lbW9TZXQuaGFzKGN1cnJlbnRPd25lcikpIHtcbiAgICAgIG1lbW9TZXQuYWRkKGN1cnJlbnRPd25lcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFjdG9yeSgpO1xuICB9LCBkZXBzKTtcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxZQUF1QjtBQUtoQixJQUFNLGtCQUFrQixNQUV2Qix5REFBbUQsa0JBQ3REO0FBRUwsSUFBTSx5QkFBdUMsdUJBQU8sSUFBSSxtQkFBbUI7QUFRcEUsSUFBTSxrQkFBa0IsTUFBZTtBQUc1QyxNQUFJLFFBQVEsSUFBSSxhQUFhLGNBQWM7QUFDekMsV0FBTztBQUFBLEVBQ1Q7QUFFQSxRQUFNLGVBQXFCLGFBQTRCLE1BQVM7QUFDaEUsUUFBTSxvQkFBMEIsY0FBUSxNQUFNO0FBQzVDLFdBQU8sT0FBYSxjQUFRLE1BQU0sR0FBRyxFQUFFLEVBQUU7QUFBQSxFQUMzQyxHQUFHLENBQU8sYUFBTyxDQUFDO0FBRWxCLE1BQUksTUFBTSxpQkFBaUIsS0FBSyxvQkFBb0IsSUFBSTtBQUN0RCxXQUFPO0FBQUEsRUFDVDtBQUVBLE1BQUksYUFBYSxZQUFZLFFBQVc7QUFDdEMsUUFBSSxlQUFlLGdCQUFnQjtBQUNuQyxXQUFPLGFBQWEsUUFBUTtBQUMxQixxQkFBZSxhQUFhO0FBQzVCLFVBQ0UsYUFBYSxTQUFTLDBCQUN0QixhQUFhLGdCQUFnQix3QkFDN0I7QUFDQSxxQkFBYSxVQUFVO0FBQUEsTUFDekI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUVBLFNBQU8sQ0FBQyxDQUFDLGFBQWE7QUFDeEI7OztBQ2hEQSxJQUFBQSxTQUF1Qjs7O0FDQXZCLElBQUFDLFNBQXVCO0FBS3ZCLElBQU0sWUFBWSxvQkFBSSxRQUFRO0FBRXZCLFNBQVMsZ0JBQ2QsUUFDQSxNQUNBO0FBQ0EsUUFBTSxlQUFlLGdCQUFnQjtBQUNyQyxFQUFNLGlCQUFVLE1BQU07QUFDcEIsUUFBSSxDQUFDLFVBQVUsSUFBSSxZQUFZLEdBQUc7QUFDaEMsZ0JBQVUsSUFBSSxZQUFZO0FBQzFCLGFBQU87QUFDUDtBQUFBLElBQ0Y7QUFFQSxVQUFNLFVBQVUsT0FBTztBQUN2QixXQUFPO0FBQUEsRUFDVCxHQUFHLElBQUk7QUFDVDs7O0FDdEJBLElBQUFDLFNBQXVCO0FBS3ZCLElBQU0sVUFBVSxvQkFBSSxRQUFRO0FBRXJCLFNBQVMsY0FDZCxTQUNBLE1BQ2tCO0FBQ2xCLFNBQWEsZUFBUSxNQUFNO0FBQ3pCLFVBQU0sZUFBZSxnQkFBZ0I7QUFDckMsUUFBSSxDQUFDLFFBQVEsSUFBSSxZQUFZLEdBQUc7QUFDOUIsY0FBUSxJQUFJLFlBQVk7QUFDeEIsYUFBTztBQUFBLElBQ1Q7QUFFQSxXQUFPLFFBQVE7QUFBQSxFQUNqQixHQUFHLElBQUk7QUFDVDs7O0FGSE8sU0FBUyxjQUNkLFNBQ0EsTUFDQTtBQXBCRjtBQXNCRSxRQUFNLGVBQ0osZ0JBQWdCLEtBQUssUUFBUSxJQUFJLGFBQWE7QUFFaEQsUUFBTUMsV0FBVSxlQUFlLGdCQUFzQjtBQUNyRCxRQUFNQyxhQUFZLGVBQWUsa0JBQXdCO0FBRXpELFFBQU0sQ0FBQyxZQUFZLE9BQU8sS0FBSSxLQUFBRCxTQUFRLE1BQU0sUUFBUSxHQUFHLElBQUksTUFBN0IsWUFBa0M7QUFBQSxJQUM5RDtBQUFBLElBQ0EsTUFBTTtBQUFBLEVBQ1I7QUFDQSxFQUFBQyxXQUFVLE1BQU07QUFDZCxXQUFPO0FBQUEsRUFDVCxHQUFHLElBQUk7QUFFUCxTQUFPO0FBQ1Q7IiwKICAibmFtZXMiOiBbIlJlYWN0IiwgIlJlYWN0IiwgIlJlYWN0IiwgInVzZU1lbW8iLCAidXNlRWZmZWN0Il0KfQo=